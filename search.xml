<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git 实用方法</title>
    <url>/2020/12/11/Git/Git%20%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>Git 的一些实用方法。</p>
<a id="more"></a>

<h2 id="git-clean-删除未追踪的文件和目录"><a href="#git-clean-删除未追踪的文件和目录" class="headerlink" title="git clean - 删除未追踪的文件和目录"></a>git clean - 删除未追踪的文件和目录</h2><p>删除一些没有git add的文件；</p>
<p>git clean 参数：<br>-n 显示将要删除的文件和目录<br>-f 删除文件，-df删除文件和目录</p>
<h2 id="git-archive-打包"><a href="#git-archive-打包" class="headerlink" title="git archive - 打包"></a>git archive - 打包</h2><p>如果使用压缩工具（tar、7zip、winzip、rar等）将工作区文件归档，一不小心会把版本库（.git目录）包含其中，甚至将工作区中的忽略文件、临时文件也包含其中。  </p>
<p>Git提供了一个归档命令：<code>gitarchive</code>，可以对任意提交对应的目录树建立归档。  </p>
<p>如，基于最新提交建立归档文件 latest.zip。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$git archive -o latest.zip HEAD</span><br></pre></td></tr></table></figure>

<h2 id="git-commit-m-换行"><a href="#git-commit-m-换行" class="headerlink" title="git commit -m 换行"></a>git commit -m 换行</h2><p>在消息前使用单引号，输完一行后换行，这将使Bash提示另一行，直到关闭引号为止。像这样：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;Message</span></span><br><span class="line"><span class="string">goes</span></span><br><span class="line"><span class="string">here&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>ECDSA</title>
    <url>/2020/12/11/Security/ECDSA/</url>
    <content><![CDATA[<p>参考：<a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">Elliptic Curve Digital Signature Algorithm</a></p>
<p>ECDSA，椭圆曲线数字签名算法，也即使用了<code>椭圆曲线密码学</code>的<code>数字签名算法</code>。</p>
<p>wikipeida 的定义如下：</p>
<blockquote>
<p>In <a href="https://en.wikipedia.org/wiki/Cryptography">cryptography</a>, the <strong>Elliptic Curve Digital Signature Algorithm</strong> (<strong>ECDSA</strong>) offers a variant of the <a href="https://en.wikipedia.org/wiki/Digital_Signature_Algorithm">Digital Signature Algorithm</a> (DSA) which uses <a href="https://en.wikipedia.org/wiki/Elliptic_curve_cryptography">elliptic curve cryptography</a>.</p>
</blockquote>
<p>可以把 ECDSA 可以拆解成两部分：ECC 和 DSA。</p>
<a id="more"></a>

<h2 id="ECDSA"><a href="#ECDSA" class="headerlink" title="ECDSA"></a>ECDSA</h2><h3 id="Fundamentals"><a href="#Fundamentals" class="headerlink" title="Fundamentals"></a>Fundamentals</h3><p><a href="https://www.maximintegrated.com/en/app-notes/index.mvp/id/5767">The Fundamentals of an ECDSA Authentication System</a> - ==强力推荐！==</p>
<p>虽然椭圆曲线有无数个，但只有很小一部分适合 ECC，NIST推荐使用这些椭圆曲线并将其写入标准，每个曲线都有一个名称并由一个参数集来定义，参数集由 Prime Modulus p, the Prime Order n, the Coefficient a, the Coefficient b, and the x and y coordinates of the Base Point G(x,y) on the curve 组成。如 <strong>Curve P-192</strong> 的参数如下：</p>
<p><img src="/2020/12/11/Security/ECDSA/image-20201123232221536.png"></p>
<p>私钥是个随机数，公钥由私钥和椭圆曲线产生，公钥由 x 和 y 值组成：</p>
<p><img src="/2020/12/11/Security/ECDSA/image-20201123232239565.png"></p>
<p>数字签名由私钥，椭圆曲线，随机数和消息的摘要产生：</p>
<p><img src="/2020/12/11/Security/ECDSA/image-20201123232258442.png"></p>
<p>验证结果由公钥，椭圆曲线，数字签名和消息的摘要产生：</p>
<p><img src="/2020/12/11/Security/ECDSA/image-20201123232313357.png"></p>
<h3 id="Digital-signature"><a href="#Digital-signature" class="headerlink" title="Digital signature"></a>Digital signature</h3><p>参考：<a href="https://superuser.com/questions/1023167/can-i-extract-r-and-s-from-an-ecdsa-signature-in-bit-form-and-vica-versa">Can I extract R and S from an ECDSA signature in bit form, and vica versa?</a></p>
<p>ECDSA 数字签名由 r 和 s 组成，r 和 s 的长度和私钥 d 长度相同。</p>
<p>实际使用的 ECDSA 一般是 DER 格式的文件，除了 r 和 s 外还有其他信息。</p>
<p>以一个例子来说明 DER 格式 ECDSA 数字签名的格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x30, 0x45, &#x2F;&#x2F; Sequence of length 69 to follow</span><br><span class="line">0x02, 0x21, &#x2F;&#x2F; Integer of length 33 to follow</span><br><span class="line">0x00, &#x2F;&#x2F; If first byte of the 32 byte integer is &gt;0x7F, an extra 0x00 byte is prepended</span><br><span class="line">&#x2F;&#x2F; Here come the 32 bytes (r):</span><br><span class="line">0xC5, 0x79, 0xA7, 0xB6, 0x01, 0xBF, 0x5D, 0x69, 0x93, 0x50, 0x58, 0x02, 0xE5, 0x8C, 0xFA, 0x61, 0x2F, 0x7C, 0x72, 0xA5, 0x47, 0xEC, 0x6E, 0x2B, 0x72, 0x88, 0xDE, 0x5C, 0xC7, 0x10, 0x1D, 0xE8, </span><br><span class="line">0x02, 0x20, &#x2F;&#x2F; Integer of length 32 to follow</span><br><span class="line">&#x2F;&#x2F; Here come the 32 bytes (s):</span><br><span class="line">0x1D, 0xF6, 0x15, 0xA8, 0x9B, 0xC8, 0x41, 0x89, 0x0F, 0x59, 0xEF, 0x3F, 0x04, 0x5D, 0x52, 0x41, 0xAE, 0xB7, 0x95, 0xE2, 0xC6, 0x4B, 0xE3, 0xA5, 0xD1, 0x85, 0xB8, 0x8F, 0x95, 0x4E, 0xB4, 0x01, </span><br></pre></td></tr></table></figure>

<p>0x30 代表着下面是个 Sequence，长度为 0x45，0x02 代表下面是个 Integer，长度是 0x21，然后是另一个 Integer，长度是 0x20。</p>
<p>为什么第一个 integer 的长度是 0x21 呢，因为 integer 是带符号类型的，所以如果第一个字节的 MSB 是 1（ &gt; 0x7F），就要额外在前面补个 0x00。</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>参考：</p>
<p><a href="https://github.com/warner/python-ecdsa">https://github.com/warner/python-ecdsa</a></p>
<p>openssl 提供了 ECDSA 的一些命令。</p>
<h3 id="生成-EC-私钥"><a href="#生成-EC-私钥" class="headerlink" title="生成 EC 私钥"></a>生成 EC 私钥</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl ecparam -name secp224r1 -genkey -out sk.pem</span><br></pre></td></tr></table></figure>

<p><a href="https://www.openssl.org/docs/manmaster/man1/ecparam.html">https://www.openssl.org/docs/manmaster/man1/ecparam.html</a></p>
<p>其中，-name secp2241r1 是椭圆曲线参数，使用 openssl ecparam -list_curves 可以查看所有的椭圆曲线参数。</p>
<h3 id="从-EC-私钥中提取公钥"><a href="#从-EC-私钥中提取公钥" class="headerlink" title="从 EC 私钥中提取公钥"></a>从 EC 私钥中提取公钥</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl ec -in sk.pem -pubout -out vk.pem</span><br></pre></td></tr></table></figure>

<p><a href="https://www.openssl.org/docs/manmaster/man1/ec.html">https://www.openssl.org/docs/manmaster/man1/ec.html</a></p>
<h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl dgst -sha256 -sign sk.pem -out data.sig data</span><br></pre></td></tr></table></figure>

<p><a href="https://www.openssl.org/docs/manmaster/man1/dgst.html">https://www.openssl.org/docs/manmaster/man1/dgst.html</a></p>
<p>其中，-sha256 是消息摘要算法。</p>
<h3 id="验签"><a href="#验签" class="headerlink" title="验签"></a>验签</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl dgst -sha256 -verify vk.pem -signature data.sig data</span><br></pre></td></tr></table></figure>

<h3 id="从证书中提取公钥"><a href="#从证书中提取公钥" class="headerlink" title="从证书中提取公钥"></a>从证书中提取公钥</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl x509 -in cert.pem  -noout -pubkey &gt; vk.pem</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/pixy/p/4722381.html">https://www.cnblogs.com/pixy/p/4722381.html</a></p>
<h3 id="查看私钥"><a href="#查看私钥" class="headerlink" title="查看私钥"></a>查看私钥</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl ec -in sk.pem -text -noout</span><br></pre></td></tr></table></figure>

<h3 id="查看公钥"><a href="#查看公钥" class="headerlink" title="查看公钥"></a>查看公钥</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl ec -in vk.pem -pubin -text -noout</span><br></pre></td></tr></table></figure>

<h3 id="SHA256-计算"><a href="#SHA256-计算" class="headerlink" title="SHA256 计算"></a>SHA256 计算</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl dgst -sha256 file</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/gordon0918/p/5382541.html">https://www.cnblogs.com/gordon0918/p/5382541.html</a></p>
<h3 id="由-R-和-S-生成-DER-文件"><a href="#由-R-和-S-生成-DER-文件" class="headerlink" title="由 R 和 S 生成 .DER 文件"></a>由 R 和 S 生成 .DER 文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># Author : Snow Yang</span><br><span class="line"></span><br><span class="line">import struct, sys</span><br><span class="line"></span><br><span class="line">def print_usage():</span><br><span class="line">    print &quot;&quot;</span><br><span class="line">    print &quot;Usage:&quot;</span><br><span class="line">    print sys.argv[0]</span><br><span class="line">    print &quot; &lt;r&gt; &lt;s&gt;&quot;</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    if len(sys.argv) !&#x3D; 3 or len(sys.argv[1]) !&#x3D; 64 or len(sys.argv[2]) !&#x3D; 64:</span><br><span class="line">        print_usage()</span><br><span class="line">        sys.exit(2)</span><br><span class="line"></span><br><span class="line">    r &#x3D; sys.argv[1]</span><br><span class="line">    s &#x3D; sys.argv[2]</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        r &#x3D; r.decode(&#39;hex&#39;)</span><br><span class="line">        s &#x3D; s.decode(&#39;hex&#39;)</span><br><span class="line">    except:</span><br><span class="line">        print_usage()</span><br><span class="line">        sys.exit(2)</span><br><span class="line"></span><br><span class="line">    int_len_r &#x3D; 0x20</span><br><span class="line">    int_len_s &#x3D; 0x20</span><br><span class="line">    if r[0] &gt; &#39;\x7F&#39;:</span><br><span class="line">        int_len_r +&#x3D; 1</span><br><span class="line">    if s[0] &gt; &#39;\x7F&#39;:</span><br><span class="line">        int_len_s +&#x3D; 1</span><br><span class="line">    seq_len &#x3D; 0x04 + int_len_r + int_len_s</span><br><span class="line"></span><br><span class="line">    with open(&#39;sig.der&#39;, &#39;wb&#39;) as f:</span><br><span class="line">        f.write(&#39;\x30&#39;)</span><br><span class="line">        f.write(struct.pack(&#39;&lt;B&#39;, seq_len))</span><br><span class="line"></span><br><span class="line">        f.write(&#39;\x02&#39;)</span><br><span class="line">        f.write(struct.pack(&#39;&lt;B&#39;, int_len_r))</span><br><span class="line">        if int_len_r &gt; 0x20:</span><br><span class="line">            f.write(&#39;\x00&#39;)</span><br><span class="line">        f.write(r)</span><br><span class="line"></span><br><span class="line">        f.write(&#39;\x02&#39;)</span><br><span class="line">        f.write(struct.pack(&#39;&lt;B&#39;, int_len_s))</span><br><span class="line">        if int_len_s &gt; 0x20:</span><br><span class="line">            f.write(&#39;\x00&#39;)</span><br><span class="line">        f.write(s)        </span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    try:</span><br><span class="line">        main()</span><br><span class="line">    except KeyboardInterrupt:</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Security</category>
      </categories>
  </entry>
  <entry>
    <title>新和稳</title>
    <url>/2020/12/11/Thinking/%E6%96%B0%E5%92%8C%E7%A8%B3/</url>
    <content><![CDATA[<h2 id="用新还是用稳"><a href="#用新还是用稳" class="headerlink" title="用新还是用稳"></a>用新还是用稳</h2><p>在做 GATT CLI 时，GATT Client 有两个选择：</p>
<ul>
<li>Bluepy。BlueZ 的 Python 封装，运行在 Linux 上。</li>
<li>Zephyr。运行在 MCU 上。</li>
</ul>
<p>最初选择了 bluepy，因为得益于 Bluepy 的 Python 封装，编写和调试特别方便。并且可以运行在电脑上，无需外接设备。</p>
<p>但在实施过程中发现了一些问题：</p>
<ul>
<li><p>树莓派支持最好，但其它平台有问题。</p>
</li>
<li><p>启动蓝牙慢</p>
</li>
<li><p>连接 peripheral 慢</p>
</li>
<li><p>扫描信息不准确（macOS 的 Linux 虚拟机上）</p>
</li>
<li><p>偶现断开连接。</p>
</li>
<li><p>文档不全</p>
</li>
<li><p>难以调试</p>
</li>
</ul>
<p>总结下来就是：<code>不稳定，不熟悉，不放心</code>。</p>
<p>可以做 demo，但不可做产品。</p>
<p>最后还是选择了稳定并且熟悉的 Zephyr + nRF52832 组合。速度快，稳定，好调试。</p>
]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
  </entry>
  <entry>
    <title>SWD 协议学习</title>
    <url>/2020/12/11/BSP/SWD/SWD%20%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>SWD - Serial Wire Debug，是一种两线制的 ARM 调试接口，是 JTAG 接口的一种替换。</p>
<a id="more"></a>

<h2 id="SWD-协议概览"><a href="#SWD-协议概览" class="headerlink" title="SWD 协议概览"></a>SWD 协议概览</h2><p><a href="https://blog.csdn.net/u010066882/article/details/56030473">https://blog.csdn.net/u010066882/article/details/56030473</a></p>
<p>主要参考 ARM 官方文档：ARM Debug Interface Architecture Specification ADIv5.0 to ADIv5.2 </p>
<p>ADI 是 ARM Debug Interface，目前是 ADIv5，即 version 5。</p>
<p>在 ADIv5 之前都是基于 IEEE 1149.1 JTAG interface 的实现，从 ADIv5 开始有了一个新的接口 SWD - Serial Wire Debug interface，所以 JTAG 是 SWD 是完全不同的两种接口。</p>
<p>ADIv5 分为两大部分：DP - Debug Port 和 AP - Access Port。</p>
<p>Debug Port 有两种： JTAG-DP 和 SW-DP</p>
<p>Access Port 也有两种：</p>
<p>​    JTAG-AP, for accessing legacy JTAG components.</p>
<p>​    MEM-AP, for accessing memory and components with memory-mapped interfaces.</p>
<p>DAP 是 Debug Access Port，是对 ADI 的具体实现，其实就是 DP + AP。</p>
<p>关于 SWD 接口的文档和翻译（个人理解）：</p>
<p>The SWD protocol uses a synchronous serial interface, which comprises a single bidirectional data signal, and a clock signal. </p>
<p>SWD 协议使用的是同步串行接口，包含一个双向数据信号线和一个时钟线。</p>
<p>When the target samples SWDIO, sampling is performed on the rising edge of SWCLK. When the target drives SWDIO, or stops driving it, signal changes are performed on the rising edge of SWCLK.</p>
<p><strong>当 MCU 在接收时，在时钟的上升沿采集数据，当 MCU 在发送时，在时钟的上升沿改变数据（也就意味着主机在时钟的下降沿采集数据）。</strong></p>
<p>The clock can be sourced from the target and exported, or provided by the host. This clock is then used by the host as a reference for generation and sampling of data so that the target is not required to perform any over-sampling.</p>
<p>Both the target and host can drive the bus HIGH and LOW or tristate it. The ports must be able to tolerate short periods of contention that might occur because of a loss of synchronization.</p>
<p>时钟可以由主机提供，也可以由 MCU 提供（没想到吧），由 MCU 来提供的好处是 MCU 不需要过采样了（此处不解，SWD 不是同步串行接口吗，为什么要过采样？）</p>
<p>由于主机和 MCU 都可以驱动总线，所以接口要能容忍因不同步造成的短暂电平竞争。</p>
<p>To make sure that the line is in a known state when neither host nor target is driving the line, a 100KΩ pull-up is required at the target. This pull-up can only be relied on to maintain the state of the wire. If the wire is driven LOW and released, the pull-up resistor eventually returns the line to the HIGH state, but this process takes many clock periods.</p>
<p>The pull-up is intended to prevent false detection of signals when no host is connected, and must be of a suitably high value to reduce current consumption from the target when the host actively pulls down the line.</p>
<p>为了让 SWD 接口悬空时能有一个确定的状态，MCU 上需要有一个 100K 的上拉电阻（所以说 MCU 芯片内部就已经有 100K 上拉了？）</p>
<p>A debugger must use a line reset sequence to ensure that hot-plugging the serial connection does not result in unintentional transfers. The line reset sequence ensures that the SW-DP is synchronized correctly to the header that signals a connection.</p>
<p>The SWD interface does not include a reset signal. A line reset is achieved by holding the data signal HIGH for at least 50 clock cycles, followed by at least two idle cycles. Figure B4-8 on page B4-123 shows the interface timing for a line reset followed by a DP DPIDR register read.</p>
<p>主机在连接 MCU 后首先要复位 SW-DP（注意，只是 Debug Port），然后才能后续的通信。以防止 SW-DP 处于不确定的状态。</p>
<p>由于 SWD 接口没有定义复位信号线，所以是通过一个特定的序列来实现复位的，具体是就是，保持数据线为高时发送至少 50 个时钟，然后再发送 2 个空闲周期。</p>
<p>Idle cycles，The host clocks the SWD interface with the line LOW to insert idle cycles.</p>
<p>空闲周期就是保持数据线为低时发送时钟。</p>
<p><img src="/2020/12/11/BSP/SWD/SWD%20%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20201123233156760.png"></p>
<p><strong>Basic operation</strong></p>
<p>The ARM SWD interface uses a single bidirectional data connection and a separate clock to transfer data synchronously. An operation on the wire consists of two or three phases:</p>
<p><strong>Packet request</strong></p>
<p>​    The external host debugger issues a request to the DP. The DP is the target of the request.</p>
<p><strong>Acknowledge response</strong></p>
<p>​    The target sends an acknowledge response to the host.</p>
<p><strong>Data transfer phase</strong></p>
<p>​    This phase is only present when either: </p>
<p>​        A data read or data write request is followed by a valid (OK) acknowledge response. </p>
<p>​        The CTRL/STAT.ORUNDETECT flag is 0b1. </p>
<p>​    The data transfer is one of: </p>
<p>​        Target to host, following a read request (RDATA).</p>
<p>​        Host to target, following a write request (WDATA).</p>
<p>每个 SWD <strong>基本操作</strong>由 3 步组成：请求 - 响应 - 数据（可选）</p>
<p>When the SW-DP receives a packet request from the debug host, it must respond immediately by entering the acknowledge phase. There is a turnaround period between these phases, as they are in different directions. If a data phase is required, it follows immediately after the acknowledge phase.</p>
<p>SW-DP 在收到主机的请求后，必须立即发出响应，然后才是可选的数据传输。这点和其他常见协议不同。</p>
<p><img src="/2020/12/11/BSP/SWD/SWD%20%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20201123233221700.png" alt="image-20201123233221700"></p>
<p><strong>Line turnaround</strong></p>
<p>To prevent contention, a turnaround period is required when the device driving the wire changes. For the turnaround period, neither the host nor the target drives the wire, and the state of the wire is undefined. See also Line pull-up on page B4-122.</p>
<p>Note</p>
<p>The line turnaround period can provide for pad delays when using a high sample clock frequency.</p>
<p>The length of the turnaround period is controlled by DLCR.TURNROUND. The default setting is a turnaround period of one clock cycle.</p>
<p>在 2 步之间，若数据线需要改变方向，那么会插入一个 turnaround 周期，用来给双方改变 IO 方向的时间，防止电平竞争。默认的 turnaround 时间是一个时钟。</p>
<p>![屏幕快照 2018-05-30 下午1.47.26](../resources/屏幕快照 2018-05-30 下午1.47.26.png)</p>
<p><strong>SELECT 和 Bandk</strong></p>
<p>主要参考章节：Using the Debug Port to access Access Ports</p>
<p>DPACC 用以访问 Debug Port 寄存器，APACC 用以访问 Access Port 寄存器。他们是一个<strong>基本操作</strong>，这个操作中指定的 RnW 位用以配置读/写操作，A[3:2] 域用以选择寄存器地址，Data[31:0] 是具体写的数据。</p>
<p>DP 只有 4 个寄存器（DPv0），A[3:2]  4 个地址刚好够用，但是 AP 可以有多个，并且每个 AP 也包含了多个寄存器，A[3:2]  地址完全不够用，怎么办呢？</p>
<p>于是每个 AP 中的寄存器被分为了多个 Bank，每个 Bank 内都有 4 个寄存器。使用 DP 中的 SELECT 寄存器的 APSEL 和 APBANKSEL 域分别选择一个 AP 和其中的一个 Bank。然后再用 APACC 的 A[3:2] 来选择 Bank 中 4 个寄存器其中的一个。</p>
<p>同样地，最新版本的 DP 扩展多个寄存器，以 DPv2 为例，其 0x4 地址被 5 个寄存器复用，要通过 SELECT 内的 DPBANKSEL 来选择使用哪一个。</p>
<p>文档中也给出了一个例子：</p>
<p>For example, to access the register at address 0x14 in the AP that is selected when SELECT.APSEL is 0x00, the debugger must: </p>
<p>• Use a DP register write to set: </p>
<p>​    — SELECT.APSEL to 0x00. </p>
<p>​    — SELECT.APBANKSEL to 0x1. </p>
<p>• Use an AP register access with A[3:2] = 0b01.</p>
<p>The DAP combines A[3:2] with SELECT.APBANKSEL to generate the AP register address, 0x14. The debugger can access any of the four registers from 0x10 to 0x1C without changing SELECT.</p>
<p>注意：SELECT，顾名思义，是用来选择的，若已经通过配置此寄存器选择好了 AP 和 Bank，那么接下来访问相同 AP 内相同 Bank 内的任意寄存器前就不用再次写 SELECT 寄存器了。可以把 SELECT 寄存器看作是总线复用器/多路选择器，只有在需要访问其他 AP 或 Bank 时才需要更新对应的域值。</p>
<p><img src="/2020/12/11/BSP/SWD/SWD%20%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20201123233240741.png"></p>
<p><strong>具体到 SWD 上的 APACC 和 DPACC</strong></p>
<p>举个写 CFG 寄存器的例子：</p>
<p>CFG 是属于 AP 的一个寄存器，地址为 0xF4。</p>
<p>第一步：通过 Packet Request 内 APnDP 置 0 来选择 DPACC，Rnw 置 1 来选择写操作，A[3:2] 置 0x8 来选择写 DP 内的 SELECT 寄存器，然后在 Data transfer phase 时把 CFG 寄存器所属于的 AP（0x0） 和 Bank（0xF）分别写入 SELECT 的 APSEL 和 APBANKSEL 域内。</p>
<p>第二步：通过 Packet Request 内 APnDP 置 1 来选择 DPACC，Rnw 置 1 来选择写操作，A[3:2] 置 0x4 来选择写 AP （0x）内 Bank（0xF）内的第一个寄存器。然后在 Data transfer phase 时把数据写入 CFG 寄存器。</p>
<p>逻辑分析仪抓包（注意：SWD 协议是 LSB）：</p>
<p>整个流程：</p>
<p><img src="/2020/12/11/BSP/SWD/SWD%20%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20201123233312354.png" alt="image-20201123233312354"></p>
<p>写 SELECT：</p>
<p><img src="/2020/12/11/BSP/SWD/SWD%20%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20201123233339963.png" alt="image-20201123233339963"></p>
<p><strong>DP 和 AP 的功能和关系</strong></p>
<p>Access Port (AP)</p>
<p>An AP uses a resource-specific transport mechanism to access debug information in the system to be debugged, and passes the information to the DP using the AP Access mechanism that is specified in this document.</p>
<p>A DAP must contain at least one AP, but if needed an ADI can implement multiple APs.</p>
<p>Debug Port (DP)</p>
<p>The DP provides a debugger with a common interface to access the information that is held in the APs.</p>
<p>可以类比分层协议，DP 实现了标准通用的 JTAG/SWD 协议收发功能，AP 实现了具体的资源读写功能，然后 DP 和 AP 之间再交互。</p>
<p><img src="/2020/12/11/BSP/SWD/SWD%20%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20201123233413784.png"></p>
<p><img src="/2020/12/11/BSP/SWD/SWD%20%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20201123233441709.png"></p>
<h2 id="SWD-中的数据校验"><a href="#SWD-中的数据校验" class="headerlink" title="SWD 中的数据校验"></a>SWD 中的数据校验</h2><p>A simple parity check is applied to all packet request and data transfer phases. Even parity is used.</p>
<p>SWD 使用简单的奇偶校验位来对传输的数据进行校验（除 ACK 外），具体来说，是计算 packet request 或者 data transfer 中为 1 的 bit 个数，若是奇数则奇偶校验位为1，否则为 0。</p>
<p>同时虽然双位同时发生错误的概率相当低，但奇偶校验却无法检测出双位错误。SWD 自带的校验不能完全保证数据传输无误，必须用户层加 CRC 才能保证数据无误。</p>
<p>2018-06-03 更新</p>
<p>根据资料，奇偶校验位失败的概率（把错误的当成正确的）是：</p>
<p><img src="/2020/12/11/BSP/SWD/SWD%20%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20201123233502195.png" alt="image-20201123233502195"></p>
<p>根据文档 <a href="https://faraday.physics.utoronto.ca/PVB/Drummond/Micro/ln_comm1.pdf%EF%BC%8C%E6%A6%82%E7%8E%87%E6%98%AF%EF%BC%9A">https://faraday.physics.utoronto.ca/PVB/Drummond/Micro/ln_comm1.pdf，概率是：</a></p>
<p>The length of pattern which each parity bit “guards” should be as long as possible so that the parity bit takes up the least amount of extra storage, but not so long that a double error becomes likely. Thus if the probability of a single bit being is error is 10-6, then the probability of an error in an 8-bit pattern (7 + parity) is about 8 x 10-6 and the probability of a double error is about 3 x 10-11 which is quite small. </p>
<p>有个矛盾之处：data bits 少，会造成 parity bit 占用多，data bits 多，又会导致误差概率变大，比如 32 bits 的情况下，误差概率就变大到 5 x 10^-10^了。</p>
<p>但是文档中也指出，有些特殊的情况下，bit 错误是成堆出现的，相临的 2 个 bit 会同时发生错误，此时未检测到的概率就是接近于每个 bit 的错误概率了。</p>
<p>An additional issue is that in some circumstances when an error does occur, it occurs in a clump - ie groups of bits may get corrupted together. Thus if the probability of one bit being currupted is P (small) then the probability of two successive bits being corrupted is not P2, but something much larger, maybe even approaching P.</p>
<h2 id="线序干扰问题"><a href="#线序干扰问题" class="headerlink" title="线序干扰问题"></a>线序干扰问题</h2><p>SWDIO 和 SWCLK 两条线是不能挨在一起的，否则会互相干扰导致错误。</p>
<p>JTAG 排线中这两根线之间是间隔了一根地线的，事实上 JTAG 的定义中所有的信号线之间有间隔有一根地线。</p>
]]></content>
      <categories>
        <category>SWD</category>
      </categories>
  </entry>
  <entry>
    <title>USB 学习</title>
    <url>/2020/12/11/BSP/USB/USB%20%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>在 2013 年学习 USB 时的笔记，那时候不喜欢写文字，而是直接画图，感觉图最能直观的理解知识。</p>
<a id="more"></a>

<p><img src="/2020/12/11/BSP/USB/USB%20%E5%AD%A6%E4%B9%A0/wps8LnXIJ.png" alt="img"></p>
]]></content>
      <categories>
        <category>USB</category>
      </categories>
  </entry>
  <entry>
    <title>OS X 和树莓派共享文件夹</title>
    <url>/2020/12/11/Boards/Raspberry%20Pi/OS%20X%20%E5%92%8C%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    <content><![CDATA[<p><a href="http://www.codeweblog.com/mac%E5%92%8C%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E5%92%8Ctm%E5%A4%87%E4%BB%BD">http://www.codeweblog.com/mac和树莓派实现文件共享和tm备份</a></p>
<p><a href="http://bbs.elecfans.com/forum.php?mod=viewthread&amp;tid=540731">http://bbs.elecfans.com/forum.php?mod=viewthread&amp;tid=540731</a></p>
<p>要用到的是 Netatalk</p>
<a id="more"></a>

<p>第一步：安装</p>
<p>sudo apt-get update</p>
<p>sudo apt-get install netatalk</p>
<p>第二步：配置</p>
<p>停止服务：sudo /etc/init.d/netatalk stop</p>
<p>打开配置文件：sudo nano /etc/netatalk/AppleVolumes.default</p>
<p>编辑安装文件夹或保留默认值：~/ “Home Directory”</p>
<p>打开服务：sudo /etc/init.d/netatalk start</p>
<p>第三步：打开搜索</p>
<p>在MAC打开搜索，几秒后你就能在共享面板中看到树莓派。</p>
]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
  </entry>
  <entry>
    <title>Raspbian 镜像使用帮助</title>
    <url>/2020/12/11/Boards/Raspberry%20Pi/Raspbian%20%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9/</url>
    <content><![CDATA[<p>Raspbian 默认使用国外镜像源来安装软件，在国内会比较卡顿。</p>
<a id="more"></a>

<h2 id="清华大学开源软件镜像站"><a href="#清华大学开源软件镜像站" class="headerlink" title="清华大学开源软件镜像站"></a>清华大学开源软件镜像站</h2><p>选择你的 Raspbian 对应的 Debian 版本:      Debian 7 (wheezy)  Debian 8 (jessie)  Debian 9 (stretch)  Debian 10 (buster) </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 编辑 &#96;&#x2F;etc&#x2F;apt&#x2F;sources.list&#96; 文件，删除原文件所有内容，用以下内容取代：</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspbian&#x2F;raspbian&#x2F; buster main non-free contrib rpi</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspbian&#x2F;raspbian&#x2F; buster main non-free contrib rpi</span><br><span class="line"></span><br><span class="line"># 编辑 &#96;&#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;raspi.list&#96; 文件，删除原文件所有内容，用以下内容取代：</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspberrypi&#x2F; buster main ui</span><br></pre></td></tr></table></figure>

<p>注意：网址末尾的<code>raspbian</code>重复两次是必须的。因为 Raspbian 的仓库中除了APT软件源还包含其他代码。APT软件源不在仓库的根目录，而在<code>raspbian/</code>子目录下。</p>
<p>编辑镜像站后，请使用<code>sudo apt-get update</code>命令，更新软件源列表，同时检查您的编辑是否正确。</p>
<p>参考：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/raspbian/">https://mirrors.tuna.tsinghua.edu.cn/help/raspbian/</a></p>
]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
  </entry>
  <entry>
    <title>SSH 登陆树莓派</title>
    <url>/2020/12/11/Boards/Raspberry%20Pi/SSH%20%E7%99%BB%E9%99%86%E6%A0%91%E8%8E%93%E6%B4%BE/</url>
    <content><![CDATA[<p>如何开启 SSH 服务，以及免密码输入 SSH 登陆。</p>
<a id="more"></a>

<p><a href="http://shumeipai.nxez.com/2017/09/13/raspberry-pi-network-configuration-before-boot.html">http://shumeipai.nxez.com/2017/09/13/raspberry-pi-network-configuration-before-boot.html</a></p>
<p>自 2016-11 官方发布的 Raspbian 系统镜像，系统默认禁用了 SSH 服务。在 SD 卡的 boot 磁盘根目录新建一个 ssh 空白文件即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd &#x2F;Volumes&#x2F;boot&#x2F;</span><br><span class="line">$ touch ssh</span><br></pre></td></tr></table></figure>

<p>然后用 arp 查找树莓派的 IP 地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ arp -a</span><br><span class="line">? (192.168.3.1) at 4:4f:4c:37:74:28 on en0 ifscope [ethernet]</span><br><span class="line">? (192.168.3.2) at 74:8d:8:c2:cd:84 on en0 ifscope [ethernet]</span><br><span class="line">? (192.168.3.33) at b8:27:eb:7e:b3:9e on en0 ifscope [ethernet]</span><br><span class="line">? (224.0.0.251) at 1:0:5e:0:0:fb on en0 ifscope permanent [ethernet]</span><br></pre></td></tr></table></figure>

<p>192.168.3.33 就是树莓派的地址，用 ssh 登陆之，用户名是 pi，密码是 raspberry：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh pi@192.168.3.33</span><br></pre></td></tr></table></figure>

<h3 id="免密码登陆"><a href="#免密码登陆" class="headerlink" title="免密码登陆"></a>免密码登陆</h3><p><a href="https://www.imooc.com/article/18859?block_id=tuijian_wz">https://www.imooc.com/article/18859?block_id=tuijian_wz</a></p>
<p>生成公钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>上传公钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i ~&#x2F;.ssh&#x2F;id_rsa.pub  pi@192.168.199.200</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
  </entry>
  <entry>
    <title>备份树莓派镜像并批量克隆</title>
    <url>/2020/12/11/Boards/Raspberry%20Pi/%E5%A4%87%E4%BB%BD%E6%A0%91%E8%8E%93%E6%B4%BE%E9%95%9C%E5%83%8F%E5%B9%B6%E6%89%B9%E9%87%8F%E5%85%8B%E9%9A%86/</url>
    <content><![CDATA[<p>在一个树莓派上开发好功能后，若要批量的生产，最方便的方法是直接将镜像备份下来，并批量复制到 SD 卡中。</p>
<p>插入待备份的 SD 卡并执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dd bs&#x3D;1m of&#x3D;raspbian-backup.img if&#x3D;&#x2F;dev&#x2F;rdisk2</span><br></pre></td></tr></table></figure>

<p>raspbian-backup.img 就是备份的树莓派镜像，可用以批量克隆生产树莓派系统。建议都使用相同的 SD 卡型号。</p>
]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
  </entry>
  <entry>
    <title>树莓派外设开发</title>
    <url>/2020/12/11/Boards/Raspberry%20Pi/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%A4%96%E8%AE%BE%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>树莓派外设开发的一些记录。</p>
<a id="more"></a>

<h2 id="mmap-操作-IO-的同步问题"><a href="#mmap-操作-IO-的同步问题" class="headerlink" title="mmap 操作 IO 的同步问题"></a>mmap 操作 IO 的同步问题</h2><p>在用树莓派 IO 模拟 SPI，频率高于 1MHz 就经常读取错误，逻辑分析仪抓波发现是时钟有异常：</p>
<p><img src="/2020/12/11/Boards/Raspberry%20Pi/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%A4%96%E8%AE%BE%E5%BC%80%E5%8F%91/image-20201208213936798.png" alt="image-20201208213936798"></p>
<p>如红框内，SCK 应该在箭头处拉低，正确的波形如红色线标出，但是实际上却延迟了一段时间才拉低，导致了波形异常。</p>
<p>可以用 msync 函数来把共享内容的改变直接写回到磁盘文件，但是此函数效率太低，所以用了个折中的办法，在拉低/高 IO 后，循环读取 IO 电平直到生效为止。</p>
<h2 id="IO-反转速度问题"><a href="#IO-反转速度问题" class="headerlink" title="IO 反转速度问题"></a>IO 反转速度问题</h2><p>写了一个 SPI bitbang 驱动，发现 IO 翻转速度达不到理想，测试看是代码运行花费时间较长，默认的编译是 -O0，也就是不优化，看了 OpenOCD 是 -O2，于是也设置为 -O2，速度就提高了 2 倍。</p>
<h2 id="WiringPi"><a href="#WiringPi" class="headerlink" title="WiringPi"></a>WiringPi</h2><p><a href="https://github.com/WiringPi">https://github.com/WiringPi</a></p>
<p><a href="https://blog.csdn.net/messidona11/article/details/71514329?fps=1&amp;locationNum=11">https://blog.csdn.net/messidona11/article/details/71514329?fps=1&amp;locationNum=11</a></p>
<p><a href="http://www.waveshare.net/study/article-742-1.html">http://www.waveshare.net/study/article-742-1.html</a></p>
<p>RPi.GPIO目前还不支持I2C、SPI等接口，且缺乏高精度定时功能。wiringpi除了提供C语言接口之外，目前已经支持Python等语言的扩展。对于GPIO的操作非常强大</p>
<p>安装 WiringPi Library：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install wiringpi</span><br></pre></td></tr></table></figure>

<p>安装 WiringPi Python：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install wiringpi</span><br></pre></td></tr></table></figure>

<p>读取树莓派引脚表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gpio readall</span><br><span class="line"> +-----+-----+---------+------+---+---Pi 3---+---+------+---------+-----+-----+</span><br><span class="line"> | BCM | wPi |   Name  | Mode | V | Physical | V | Mode | Name    | wPi | BCM |</span><br><span class="line"> +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+</span><br><span class="line"> |     |     |    3.3v |      |   |  1 || 2  |   |      | 5v      |     |     |</span><br><span class="line"> |   2 |   8 |   SDA.1 |   IN | 1 |  3 || 4  |   |      | 5v      |     |     |</span><br><span class="line"> |   3 |   9 |   SCL.1 |   IN | 1 |  5 || 6  |   |      | 0v      |     |     |</span><br><span class="line"> |   4 |   7 | GPIO. 7 |   IN | 1 |  7 || 8  | 0 | IN   | TxD     | 15  | 14  |</span><br><span class="line"> |     |     |      0v |      |   |  9 || 10 | 1 | IN   | RxD     | 16  | 15  |</span><br><span class="line"> |  17 |   0 | GPIO. 0 |   IN | 0 | 11 || 12 | 0 | IN   | GPIO. 1 | 1   | 18  |</span><br><span class="line"> |  27 |   2 | GPIO. 2 |   IN | 0 | 13 || 14 |   |      | 0v      |     |     |</span><br><span class="line"> |  22 |   3 | GPIO. 3 |   IN | 0 | 15 || 16 | 0 | IN   | GPIO. 4 | 4   | 23  |</span><br><span class="line"> |     |     |    3.3v |      |   | 17 || 18 | 0 | IN   | GPIO. 5 | 5   | 24  |</span><br><span class="line"> |  10 |  12 |    MOSI |   IN | 0 | 19 || 20 |   |      | 0v      |     |     |</span><br><span class="line"> |   9 |  13 |    MISO |   IN | 0 | 21 || 22 | 0 | IN   | GPIO. 6 | 6   | 25  |</span><br><span class="line"> |  11 |  14 |    SCLK |   IN | 0 | 23 || 24 | 1 | IN   | CE0     | 10  | 8   |</span><br><span class="line"> |     |     |      0v |      |   | 25 || 26 | 1 | IN   | CE1     | 11  | 7   |</span><br><span class="line"> |   0 |  30 |   SDA.0 |   IN | 1 | 27 || 28 | 1 | IN   | SCL.0   | 31  | 1   |</span><br><span class="line"> |   5 |  21 | GPIO.21 |   IN | 1 | 29 || 30 |   |      | 0v      |     |     |</span><br><span class="line"> |   6 |  22 | GPIO.22 |   IN | 1 | 31 || 32 | 0 | IN   | GPIO.26 | 26  | 12  |</span><br><span class="line"> |  13 |  23 | GPIO.23 |   IN | 0 | 33 || 34 |   |      | 0v      |     |     |</span><br><span class="line"> |  19 |  24 | GPIO.24 |   IN | 0 | 35 || 36 | 0 | IN   | GPIO.27 | 27  | 16  |</span><br><span class="line"> |  26 |  25 | GPIO.25 |   IN | 0 | 37 || 38 | 0 | IN   | GPIO.28 | 28  | 20  |</span><br><span class="line"> |     |     |      0v |      |   | 39 || 40 | 0 | IN   | GPIO.29 | 29  | 21  |</span><br><span class="line"> +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+</span><br><span class="line"> | BCM | wPi |   Name  | Mode | V | Physical | V | Mode | Name    | wPi | BCM |</span><br><span class="line"> +-----+-----+---------+------+---+---Pi 3---+---+------+---------+-----+-----+</span><br></pre></td></tr></table></figure>

<h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><p><a href="http://wiringpi.com/examples/blink/">http://wiringpi.com/examples/blink/</a></p>
<p>配置上下拉：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wiringPiSetup();</span><br><span class="line">pullUpDnControl(13, PUD_UP);</span><br></pre></td></tr></table></figure>

<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><p><a href="https://blog.csdn.net/messidona11/article/details/73957275?utm_source=gold_browser_extension">https://blog.csdn.net/messidona11/article/details/73957275?utm_source=gold_browser_extension</a></p>
<p>官方似乎没有提供详细的 API 文档，但是可以直接看源码：<a href="https://github.com/WiringPi/WiringPi/blob/master/wiringPi/wiringPiSPI.c">https://github.com/WiringPi/WiringPi/blob/master/wiringPi/wiringPiSPI.c</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int wiringPiSPIGetFd     (int channel) ;</span><br><span class="line">int wiringPiSPIDataRW    (int channel, unsigned char *data, int len) ;</span><br><span class="line">int wiringPiSPISetupMode (int channel, int speed, int mode) ;</span><br><span class="line">int wiringPiSPISetup     (int channel, int speed) ;</span><br></pre></td></tr></table></figure>

<p>Raspian 默认不使能 SPI，需要在 raspi-config 内 enable SPI interface。</p>
<p>在 /dev 内会出现两个 SPI 设备 spidev0.0 和 spidev0.1，这两个设备共用 MOSI，MISO 和 SCLK，NSS 分别是 CE0 和 CE1，引脚序号如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----+-----+---------+------+---+---Pi 3---+---+------+---------+-----+-----+</span><br><span class="line">| BCM | wPi |   Name  | Mode | V | Physical | V | Mode | Name    | wPi | BCM |</span><br><span class="line">+-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+</span><br><span class="line">|  10 |  12 |    MOSI |   IN | 0 | 19 || 20 |   |      | 0v      |     |     |</span><br><span class="line">|   9 |  13 |    MISO |   IN | 0 | 21 || 22 | 0 | IN   | GPIO. 6 | 6   | 25  |</span><br><span class="line">|  11 |  14 |    SCLK |   IN | 0 | 23 || 24 | 1 | IN   | CE0     | 10  | 8   |</span><br><span class="line">|     |     |      0v |      |   | 25 || 26 | 1 | IN   | CE1     | 11  | 7   |</span><br></pre></td></tr></table></figure>

<p>注意，wiringpi 的作者 Gordon 只提供了 C/C++ 版本实现，其他语言的 wrappers 由其他开发者提供，如 Python 是 <a href="http://pi.gadgetoid.co.uk/">Gadgetoid</a> 实现的。</p>
<blockquote>
<p><strong>Other wiringPi resources:</strong></p>
<ul>
<li>Thanks to <a href="http://pi.gadgetoid.co.uk/">Gadgetoid</a> there are now wrappers for Ruby, Python and Perl and these can all be <a href="https://github.com/WiringPi">found here</a>.</li>
<li>Thanks to <a href="http://jkransen.wordpress.com/2012/07/16/raspberry-pi/">Jeroen Kransen</a> there are wrappers for Java which can be <a href="https://github.com/jkransen/framboos">found here</a>.</li>
<li>Thanks to Dave Boulton for creating a TCL wrapper  which can be <a href="https://github.com/davidb24v/WiringPi-Tcl">found here</a>.</li>
<li><a href="http://pi4j.com/">Pi4J</a> is another Java project that uses WiringPi. It has a <a href="https://github.com/Pi4J/pi4j/">Github repository here</a>.</li>
</ul>
</blockquote>
<p>Python 的 wiringpi 代码仓库：<a href="https://github.com/WiringPi/WiringPi-Python">https://github.com/WiringPi/WiringPi-Python</a></p>
<p>使用 Python wiringpi 的 SPI 要特别注意，wiringPiSPIDataRW( channel ,data ) 的 data 参数是会被修改的，由于没有仔细看文档，我被这个坑了很久。</p>
<blockquote>
<p><strong>SPI:</strong></p>
<p>The <code>wiringPiSPIDataRW()</code> function needs to be passed a <code>bytes</code> object in Python 3. In Python 2, it takes a string. The following should work in either Python 2 or 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wiringpi.wiringPiSPISetup(channel, speed)</span><br><span class="line">buf &#x3D; bytes([your data here])</span><br><span class="line">retlen, retdata &#x3D; wiringpi.wiringPiSPIDataRW(0, buf)</span><br></pre></td></tr></table></figure>

<p>Now, <code>retlen</code> will contain the number of bytes received/read by the call.  <code>retdata</code> will contain the data itself, and <strong>==in Python 3, <code>buf</code> will have been modified to contain it as well==</strong> (that won’t happen in Python 2, because then <code>buf</code> is a string, and strings are immutable).</p>
</blockquote>
<p>令人蛋痛的是不管用 bytes() 还是 copy()，最后 data 的值还是被修改了，只能用 buf =bytes.fromhex(data.hex())  或者 buf = bytes(bytearray(data)) 这样的方法来避免问题了。</p>
<p>更蛋痛的是作者自己也说了，这个不是官方移植版本的，那就意味着可能会有很多碧游鸡，在使用过程中果然遇到了一些坑爹的地方，比如 wiringPiSPIDataRW 的 data 参数超过了 0x1000 就会 segment fault 等。</p>
<blockquote>
<p><strong>Note</strong></p>
<p>This is an unofficial port of Gordon’s WiringPi library. Please do not email Gordon if you have issues, he will not be able to help.</p>
<p>For support, comments, questions, etc please join the WiringPi Discord channel: <a href="https://discord.gg/SM4WUVG">https://discord.gg/SM4WUVG</a></p>
</blockquote>
<p>所以，在官方移植 Python之前，还是不要用这个坑爹的仓库了。</p>
<hr>
<p>2018-04-06 更新</p>
<p>看来我是冤枉 Gadgetoid 这位大神了，wiringpi 中 SPI 一次发送的数据本来就最大只有 4K。</p>
<p>不过实际测试下来，读取 2M 的 SPI Flash，python 用 2.9s, C 用了 1.5s，几乎是 C 的 2 倍多时间，所以还是 C 的效率快。</p>
<h2 id="SPI-Flash"><a href="#SPI-Flash" class="headerlink" title="SPI Flash"></a>SPI Flash</h2><p><a href="https://github.com/nopnop2002/Raspberry-W25Q64/blob/master/W25Q64.c">https://github.com/nopnop2002/Raspberry-W25Q64/blob/master/W25Q64.c</a></p>
<p>一个日本人用 wiringpi 实现的 SPI Flash 驱动。</p>
<h2 id="树莓派安装-RTC-时钟"><a href="#树莓派安装-RTC-时钟" class="headerlink" title="树莓派安装 RTC 时钟"></a>树莓派安装 RTC 时钟</h2><p>安装 RTC 时钟后，树莓派就不用网络时间来同步了（可以不接外网）。</p>
<p><a href="https://www.raspberrypi-spy.co.uk/2015/05/adding-a-ds3231-real-time-clock-to-the-raspberry-pi/">https://www.raspberrypi-spy.co.uk/2015/05/adding-a-ds3231-real-time-clock-to-the-raspberry-pi/</a></p>
<h3 id="DS1307-or-DS3231"><a href="#DS1307-or-DS3231" class="headerlink" title="DS1307 or DS3231?"></a>DS1307 or DS3231?</h3><p>Modules based on the DS1307 and DS3231 chips are popular devices and you’ll see them for sale from various retailers. I purchased both types and quickly realised my DS1307 modules were useless. My advice would be to go for a DS3231 based module. They are more accurate and run happily from 3.3V. My two “Tiny RTC” DS1307 modules went straight in the bin.</p>
<h3 id="I2C-Setup"><a href="#I2C-Setup" class="headerlink" title="I2C Setup"></a>I2C Setup</h3><p>As with all I2C devices you must configure the I2C interface. This is quite easy to do and explained in my <a href="https://www.raspberrypi-spy.co.uk/2014/11/enabling-the-i2c-interface-on-the-raspberry-pi/">Enabling The I2C Interface On The Raspberry Pi</a> tutorial.</p>
<h3 id="DS3231-Module-Setup"><a href="#DS3231-Module-Setup" class="headerlink" title="DS3231 Module Setup"></a>DS3231 Module Setup</h3><p>Now we need to modify a system file using :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nano &#x2F;etc&#x2F;modules</span><br></pre></td></tr></table></figure>

<p>If it isn’t already there add “rtc-ds1307” to the bottom so it looks something like :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">snd-bcm2835</span><br><span class="line">i2c-bcm2835</span><br><span class="line">i2c-dev</span><br><span class="line">rtc-ds1307</span><br></pre></td></tr></table></figure>

<p>Shutdown the Pi using “sudo halt” and remove the power when it has completed the process.</p>
<h3 id="Interface-Test"><a href="#Interface-Test" class="headerlink" title="Interface Test"></a>Interface Test</h3><p>Power up the Pi and run the following command :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo i2cdetect -y 1</span><br></pre></td></tr></table></figure>

<p>You should see something similar to this :</p>
<p><img src="/2020/12/11/Boards/Raspberry%20Pi/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%A4%96%E8%AE%BE%E5%BC%80%E5%8F%91/ds3231_rtc_module_01.png" alt="DS3231 RTC Module Config"></p>
<p>In this example “68” is the hex address of the RTC module on the I2C interface.</p>
<h3 id="I2C-Device-Setup"><a href="#I2C-Device-Setup" class="headerlink" title="I2C Device Setup"></a>I2C Device Setup</h3><p>To ensure the DS1307 device is setup and the time synchronised when the Pi boots we need to edit another system file :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nano &#x2F;etc&#x2F;rc.local</span><br></pre></td></tr></table></figure>

<p>Add the following two lines before the exit 0 line :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo ds1307 0x68 &gt; &#x2F;sys&#x2F;class&#x2F;i2c-adapter&#x2F;i2c-1&#x2F;new_device</span><br><span class="line">hwclock -s</span><br></pre></td></tr></table></figure>

<p>so it looks something like :</p>
<p><a href="https://www.raspberrypi-spy.co.uk/2015/05/adding-a-ds3231-real-time-clock-to-the-raspberry-pi/ds1308_rtc_module_06/"><img src="/2020/12/11/Boards/Raspberry%20Pi/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%A4%96%E8%AE%BE%E5%BC%80%E5%8F%91/ds1308_rtc_module_06.png" alt="DS1307 RTC Module Config"></a></p>
<p>Now reboot the Pi using :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>

<p>Now when you repeat the i2cdetect command (see above) the 68 will turn into UU :</p>
<p><img src="/2020/12/11/Boards/Raspberry%20Pi/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%A4%96%E8%AE%BE%E5%BC%80%E5%8F%91/ds3231_rtc_module_02.png" alt="DS3231 RTC Module Config"></p>
<h3 id="Reading-The-Date-And-Time"><a href="#Reading-The-Date-And-Time" class="headerlink" title="Reading The Date And Time"></a>Reading The Date And Time</h3><p>You can read the Pi’s system time using :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure>

<p>Once correct you can write the system date and time to the RTC module using :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo hwclock -w</span><br></pre></td></tr></table></figure>

<p>You should be able to read the date and time back from the RTC using :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo hwclock -r</span><br></pre></td></tr></table></figure>

<p>By separating the commands with a semi-colon you can read back the system time and the RTC time at the same time. Hopefully they should match and look something like this :</p>
<p><img src="/2020/12/11/Boards/Raspberry%20Pi/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%A4%96%E8%AE%BE%E5%BC%80%E5%8F%91/ds3231_rtc_module_03.png" alt="DS3231 RTC Module Config"></p>
<p>The “hwclock -s” we added to “rc.local” sets the system time from the RTC module.</p>
<h3 id="The-Final-Test"><a href="#The-Final-Test" class="headerlink" title="The Final Test"></a>The Final Test</h3><p>The final test is to determine if the RTC module is keeping time and that the Pi will use that time when it boots. The best way to do that is to :</p>
<ul>
<li>Power down the Pi</li>
<li>Remove the power cable</li>
<li>Remove the network connection</li>
<li>Attach the Pi to a monitor and keyboard</li>
<li>Leave it overnight</li>
<li>Power it up and use “date” to see what time the Pi thinks it is</li>
</ul>
]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
  </entry>
  <entry>
    <title>树莓派开发杂记</title>
    <url>/2020/12/11/Boards/Raspberry%20Pi/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E5%8F%91%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<p>开发树莓派时一些散碎的知识记录</p>
<a id="more"></a>

<h2 id="隐藏任务栏"><a href="#隐藏任务栏" class="headerlink" title="隐藏任务栏"></a>隐藏任务栏</h2><p>有时候需要把自己的程序布满整个屏幕，用户只能操作这个界面，就需要把任务栏隐藏起来</p>
<p>可以右键任务栏，选择 Panel Preference，把 Geometry 中 Size 的 Width 设置为 0，这样任务栏的长度就是 0 了，就看不见了，保险起见，把 Advanced 中 Automatic hiding 的 Minimise panel when not in use 勾选上，并把 Size when minimised 设为 0。</p>
<h2 id="问题：sudo-unable-to-resolve-host-raspberrypisnowyang"><a href="#问题：sudo-unable-to-resolve-host-raspberrypisnowyang" class="headerlink" title="问题：sudo: unable to resolve host raspberrypisnowyang"></a>问题：sudo: unable to resolve host raspberrypisnowyang</h2><p>在执行 sudo 命令时出现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo: unable to resolve host raspberrypisnowyang</span><br></pre></td></tr></table></figure>

<p>虽然命令最终成功了，但是卡住了一段时间，估计是在试图解析 host 超时了。</p>
<p>我的 host 是 raspberrypi@snowyang，但是错误信息里是 raspberrypisnowyang，估计就是这个 @ 符号让 sudo 以为是个域名进而解析导致了问题。</p>
<p>sudo raspi-config 吧 host name 中的 @ 去掉就好了</p>
<h2 id="OpenOCD-不启动服务器"><a href="#OpenOCD-不启动服务器" class="headerlink" title="OpenOCD 不启动服务器"></a>OpenOCD 不启动服务器</h2><p>OpenOCD 默认会启动 TCP, Telnet 和 TCL 服务器，在频繁开关 OpenOCD 时会可能会造成问题，所以可使用 <code>-c &quot;gdb_port disabled&quot; -c &quot;tcl_port disabled&quot; -c &quot;telnet_port disabled&quot;</code> 选项来不启动这些服务器。</p>
<h2 id="SCP-传输文件"><a href="#SCP-传输文件" class="headerlink" title="SCP 传输文件"></a>SCP 传输文件</h2><p><a href="http://www.runoob.com/linux/linux-comm-scp.html">http://www.runoob.com/linux/linux-comm-scp.html</a></p>
<p>netatalk 可以很方便的共享文件夹，可是 Raspberry 默认是没有安装此服务的，在上不了外网的情况下，还可以用自带的 scp 来传输文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp local_file remote_username@remote_ip:remote_file </span><br><span class="line">scp -r local_folder remote_username@remote_ip:remote_folder </span><br></pre></td></tr></table></figure>

<h2 id="虚拟键盘"><a href="#虚拟键盘" class="headerlink" title="虚拟键盘"></a>虚拟键盘</h2><p><a href="https://blog.csdn.net/xuelanlingying/article/details/78408617?locationNum=6&amp;fps=1">https://blog.csdn.net/xuelanlingying/article/details/78408617?locationNum=6&amp;fps=1</a></p>
<h2 id="设置静态-IP-地址"><a href="#设置静态-IP-地址" class="headerlink" title="设置静态 IP 地址"></a>设置静态 IP 地址</h2><p><a href="https://www.cnblogs.com/taojintianxia/p/6026225.html">https://www.cnblogs.com/taojintianxia/p/6026225.html</a></p>
<p>修改*/etc/dhcpcd.conf* 文件</p>
<p>sudo vim <em>/etc/dhcpcd.conf</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface eth0</span><br><span class="line"></span><br><span class="line">static ip_address&#x3D;10.0.0.2&#x2F;24</span><br><span class="line">static routers&#x3D;10.0.0.1</span><br><span class="line">static domain_name_servers&#x3D;10.0.0.1</span><br><span class="line"></span><br><span class="line">interface wlan0</span><br><span class="line"></span><br><span class="line">static ip_address&#x3D;10.0.0.3&#x2F;24</span><br><span class="line">static routers&#x3D;10.0.0.1</span><br><span class="line">static domain_name_servers&#x3D;10.0.0.1</span><br></pre></td></tr></table></figure>

<p>上面的配置文件中 , eth0是有线的配置  , wlan0是无线配置</p>
<p>ip_address就是静态IP , 后面要接/24</p>
<p>routers是网关sudo </p>
<p>static domain_name_servers是DNS</p>
<h2 id="禁止休眠，屏幕常亮"><a href="#禁止休眠，屏幕常亮" class="headerlink" title="禁止休眠，屏幕常亮"></a>禁止休眠，屏幕常亮</h2><p><a href="https://blog.csdn.net/u011720560/article/details/78288128">https://blog.csdn.net/u011720560/article/details/78288128</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">该设置应用于2017-06-21-raspbian-jessie版本</span><br></pre></td></tr></table></figure>

<p>我想让连接树莓派的HDMI屏幕一直显示，然后从网上找了许多关于禁止休眠的设置，最终找到了方法，那些方法估计是用在老版本系统上的。<br>其中Raspbian使用了轻量桌面显示管理器即lightdm,通过该管理器可对xserver桌面会话交互、显示等进行设置.</p>
<p>步骤</p>
<p>1.打开lightdm.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;lightdm&#x2F;lightdm.conf</span><br></pre></td></tr></table></figure>

<p>2.修改lightdm.conf</p>
<p>找到[SeatDefaults]段下的’xserver-command’,取消注释,修改为如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#xserver-command&#x3D;X</span><br></pre></td></tr></table></figure>

<p>修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xserver-command&#x3D;X -s 0 -dpms</span><br></pre></td></tr></table></figure>

<ul>
<li>-s # –设置屏幕保护不启用</li>
<li>dpms 关闭电源节能管理</li>
</ul>
<p>3.重启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>

<p>参考连接</p>
<p><a href="https://raspberrypi.stackexchange.com/questions/4773/raspberry-pi-sleep-mode-how-to-avoid">raspberry-pi-sleep-mode-how-to-avoid</a></p>
<h2 id="VNC-连接树莓派"><a href="#VNC-连接树莓派" class="headerlink" title="VNC 连接树莓派"></a>VNC 连接树莓派</h2><p><a href="https://blog.csdn.net/u012952807/article/details/70225700">https://blog.csdn.net/u012952807/article/details/70225700</a></p>
<p>树莓派的Raspbian集成了VNC Server，默认却是不开启的，需要 raspi-config 的 interface 内开启，然后 reboot 后生效。</p>
<p>VNC client 推荐使用 VNC viewer：<a href="http://mac.softpedia.com/get/Network-Admin/VNC-Viewer.shtml">http://mac.softpedia.com/get/Network-Admin/VNC-Viewer.shtml</a></p>
<h2 id="使用-waveshare-的-5-寸屏幕"><a href="#使用-waveshare-的-5-寸屏幕" class="headerlink" title="使用 waveshare 的 5 寸屏幕"></a>使用 waveshare 的 5 寸屏幕</h2><p><a href="http://www.waveshare.net/wiki/5inch_HDMI_LCD_(B)">http://www.waveshare.net/wiki/5inch_HDMI_LCD_(B)</a></p>
<p>在 /boot 目录下的 config.txt 文件尾部追加：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">max_usb_current&#x3D;1</span><br><span class="line">hdmi_group&#x3D;2</span><br><span class="line">hdmi_mode&#x3D;1</span><br><span class="line">hdmi_mode&#x3D;87</span><br><span class="line">hdmi_cvt 800 480 60 6 0 0 0</span><br><span class="line">hdmi_drive&#x3D;1</span><br></pre></td></tr></table></figure>

<h2 id="图形界面开发快捷方法"><a href="#图形界面开发快捷方法" class="headerlink" title="图形界面开发快捷方法"></a>图形界面开发快捷方法</h2><p>使用 VNC 连接树莓派作显示，使用 Netatalk 来直接访问并编辑树莓派上的代码，比树莓派直接连个显示器来开发要方便多了。</p>
<h2 id="PyInstaller"><a href="#PyInstaller" class="headerlink" title="PyInstaller"></a>PyInstaller</h2><p>在树莓派上 pip3 installer pyinstaller 后，在 shell 中却找不到 pyinstaller 可执行文件，用 pip3 show -f pyinstaller 查看发现其路径在 /home/pi/.local/bin/ 目录下，而此目录不在 PATH 内，所以 shell 内找不到 pyinstaller，很简单，把其在 .bashrc 加入 PATH 就好了: PATH=$PATH:/home/pi/.local/bin/</p>
<h2 id="raspi-config-的命令行用法"><a href="#raspi-config-的命令行用法" class="headerlink" title="raspi-config 的命令行用法"></a>raspi-config 的命令行用法</h2><p>在把树莓派用作产品批量生产时，用图形化的 raspi-config 是低效且易错的，所以命令行模式的 raspi-config 就很有用了</p>
<p><a href="http://www.52pi.net/archives/623">http://www.52pi.net/archives/623</a></p>
<p><a href="https://github.com/raspberrypi-ui/rc_gui/blob/master/src/rc_gui.c#L23-L70">https://github.com/raspberrypi-ui/rc_gui/blob/master/src/rc_gui.c#L23-L70</a></p>
<p>比如说要 expand filesystem，那么使用命令：<code>sudo raspi-config nonint do_expand_rootfs</code> 就可以了。</p>
<p>这样的好处是可以把配置命令集合到 shell 脚本内，生产时只需执行这个脚本就可以配置好树莓派了。</p>
<h2 id="树莓派-Wi-Fi-抓包"><a href="#树莓派-Wi-Fi-抓包" class="headerlink" title="树莓派 Wi-Fi 抓包"></a>树莓派 Wi-Fi 抓包</h2><p><a href="https://www.jianshu.com/p/8a27249997c0">https://www.jianshu.com/p/8a27249997c0</a></p>
<p><a href="http://www.360zhijia.com/360anquanke/309676.html">http://www.360zhijia.com/360anquanke/309676.html</a></p>
<p><a href="https://blog.csdn.net/QS_0928/article/details/77387335">https://blog.csdn.net/QS_0928/article/details/77387335</a></p>
<p><a href="https://www.cnblogs.com/sjqlwy/p/zero_otg.html">https://www.cnblogs.com/sjqlwy/p/zero_otg.html</a></p>
<p>应该可以用在 windows 上抓包</p>
<h2 id="USB-供电和-HUB"><a href="#USB-供电和-HUB" class="headerlink" title="USB 供电和 HUB"></a>USB 供电和 HUB</h2><p>若屏幕使用 USB 供电，那么接入的 HUB 就必须自带电源供电，否则 USB 插入设备不被识别。</p>
<h2 id="性能模式和-CPU-主频"><a href="#性能模式和-CPU-主频" class="headerlink" title="性能模式和 CPU 主频"></a>性能模式和 CPU 主频</h2><p><a href="http://bbs.elecfans.com/jishu_804044_1_1.html">http://bbs.elecfans.com/jishu_804044_1_1.html</a></p>
<p>树莓派默认的性能模式是 ondemand，即按需快速动态调整CPU频率，此模式下会根据供电，CPU 温度和计算量自动的调整频率。</p>
<p><a href="https://blog.csdn.net/zhenwenxian/article/details/6196943">https://blog.csdn.net/zhenwenxian/article/details/6196943</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cpufreq是一个动态调整cpu频率的模块，系统启动时生成一个文件夹&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cpufreq&#x2F;，里面有几个文件，其中scaling_min_freq代表最低频率，scaling_max_freq代表最高频率，scalin_governor代表cpu频率调整模式，用它来控制CPU频率。</span><br><span class="line"></span><br><span class="line">1，performance ：顾名思义只注重效率，将CPU频率固定工作在其支持的最高运行频率上，而不动态调节。</span><br><span class="line">2，powersave：将CPU频率设置为最低的所谓“省电”模式，CPU会固定工作在其支持的最低运行频率上。</span><br><span class="line"></span><br><span class="line">因此这两种governors 都属于静态governor，即在使用它们时CPU 的运行频率不会根据系统运行时负载的变化动态作出调整。这两种governors 对应的是两种极端的应用场景，使用performance governor 是对系统高性能的最大追求，而使用powersave governor 则是对系统低功耗的最大追求。</span><br><span class="line"></span><br><span class="line">3，Userspace：最早的cpufreq 子系统通过userspace governor为用户提供了这种灵活性。系统将变频策略的决策权交给了用户态应用程序，并提供了相应的接口供用户态应用程序调节CPU 运行频率使用。也就是长期以来都在用的那个模式。可以通过手动编辑配置文件进行配置。</span><br><span class="line">4，ondemand 按需快速动态调整CPU频率，一有cpu计算量的任务，就会立即达到最大频率运行，等执行完毕就立即回到最低频率。</span><br><span class="line">5，conservative 与ondemand不同，平滑地调整CPU频率，频率的升降是渐变式的,会自动在频率上下限调整，和ondemand的区别   在于它会按需分配频率，而不是一味追求最高频率。</span><br></pre></td></tr></table></figure>

<p>要修改性能模式，有以下三种方法：</p>
<ul>
<li><p>命令行内修改：</p>
<p><a href="https://www.guokr.com/post/687371/">https://www.guokr.com/post/687371/</a></p>
<p><code>sudo -i</code> 切换到root用户，然后再<code>echo powersave &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</code></p>
<p>或者：</p>
<p><a href="https://raspberrypi.stackexchange.com/questions/9034/how-to-change-the-default-governor?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa">https://raspberrypi.stackexchange.com/questions/9034/how-to-change-the-default-governor?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa</a></p>
<p><code>sudo sh -c &quot;echo powersave &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor&quot;</code></p>
</li>
<li><p>启动时修改：</p>
<p><a href="https://www.raspberrypi.org/forums/viewtopic.php?t=114536">https://www.raspberrypi.org/forums/viewtopic.php?t=114536</a></p>
<p>Have a look at /etc/init.d/raspi-config that controls the on-demand governor during boot up.</p>
<p>把 /etc/init.d/raspi-config 内的 ondemand 修改为 powersave</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">  start)</span><br><span class="line">    log_daemon_msg &quot;Checking if shift key is held down&quot;</span><br><span class="line">    if [ -x &#x2F;usr&#x2F;sbin&#x2F;thd ] &amp;&amp; timeout 1 thd --dump &#x2F;dev&#x2F;input&#x2F;event* | grep -q &quot;LEFTSHIFT\|RIGHTSHIFT&quot;; then</span><br><span class="line">      printf &quot; Yes. Not enabling powersave scaling governor&quot;</span><br><span class="line">      log_end_msg 0</span><br><span class="line">    else</span><br><span class="line">      printf &quot; No. Switching to powersave scaling governor&quot;</span><br><span class="line">      SYS_CPUFREQ_GOVERNOR&#x3D;&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cpufreq&#x2F;scaling_governor</span><br><span class="line">      if [ -e $SYS_CPUFREQ_GOVERNOR ]; then</span><br><span class="line">        echo &quot;powersave&quot; &gt; $SYS_CPUFREQ_GOVERNOR</span><br><span class="line">        echo 50 &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;ondemand&#x2F;up_threshold</span><br><span class="line">        echo 100000 &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;ondemand&#x2F;sampling_rate</span><br><span class="line">        echo 50 &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;ondemand&#x2F;sampling_down_factor</span><br><span class="line">      fi</span><br><span class="line">      log_end_msg 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
  </entry>
  <entry>
    <title>树莓派开机自动启动GUI程序</title>
    <url>/2020/12/11/Boards/Raspberry%20Pi/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8GUI%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>有多种开机自启用户脚本命令的方法，可以参考：<a href="https://www.jianshu.com/p/86adb6d5347b">https://www.jianshu.com/p/86adb6d5347b</a></p>
<p>但是那都是在登录用户前的阶段启动的，而 GUI 程序，比如 Qt 需要依赖于桌面和各种服务，所以不能使用那些方法。</p>
<a id="more"></a>

<p>开机自启 Qt 程序的方法，可以参考：</p>
<p><a href="https://blog.csdn.net/dubuzherui/article/details/52846166">https://blog.csdn.net/dubuzherui/article/details/52846166</a></p>
<blockquote>
<p>用树莓派上用Qt进行图形界面开发，发现无法自动启动程序，找了好多方法都是不行。网上都是讲怎么启动脚本的，但是脚本的启动与图形程序是不同的。</p>
<p>树莓派开机启动流程：自动登录–&gt;自动启动窗口–&gt;自动运行用户程序</p>
<p>脚本程序可以在自动启动窗口这一步之前运行，但是用户程序是不行。下面来看一下怎么启动用户程序：</p>
<p>进入当前用户HOME目录下的.config目录(这是一个隐藏目录，需用ls -a显示出来)<br>cd <del>/.config<br>当前用户是pi, 其HOME目录是/home/pi, 上述命令相当于<br>cd /home/pi/.config<br>建立一个名为autostart的子目录,并进入该目录<br>mkdir autostart<br>cd autostart<br>生成一个*.desktop文件（比如：my.desktop），命令如下:<br>sudo nano my.desktop<br>输入以下文件内容:<br>[Desktop Entry]<br>Type=Application<br>Exec=Path<br>最后一句Exec的值就是要启动的程序名(最好是全路径的可执行文件名)，然后重启即可。<br>原理：startx后，LXDE窗口管理器会找到</del>/.config/autostart目录下的所有 .desktop文件，一一执行<br>把上述全部串起来，就是一上电：自动登录－自动启动窗口-自动运行程序</p>
</blockquote>
<p>再隐藏下任务栏和更换壁纸，开机后基本不会让使用者看到多余的内容。</p>
<p>注意：Exec 的值必须是个应用程序或者脚本，如果是多条命令的话，必须用放在一个脚本内，然后 Exec 来运行这个脚本。</p>
<p>注意：从 2017 年后，Raspbian 不再使用 PIXEL 替换 LXDE 作为桌面环境。</p>
<p><a href="http://shumeipai.nxez.com/2016/10/24/raspbian-pixel-desktop-coming.html">http://shumeipai.nxez.com/2016/10/24/raspbian-pixel-desktop-coming.html</a></p>
<p>注意：如果有多条命令，应该放在一个 shell 脚本内，然后 *.desktop 的 Exec 设置为这个脚本去执行</p>
<p>注意：如果没有 expand filesystem，可能会比较卡顿。</p>
]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
  </entry>
  <entry>
    <title>烧录树莓派镜像</title>
    <url>/2020/12/11/Boards/Raspberry%20Pi/%E7%83%A7%E5%BD%95%E6%A0%91%E8%8E%93%E6%B4%BE%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<p>通过命令行来烧录树莓派镜像到 SD 卡中</p>
<a id="more"></a>

<p>参考：<a href="https://blog.csdn.net/freewebsys/article/details/48980993">https://blog.csdn.net/freewebsys/article/details/48980993</a></p>
<ol>
<li><p>下载镜像</p>
<p>去官网 <a href="https://www.raspberrypi.org/downloads/raspbian/">https://www.raspberrypi.org/downloads/raspbian/</a> 下载镜像，我下载的是 RASPBIAN STRETCH LITE，也就是没有桌面的，会小很多。</p>
</li>
<li><p>在 OS X 下安装镜像</p>
<ol>
<li><p>格式化 SD 卡</p>
<p>官方推荐使用 <a href="https://www.sdcard.org/downloads/formatter_4/">sdcard formatter</a>，操作简单点击下就行。</p>
</li>
<li><p>查看并卸载 SD 卡</p>
<p>查看 SD 卡磁盘</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ df -lh</span><br><span class="line">Filesystem     Size   Used  Avail Capacity  iused   ifree %iused  Mounted on</span><br><span class="line">&#x2F;dev&#x2F;disk1    233Gi  215Gi   18Gi    93% 56386271 4592543   92%   &#x2F;</span><br><span class="line">&#x2F;dev&#x2F;disk2s1   30Gi  1.6Mi   30Gi     1%        0       0  100%   &#x2F;Volumes&#x2F;21 1</span><br></pre></td></tr></table></figure>

<p>记住磁盘叫/dev/disk2s1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo diskutil umount &#x2F;dev&#x2F;disk2s1                                </span><br><span class="line">Volume 21 on disk2s1 unmounted</span><br></pre></td></tr></table></figure>
</li>
<li><p>写入镜像</p>
<p><strong>特别注意写入文件没有s1且前面多了个r，/dev/disk2s1对应的输出文件是/dev/rdisk2）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo dd bs&#x3D;1m if&#x3D;2018-03-13-raspbian-stretch.img of&#x3D;&#x2F;dev&#x2F;rdisk2  </span><br><span class="line">4125+0 records in</span><br><span class="line">4125+0 records out</span><br><span class="line">4325376000 bytes transferred in 401.205151 secs (10780958 bytes&#x2F;sec)</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<p>rdisk 和 disk 的区别：</p>
<p><a href="https://superuser.com/questions/631592/why-is-dev-rdisk-about-20-times-faster-than-dev-disk-in-mac-os-x">Why is “/dev/rdisk” about 20 times faster than “/dev/disk” in Mac OS X</a></p>
<p>According to the <a href="http://elinux.org/RPi_Easy_SD_Card_Setup">rasbery pi documentation</a>, You can load your OS to a flash card with either /dev/disk or /dev/rdisk. </p>
<p>rdisk stands for raw disk.</p>
<p>/dev/disk is a block level device, <strong>why would rdisk be 20 times faster?</strong></p>
<blockquote>
<p>Using Mac OSX</p>
<p>Note: In OS X each disk may have two path references in /dev: /dev/disk# is a buffered device, which means any data being sent undergoes extra processing. /dev/rdisk# is a raw path, which is much faster, and perfectly OK when using the dd program. On a Class 4 SD card the difference was around 20 times faster using the rdisk path.</p>
</blockquote>
<p>From <code>man hdiutil</code>:</p>
<blockquote>
<p>/dev/rdisk nodes are character-special devices, but are “raw” in the BSD sense and force block-aligned I/O. They are closer to the physical disk than the buffer cache. /dev/disk nodes, on the other hand, are buffered block-special devices and are used primarily by the kernel’s filesystem code.</p>
</blockquote>
<p>In layman’s terms <code>/dev/rdisk</code> goes almost directly to disk and <code>/dev/disk</code> goes via a longer more expensive route</p>
]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
  </entry>
  <entry>
    <title>配置树莓派成为一个 JTAG adapter</title>
    <url>/2020/12/11/Boards/Raspberry%20Pi/%E9%85%8D%E7%BD%AE%E6%A0%91%E8%8E%93%E6%B4%BE%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%20JTAG%20adapter/</url>
    <content><![CDATA[<p>OpenOCD 支持通过树莓派的 GPIO 作为一个 JTAG 调试器。</p>
<a id="more"></a>

<h2 id="配置树莓派成为一个-JTAG-adapter"><a href="#配置树莓派成为一个-JTAG-adapter" class="headerlink" title="配置树莓派成为一个 JTAG adapter"></a>配置树莓派成为一个 JTAG adapter</h2><p><a href="http://blog.sina.com.cn/s/blog_7cedb56d0102v141.html">http://blog.sina.com.cn/s/blog_7cedb56d0102v141.html</a></p>
<p>在树莓派上编译 openocd：</p>
<ol>
<li><p>下载 openocd 源码</p>
<p>基于提交： 1756f393e45c2a23dd29ff8bc85d188b547624f9</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone git:&#x2F;&#x2F;repo.or.cz&#x2F;openocd.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>按照 README 安装依赖库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install libtool pkg-config autoconf automake texinfo</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd openocd</span><br><span class="line">$ git checkout 1756f393e45c2a23dd29ff8bc85d188b547624f9</span><br><span class="line">$ .&#x2F;bootstrap</span><br><span class="line">$ .&#x2F;configure --enable-bcm2835gpio</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<p>按 BCM 编码，SWCLK 是 11 脚（排针23），SWDIO 是 25 脚（排针22），连接到 STM32F410 的 SWD 脚上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd tcl</span><br><span class="line">$ sudo openocd -f interface&#x2F;raspberrypi2-native.cfg -c &quot;transport select swd&quot; -f target&#x2F;stm32f4x.cfg -c init -c &quot;dump_image ram.bin 0x8000000 0x10000&quot;</span><br><span class="line">Open On-Chip Debugger 0.10.0+dev-00364-g1756f393 (2018-03-28-14:26)</span><br><span class="line">Licensed under GNU GPL v2</span><br><span class="line">For bug reports, read</span><br><span class="line">	http:&#x2F;&#x2F;openocd.org&#x2F;doc&#x2F;doxygen&#x2F;bugs.html</span><br><span class="line">BCM2835 GPIO config: tck &#x3D; 11, tms &#x3D; 25, tdi &#x3D; 10, tdo &#x3D; 9</span><br><span class="line">BCM2835 GPIO nums: swclk &#x3D; 11, swdio &#x3D; 25</span><br><span class="line">swd</span><br><span class="line">adapter speed: 20000 kHz</span><br><span class="line">adapter_nsrst_delay: 100</span><br><span class="line">none separate</span><br><span class="line">cortex_m reset_config sysresetreq</span><br><span class="line">Info : BCM2835 GPIO JTAG&#x2F;SWD bitbang driver</span><br><span class="line">Info : JTAG and SWD modes enabled</span><br><span class="line">Info : clock speed 4061 kHz</span><br><span class="line">Info : SWD DPIDR 0x2ba01477</span><br><span class="line">Info : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints</span><br><span class="line">Info : Listening on port 3333 for gdb connections</span><br><span class="line">dumped 65536 bytes in 0.123247s (519.282 KiB&#x2F;s)</span><br><span class="line">Info : Listening on port 6666 for tcl connections</span><br><span class="line">Info : Listening on port 4444 for telnet connections</span><br></pre></td></tr></table></figure>

<p>速度达到可怕的 519 KiB/s，J-Link 是 103KiB/s，是 J-Link 的 5 倍多！！！</p>
<p><img src="/2020/12/11/Boards/Raspberry%20Pi/%E9%85%8D%E7%BD%AE%E6%A0%91%E8%8E%93%E6%B4%BE%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%20JTAG%20adapter/image-20201208213734757.png" alt="image-20201208213734757"></p>
<p><strong>为什么会比 J-Link 要快？</strong></p>
<p>JTAG 通信速度由 GPIO 和 CPU 速度共同决定，J-Link v9 使用的是 STM32F205，GPIO 速度 60MHz，树莓派3B 的 BCM2837 的 GPIO 速度应该也是这个量级，并且从 log 可以看出，事实上树莓派的 JTAG clock speed 最大是 4MHz，而 J-Link 是 10MHz，这说明了影响 JTAG 速度的主要是 CPU 速度。STM32F205 最大 150 DMIPS，而树莓派是 11040 DMIPS，完全不是一个量级的，这就导致了树莓派虽然 JTAG 频率低，但是超快的协议处理速度还是让其通信速度碾压了 J-Link</p>
<p><strong>修改 JTAG 引脚</strong></p>
<p>在 raspberrypi2-native.cfg 内用 bcm2835gpio_swd_nums 来设置 SWD 使用的 GPIO，注意是 BCM 编码</p>
<p><strong>bit-bang</strong></p>
<blockquote>
<p>什么是SPI的bitbang / bit bang / bit-bang / bitbanging</p>
<p>在了解了基本的SPI之后，在Linux内核源码里面，发现关于SPI来说，有个叫做bitbang的东西，所以有点迷惑，想搞清楚bitbang是啥意思。</p>
<p>找了点资料，大概看明白了：</p>
<p>首先，对于多数情况来说，我们所用的SPI，都是有对应的SPI的控制器的，其负责和外部SPI设备进行通信，负责两者通信时候的信号之间的同步，保证信号的timing都符合SPI协议，保证可以正常进行SPI通信。</p>
<p>但是有些时候，没有此对应的硬件上的SPI控制器，而还想要和SPI设备通信，那么就只能用GPIO端口去模拟对应的SPI接口的对应的pin：片选CS，数据输入Data In，数据输出Data Out，始终Clock，去模拟SPI协议，和对应spi设备进行通信。所以，此时你对每个端口的操作，作为编程者，你自己要去负责信号的同步，保证timing符合协议规定，才能正常进行SPI通信。</p>
<p>这样的SPI的bit-bang，优点是不需要SPI的控制器了，但是缺点很明显，除了要用户自己负责同步，timing等事情之外，相对来说，即使本身SPI设备支持以很高的频率运行，可以实现很好的性能，但是以bit-bang的方式去使用的话，实际性能往往很差。</p>
<p>最后，可以用一句话来解释，什么是SPI的bitbang/bit-bang：</p>
<p>Use software to control serial communication at general-purpose I/O pins</p>
<p>通过GPIO引脚，用软件来模拟串行通信（SPI/I2C 。。。）。</p>
</blockquote>
</li>
</ol>
<h2 id="树莓派作-JTAG-的-OpenOCD-权限问题"><a href="#树莓派作-JTAG-的-OpenOCD-权限问题" class="headerlink" title="树莓派作 JTAG 的 OpenOCD 权限问题"></a>树莓派作 JTAG 的 OpenOCD 权限问题</h2><p>pi 用户提示<code>open: Permission denied</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ openocd -s rtl8710_openocd&#x2F; -f rtl8710_openocd&#x2F;interface&#x2F;raspberrypi2-native.cfg -f rtl8710_openocd&#x2F;rtl8710&#x2F;rtl8710.cfg</span><br><span class="line">Open On-Chip Debugger 0.10.0+dev-00364-g1756f393 (2018-03-30-05:45)</span><br><span class="line">Licensed under GNU GPL v2</span><br><span class="line">For bug reports, read</span><br><span class="line">	http:&#x2F;&#x2F;openocd.org&#x2F;doc&#x2F;doxygen&#x2F;bugs.html</span><br><span class="line">BCM2835 GPIO config: tck &#x3D; 11, tms &#x3D; 25, tdi &#x3D; 10, tdo &#x3D; 9</span><br><span class="line">BCM2835 GPIO nums: swclk &#x3D; 11, swdio &#x3D; 25</span><br><span class="line">swd</span><br><span class="line">Warn : Transport &quot;swd&quot; was already selected</span><br><span class="line">adapter speed: 10000 kHz</span><br><span class="line">adapter_nsrst_delay: 100</span><br><span class="line">none separate</span><br><span class="line">cortex_m reset_config vectreset</span><br><span class="line">Info : Listening on port 6666 for tcl connections</span><br><span class="line">Info : Listening on port 4444 for telnet connections</span><br><span class="line">Info : BCM2835 GPIO JTAG&#x2F;SWD bitbang driver</span><br><span class="line">Info : JTAG and SWD modes enabled</span><br><span class="line">open: Permission denied</span><br></pre></td></tr></table></figure>

<p>打开 -d 查看 debug log：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Info : 261 78 bcm2835gpio.c:438 bcm2835gpio_init(): JTAG and SWD modes enabled</span><br><span class="line">open: Permission denied</span><br><span class="line">Debug: 262 79 command.c:642 run_command(): Command failed with error code -100</span><br></pre></td></tr></table></figure>

<p>到源代码内查看，原来是写 /dev/mem 的权限问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (bcm2835gpio_jtag_mode_possible()) &#123;</span><br><span class="line">	if (bcm2835gpio_swd_mode_possible())</span><br><span class="line">		LOG_INFO(&quot;JTAG and SWD modes enabled&quot;);</span><br><span class="line">	else</span><br><span class="line">		LOG_INFO(&quot;JTAG only mode enabled (specify swclk and swdio gpio to add SWD mode)&quot;);</span><br><span class="line">&#125; else if (bcm2835gpio_swd_mode_possible()) &#123;</span><br><span class="line">	LOG_INFO(&quot;SWD only mode enabled (specify tck, tms, tdi and tdo gpios to add JTAG mode)&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	LOG_ERROR(&quot;Require tck, tms, tdi and tdo gpios for JTAG mode and&#x2F;or swclk and swdio gpio for SWD mode&quot;);</span><br><span class="line">	return ERROR_JTAG_INIT_FAILED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dev_mem_fd &#x3D; open(&quot;&#x2F;dev&#x2F;mem&quot;, O_RDWR | O_SYNC);</span><br><span class="line">if (dev_mem_fd &lt; 0) &#123;</span><br><span class="line">	perror(&quot;open&quot;);</span><br><span class="line">	return ERROR_JTAG_INIT_FAILED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>/dev/mem 是 CPU 的内存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -l &#x2F;dev&#x2F;mem</span><br><span class="line">crw-r----- 1 root kmem 1, 1 Apr  3 03:39 &#x2F;dev&#x2F;mem</span><br></pre></td></tr></table></figure>

<p>把 /dev/mem 换成 /dev/gpiomem，更安全，并且不需要 root 权限</p>
<h2 id="树莓派上多个-openocd（不同-io）并行运行时的问题"><a href="#树莓派上多个-openocd（不同-io）并行运行时的问题" class="headerlink" title="树莓派上多个 openocd（不同 io）并行运行时的问题"></a>树莓派上多个 openocd（不同 io）并行运行时的问题</h2><p>比如，使用 2,3 脚作为一组 SWD，使用 4,5 脚作为另一组 SWD，那么两组 SWD 同时跑起来时就会互相影响，导致同时只有一组能用，但是，2,3 脚的 SWD 和 10,11 脚的 SWD 就不会冲突。</p>
<p>原因是：SWDIO 是双向通信口，所以 openocd 要在通信时频繁地切换其方向（输入/输出），配置方向的寄存器是 10 个 io 共用一个寄存器（参考 BCM2835-ARM-Peripherals.pdf），总共有 0 -9 或者 10- 19 或者 20-27 三个寄存器。openocd 内配置某个 io 方向是对寄存器内位或/与来实现的，也就是（读出 - 与/或 - 写回），所以在不同进程内会有临界区风险发生。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define INP_GPIO(g) do &#123; *(pio_base+((g)&#x2F;10)) &amp;&#x3D; ~(7&lt;&lt;(((g)%10)*3)); &#125; while (0)</span><br></pre></td></tr></table></figure>

<p>即使是不属于同一个 io 方向配置寄存器，如 2,3 和 11,12，在频繁的启动 - 退出 openocd 时也会互相影响，原因是 bcm2835gpio.c 内有个 bug：bcm2835gpio.c 内使用 -1 来表示无效/不用的 io，但是它只对 trst 和 srst 作有效性判断，若使用 SWD 模式，那么 tdo, tdi 和 tck 也是不用的，此时代码内仍会去操作这些 io，就可能会写到其他 io，因为 -1%10 是 -1, -1 &lt;&lt; m 是不确定的。</p>
<h2 id="ondemand-模式下-CPU-频率变化导致的-SWCLK-变化问题"><a href="#ondemand-模式下-CPU-频率变化导致的-SWCLK-变化问题" class="headerlink" title="ondemand 模式下 CPU 频率变化导致的 SWCLK 变化问题"></a>ondemand 模式下 CPU 频率变化导致的 SWCLK 变化问题</h2><p>树莓派默认是 ondemand 模式，此模式下 CPU 会动态调整频率。由于 openocd 内是 bitbang 模拟协议，靠 while 循环来延时，所以 SWCLK 频率随之变化，导致了 SWD 连接不稳定。</p>
<p>修改为 powersave 模式，锁定 CPU 使用最低的 600MHz 频率就好了。</p>
]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
  </entry>
  <entry>
    <title>Cotex-M0 and plus</title>
    <url>/2020/12/11/CPU/ARM/Cotex-M0%20and%20plus/</url>
    <content><![CDATA[<p>Cortex-M0 和 M0+ 的区别。</p>
<a id="more"></a>

<h2 id="M0-和-M0-的区别"><a href="#M0-和-M0-的区别" class="headerlink" title="M0 和 M0+ 的区别"></a>M0 和 M0+ 的区别</h2><p>参考：<a href="https://community.cypress.com/docs/DOC-10652">Cortex® -M0 Versus Cortex-M0+ - KBA211306</a></p>
<p>The Cortex-M0+ processor builds on the Cortex-M0 processor, retaining the full instruction set and tool compatibility, while reducing energy consumption and increasing performance. </p>
<p>The following table lists the difference in the features of the two processors.                                                                                                                                         </p>
<table>
<thead>
<tr>
<th><strong>Features</strong></th>
<th><strong>M0</strong></th>
<th><strong>M0+</strong></th>
<th><strong>Advantages of M0+ over M0</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Pipeline</td>
<td>Three-stage</td>
<td>Two-stage</td>
<td>Improved response time,improved efficiency</td>
</tr>
<tr>
<td>Performance Efficiency</td>
<td>2.33 CoreMark/MHz</td>
<td>2.46 CoreMark/MHz</td>
<td>Lower power and higher performance</td>
</tr>
<tr>
<td>Memory Protection</td>
<td>Not available</td>
<td>Has optional Memory protection Unit</td>
<td>Makes system more secure by: Separating processes – Preventing tasks from corrupting stack or data memory used by other tasks Preventing unprivileged tasks from accessing peripherals that can be critical to the system security</td>
</tr>
<tr>
<td>Relocatable vectortable</td>
<td>Does not support</td>
<td>Supports</td>
<td>Allows relocating the interrupt vector table anywhere in the memory - enables different applications to use their own vector table.</td>
</tr>
<tr>
<td>Unprivileged/privileged mode execution</td>
<td>Does not support</td>
<td>Supports</td>
<td>Allows a task, such as the system calling in an operating system, to execute with more privileges than the user task or an application.</td>
</tr>
</tbody></table>
<h2 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h2><p>Cortex-M0 使用了 ARMv6-M 指令集，该指令集由 2 部分组成：</p>
<ul>
<li>除 CBZ, CBNZ 和 IT 外的所有 ARMv7-M 指令。</li>
<li>32-bit Thumb-2 指令：BL, DMB, DSB, ISB, MRS and MSR。</li>
</ul>
<p><em>Reference &lt; Cotex-M0 Technical Reference Manual &gt; 3.3 Instruction set summary</em></p>
<p>所以在移植 Cortex-M3 的汇编代码到 Cortex-M0 时要注意两点：</p>
<ul>
<li>CBZ 指令要用 CMP + BEQ 来代替。</li>
<li>STM 等多寄存器操作最大只能到 R7。</li>
</ul>
<h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>Cortex-M0 有两种工作模式：</p>
<ul>
<li>Thread mode - Normal code</li>
<li>Handler mode - Interrupt </li>
</ul>
<p>两种模式的唯一区别是 thread mode 可以额外选择使用 PSP 作为栈指针寄存器。</p>
<p><em>Reference &lt;The Definitive Guide to ARM Cortex-M0 and Cortex-M0+ Processors 2nd Edition&gt; Chapter 3 - Programmer’s Modle - Operation Modes and States - page 26</em></p>
<h2 id="用户等级"><a href="#用户等级" class="headerlink" title="用户等级"></a>用户等级</h2><p>Cortex-M0+ 有两种用户等级：</p>
<ul>
<li>Privileged</li>
<li>Nonprivileged</li>
</ul>
<p>Privileged 等级可以访问所有的内存，相对的，Nonprivileged 等级不能访问部分系统控制寄存器。</p>
<p>但 Cortex-M0 没有用户等级的区别，换句话说，Cortex-M0 始终工作在 Privileged  等级。</p>
<p>Reference &lt;Joseph Yiu - The Definitive Guide to ARM Cortex-M0 and Cortex-M0+ Processors 2nd Edition&gt; Chapter 7.8 - Memory Attributes and Memory Access Permission - page 179</p>
<h2 id="中断进-出操作和序列"><a href="#中断进-出操作和序列" class="headerlink" title="中断进/出操作和序列"></a>中断进/出操作和序列</h2><p>中断进入：</p>
<ul>
<li>把 R0 to R3, R12, LR, PC 和 xPSR 压入中断前使用的栈</li>
<li>取向量</li>
<li>更新 LR, IPSR 和 NVIC</li>
</ul>
<p>中断退出：</p>
<ul>
<li>把 R0 to R3, R12, LR, PC 和 xPSR 推出栈（根据 LR 的 EXC_RETURN bit 决定 MSP 还是 PSP）</li>
<li>返回断点处执行</li>
</ul>
<p><em>Reference &lt; Joseph Yiu - The Definitive Guide to ARM Cortex-M0 and Cortex-M0+ Processors 2nd Edition &gt; page 150</em></p>
<h2 id="内核中断控制"><a href="#内核中断控制" class="headerlink" title="内核中断控制"></a>内核中断控制</h2><p>Cortex-M0 的内核中断是在 SCB 寄存器组内控制的。</p>
<p><img src="/2020/12/11/CPU/ARM/Cotex-M0%20and%20plus/image-20201208214549837.png" alt="image-20201208214549837"></p>
<p><em>Reference &lt;The Definitive Guide to ARM Cortex-M0 and Cortex-M0+ Processors 2nd Edition&gt; - Chapter 9.2.1</em></p>
<p>其中，SHPR2 和 SHPR3 是控制内核中断的优先级的寄存器，ICSR 是悬起/解悬中断的寄存器。</p>
<p><img src="/2020/12/11/CPU/ARM/Cotex-M0%20and%20plus/image-20201208214558944.png" alt="image-20201208214558944"></p>
<p><em>Reference &lt;[The Definitive Guide to ARM Cortex-M0 and Cortex-M0+ Processors 2nd Edition](../../resources/ARM/The Definitive Guide to ARM Cortex-M0 and Cortex-M0+ Processors 2nd Edition.pdf)&gt; - Chapter 9.2.3</em></p>
<p>内核中断中，除 NMI, hardfault 外优先级都是可编程的，除 SYSTICK 外都是无法 disable 的。</p>
<p><img src="/2020/12/11/CPU/ARM/Cotex-M0%20and%20plus/image-20201208214649538.png" alt="image-20201208214649538"></p>
<p><em>Reference &lt;The Definitive Guide to ARM Cortex-M0 and Cortex-M0+ Processors 2nd Edition&gt; - Chapter 10.3.1</em></p>
<h2 id="ARMv6-M-和-ARMv7-M-的一些具体区别"><a href="#ARMv6-M-和-ARMv7-M-的一些具体区别" class="headerlink" title="ARMv6-M 和 ARMv7-M 的一些具体区别"></a>ARMv6-M 和 ARMv7-M 的一些具体区别</h2><h3 id="LDMIA-指令"><a href="#LDMIA-指令" class="headerlink" title="LDMIA 指令"></a>LDMIA 指令</h3><p><code>LDMIA &lt;Rn&gt;!, &lt;registers&gt;</code></p>
<p>Cortex-M0 的 LDMIA 指令只能操作 R0 ~ R7，是因为其只支持 16 bit 的指令。机器码格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 15 14 13 12 | 11 | 10 9 8 | 7 6 5 4 3 2 1 0 |</span><br><span class="line">|  1  1  0  0 | 1  |   Rn   |  register_list  |</span><br></pre></td></tr></table></figure>

<p>其中<code>register_list</code>的每个 bit 分别代表 R0 ~ R7 之间的一个寄存器。所以 LDMIA 只能操作到寄存器 R7。</p>
<p><strong>如果出现<code>Error: cannot honor width suffix</code>这样的编译错误，多半是操作的寄存器超出了范围，比如 LDMIA R0!, {R4 ~ R8}。</strong></p>
<p><em>Reference &lt; ARMv6-M Architecture Reference Manual &gt; A6.7.25 LDM, LDMIA, LDMFD</em></p>
<p>Cortex-M3 的 LDMIA 指令还支持 32 bit 格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 | 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 |</span><br><span class="line">|  1  1  1  0  1| 0 0|0 1 0|W 1|  Rn    | P | M|(0)|      register_list         |</span><br></pre></td></tr></table></figure>

<p>所以 Cortex-M3 最大可以操作到寄存器 R11。</p>
<p><em>Reference &lt; ARMv7-M Architecture Reference Manual &gt; A7.7.40 LDM, LDMIA, LDMFD</em></p>
<h3 id="通用寄存器出入栈的汇编代码"><a href="#通用寄存器出入栈的汇编代码" class="headerlink" title="通用寄存器出入栈的汇编代码"></a>通用寄存器出入栈的汇编代码</h3><p>由于 Cortex-M0 的 LDMIA 指令最大只能操作到 R7，所以只对于 R8 ~ R11 的入栈，要通过先拷贝 R8 ~ R11 到 R4 ~ R7 后再入栈 R4 - R7 的方法来实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void xPortPendSVHandler( void )</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;* This is a naked function. *&#x2F;</span><br><span class="line"></span><br><span class="line">	__asm volatile</span><br><span class="line">	(</span><br><span class="line">	&quot;	mrs r0, psp							\n&quot;</span><br><span class="line">	&quot;										\n&quot;</span><br><span class="line">	&quot;	ldr	r3, pxCurrentTCBConst			\n&quot; &#x2F;* Get the location of the current TCB. *&#x2F;</span><br><span class="line">	&quot;	ldr	r2, [r3]						\n&quot;</span><br><span class="line">	&quot;										\n&quot;</span><br><span class="line">	&quot;	sub r0, r0, #32						\n&quot; &#x2F;* Make space for the remaining low registers. *&#x2F;</span><br><span class="line">	&quot;	str r0, [r2]						\n&quot; &#x2F;* Save the new top of stack. *&#x2F;</span><br><span class="line">	&quot;	stmia r0!, &#123;r4-r7&#125;					\n&quot; &#x2F;* Store the low registers that are not saved automatically. *&#x2F;</span><br><span class="line">	&quot; 	mov r4, r8							\n&quot; &#x2F;* Store the high registers. *&#x2F;</span><br><span class="line">	&quot; 	mov r5, r9							\n&quot;</span><br><span class="line">	&quot; 	mov r6, r10							\n&quot;</span><br><span class="line">	&quot; 	mov r7, r11							\n&quot;</span><br><span class="line">	&quot; 	stmia r0!, &#123;r4-r7&#125;              	\n&quot;</span><br><span class="line">	&quot;										\n&quot;</span><br><span class="line">	&quot;	push &#123;r3, r14&#125;						\n&quot;</span><br><span class="line">	&quot;	cpsid i								\n&quot;</span><br><span class="line">	&quot;	bl vTaskSwitchContext				\n&quot;</span><br><span class="line">	&quot;	cpsie i								\n&quot;</span><br><span class="line">	&quot;	pop &#123;r2, r3&#125;						\n&quot; &#x2F;* lr goes in r3. r2 now holds tcb pointer. *&#x2F;</span><br><span class="line">	&quot;										\n&quot;</span><br><span class="line">	&quot;	ldr r1, [r2]						\n&quot;</span><br><span class="line">	&quot;	ldr r0, [r1]						\n&quot; &#x2F;* The first item in pxCurrentTCB is the task top of stack. *&#x2F;</span><br><span class="line">	&quot;	add r0, r0, #16						\n&quot; &#x2F;* Move to the high registers. *&#x2F;</span><br><span class="line">	&quot;	ldmia r0!, &#123;r4-r7&#125;					\n&quot; &#x2F;* Pop the high registers. *&#x2F;</span><br><span class="line">	&quot; 	mov r8, r4							\n&quot;</span><br><span class="line">	&quot; 	mov r9, r5							\n&quot;</span><br><span class="line">	&quot; 	mov r10, r6							\n&quot;</span><br><span class="line">	&quot; 	mov r11, r7							\n&quot;</span><br><span class="line">	&quot;										\n&quot;</span><br><span class="line">	&quot;	msr psp, r0							\n&quot; &#x2F;* Remember the new top of stack for the task. *&#x2F;</span><br><span class="line">	&quot;										\n&quot;</span><br><span class="line">	&quot;	sub r0, r0, #32						\n&quot; &#x2F;* Go back for the low registers that are not automatically restored. *&#x2F;</span><br><span class="line">	&quot; 	ldmia r0!, &#123;r4-r7&#125;              	\n&quot; &#x2F;* Pop low registers.  *&#x2F;</span><br><span class="line">	&quot;										\n&quot;</span><br><span class="line">	&quot;	bx r3								\n&quot;</span><br><span class="line">	&quot;										\n&quot;</span><br><span class="line">	&quot;	.align 4							\n&quot;</span><br><span class="line">	&quot;pxCurrentTCBConst: .word pxCurrentTCB	  &quot;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 Cortex-M3 则可以直接入栈 R4 ~ R11：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void xPortPendSVHandler( void )</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;* This is a naked function. *&#x2F;</span><br><span class="line"></span><br><span class="line">	__asm volatile</span><br><span class="line">	(</span><br><span class="line">	&quot;	mrs r0, psp							\n&quot;</span><br><span class="line">	&quot;	isb									\n&quot;</span><br><span class="line">	&quot;										\n&quot;</span><br><span class="line">	&quot;	ldr	r3, pxCurrentTCBConst			\n&quot; &#x2F;* Get the location of the current TCB. *&#x2F;</span><br><span class="line">	&quot;	ldr	r2, [r3]						\n&quot;</span><br><span class="line">	&quot;										\n&quot;</span><br><span class="line">	&quot;	stmdb r0!, &#123;r4-r11&#125;					\n&quot; &#x2F;* Save the remaining registers. *&#x2F;</span><br><span class="line">	&quot;	str r0, [r2]						\n&quot; &#x2F;* Save the new top of stack into the first member of the TCB. *&#x2F;</span><br><span class="line">	&quot;										\n&quot;</span><br><span class="line">	&quot;	stmdb sp!, &#123;r3, r14&#125;				\n&quot;</span><br><span class="line">	&quot;	mov r0, %0							\n&quot;</span><br><span class="line">	&quot;	msr basepri, r0						\n&quot;</span><br><span class="line">	&quot;	bl vTaskSwitchContext				\n&quot;</span><br><span class="line">	&quot;	mov r0, #0							\n&quot;</span><br><span class="line">	&quot;	msr basepri, r0						\n&quot;</span><br><span class="line">	&quot;	ldmia sp!, &#123;r3, r14&#125;				\n&quot;</span><br><span class="line">	&quot;										\n&quot;	&#x2F;* Restore the context, including the critical nesting count. *&#x2F;</span><br><span class="line">	&quot;	ldr r1, [r3]						\n&quot;</span><br><span class="line">	&quot;	ldr r0, [r1]						\n&quot; &#x2F;* The first item in pxCurrentTCB is the task top of stack. *&#x2F;</span><br><span class="line">	&quot;	ldmia r0!, &#123;r4-r11&#125;					\n&quot; &#x2F;* Pop the registers. *&#x2F;</span><br><span class="line">	&quot;	msr psp, r0							\n&quot;</span><br><span class="line">	&quot;	isb									\n&quot;</span><br><span class="line">	&quot;	bx r14								\n&quot;</span><br><span class="line">	&quot;										\n&quot;</span><br><span class="line">	&quot;	.align 4							\n&quot;</span><br><span class="line">	&quot;pxCurrentTCBConst: .word pxCurrentTCB	\n&quot;</span><br><span class="line">	::&quot;i&quot;(configMAX_SYSCALL_INTERRUPT_PRIORITY)</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ARM</category>
      </categories>
  </entry>
  <entry>
    <title>Hardfault 调试实例</title>
    <url>/2020/12/11/CPU/ARM/Hardfault%20%E8%B0%83%E8%AF%95%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>ARM hardfault 调试的一些例子。</p>
<a id="more"></a>

<h2 id="非对齐的访问"><a href="#非对齐的访问" class="headerlink" title="非对齐的访问"></a>非对齐的访问</h2><p>rf_pin_sleep 函数，在按键长按回调中调用没有异常，但是在 TIM_SLP 定时器回调中就会挂掉，调试发现是触发了 Hardfault。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rf_pin_sleep</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">  EXTI_InitStructure.EXTI_Line = EXTI_Line5;</span><br><span class="line">  EXTI_InitStructure.EXTI_LineCmd = DISABLE;</span><br><span class="line">  EXTI_Init(&amp;EXTI_InitStructure);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实按键长按回调也是定时器的回调，有什么区别呢。</p>
<p>用 Ozone 跟进看可能的异常是 UNALIGN_TRA，也就是非对齐的访问。</p>
<p><img src="/2020/12/11/CPU/ARM/Hardfault%20%E8%B0%83%E8%AF%95%E5%AE%9E%E4%BE%8B/image-20201122230410929.png" alt="image-20201122230410929"></p>
<p>EXTI_Init 对于 DISABLE 的处理如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_Init</span><span class="params">(EXTI_InitTypeDef *EXTI_InitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> tmp = (<span class="keyword">uint32_t</span>)EXTI_BASE;</span><br><span class="line">    ...</span><br><span class="line">    tmp = (<span class="keyword">uint32_t</span>)EXTI_BASE;</span><br><span class="line">    tmp += EXTI_InitStruct-&gt;EXTI_Mode;</span><br><span class="line">    <span class="comment">/* Disable the selected external lines */</span></span><br><span class="line">    *(__IO <span class="keyword">uint32_t</span> *)tmp &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里有个 EXTI_Mode 并没有在 EXTI_InitStructure 变量中赋值，EXTI_InitStructure 是个局部变量，位于栈上，那么 EXTI_Mode 也就是个不确定的值。</p>
<p>故而在不同的函数中调用此函数表现不一，若 EXTI_Mode 的值刚好不对齐 word，那么就会导致 Hardfault。</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
  </entry>
  <entry>
    <title>一种在 ARM968E-S 上重定向中断向量表的方法</title>
    <url>/2020/12/12/CPU/ARM/%E4%B8%80%E7%A7%8D%E5%9C%A8%20ARM968E-S%20%E4%B8%8A%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>ARM968E-S 架构非常古老，不支持中断向量重定向，所以此功能需要用户自己在代码中实现，也即在固定的中断向量函数内跳转到 RAM 那的用户向量地址。</p>
<p>由于此架构不会在中断时自动保存寄存器，所以必须由用户手动把寄存器入栈出栈。但是从 RAM 中取值需要用到寄存器 Rn，把这个值赋给 PC 也需要寄存器 Rn，所以就无法避免的会修改到 Rn 的值。</p>
<a id="more"></a>

<p>之前的做法是在进 boot 中断后先把 Rn 入栈，跳转到 APP 中断后再把 Rn 出栈，但这样用户的中断处理程序就比较奇怪（一开始就要把 Rn 出栈）并且不注意就容易出错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Bootloader</span><br><span class="line">boot_iqr:</span><br><span class="line">PUSH &#123;R0&#125;</span><br><span class="line">LDR R0,&#x3D;0x400018</span><br><span class="line">LDR R0, [R0]</span><br><span class="line">LDR PC, R0</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;Application</span><br><span class="line">app_irq:</span><br><span class="line">POP &#123;R0&#125;</span><br><span class="line">user process</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>其实给 PC 赋值除了LDR PC, Rn之外，还可以使用 POP 指令POP {PC}把栈内的值弹到 PC 中来变相实现跳转。</p>
<p>先把中断地址从 RAM 中 LOAD 到当前栈内，并把 SP 递增，然后使用POP {PC}来跳转。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Bootloader</span><br><span class="line">boot_iqr:</span><br><span class="line">SUB SP, SP, #4</span><br><span class="line">PUSH &#123;R0&#125;</span><br><span class="line">LDR R0, &#x3D; 0x400018</span><br><span class="line">LDR R0, [R0]</span><br><span class="line">ADD SP, SP, #8</span><br><span class="line">PUSH &#123;R0&#125;</span><br><span class="line">SUB SP, SP, #4</span><br><span class="line">POP &#123;R0&#125;</span><br><span class="line">POP &#123;PC&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;Application</span><br><span class="line">app_irq:</span><br><span class="line">user process</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>流程图如下</p>
<p><img src="/2020/12/12/CPU/ARM/%E4%B8%80%E7%A7%8D%E5%9C%A8%20ARM968E-S%20%E4%B8%8A%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%E7%9A%84%E6%96%B9%E6%B3%95/%E6%9C%AA%E5%91%BD%E5%90%8D%E5%9B%BE%E7%89%87.png"></p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
  </entry>
  <entry>
    <title>GCC 实用方法</title>
    <url>/2020/12/11/Complie%20&amp;%20Debug/GCC/GCC%20%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>GCC 的一些实用的方法。</p>
<a id="more"></a>

<h2 id="到底使用了哪个头文件？"><a href="#到底使用了哪个头文件？" class="headerlink" title="到底使用了哪个头文件？"></a>到底使用了哪个头文件？</h2><p>一个 SDK 中可能存在多个同名的 .h 文件，如何确定 .c 中到底使用的是哪个 .h 呢？</p>
<p>GCC 有一个选项 -M 可以输出 .c 所包含的所有 .h，使用此方法能确定 .c 使用的 .h 文件。</p>
<p>开发 5062 时遇到了编译错误：<code>error: &#39;errno&#39; undeclared</code>，可能是 .c 使用了一个错误的非系统的 errno.h，于是到 build 目录下去查找对应的 .d 文件，发现果然用的是一个原厂自己写的 errno.h，其中没有声明 errno。</p>
<h2 id="屏蔽编译-warning-输出"><a href="#屏蔽编译-warning-输出" class="headerlink" title="屏蔽编译 warning 输出"></a>屏蔽编译 warning 输出</h2><p>有时候 warning 太多，淹没了 error，可以用 -w 选项屏蔽 warning 输出。</p>
<h2 id="使用-strip-精简静态库的大小"><a href="#使用-strip-精简静态库的大小" class="headerlink" title="使用 strip 精简静态库的大小"></a>使用 strip 精简静态库的大小</h2><p><code>arm-none-eabi-strip -o lib.strip.a lib.a --strip-debug</code></p>
<p>静态库只能使用<code>--strip-debug</code>选项，去除库中的 debug 信息，可以把一个 16M 的静态库精简到 280K。</p>
<p>注意：使用<code>ar -M &lt; script</code>方式将多个 .a 打包成的静态库不能使用 strip 命令。</p>
<h2 id="在-map-表内查找静态变量和函数地址"><a href="#在-map-表内查找静态变量和函数地址" class="headerlink" title="在 map 表内查找静态变量和函数地址"></a>在 map 表内查找静态变量和函数地址</h2><p>静态变量和函数其实在 map 表内也能查到的，首先要使能 GCC 的编译选项<code>-fdata-sections -ffunction-sections</code>，为变量和函数生成一个专有的段名称。</p>
<p>以静态变量来举例说明：</p>
<p>ota.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static uint8_t flash_data_buf;</span><br><span class="line"></span><br><span class="line">void ota(void)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>main.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void hal_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	static uint8_t flash_data_buf;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">	static uint8_t flash_data_buf;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于在函数外的静态变量，在 map 表中形式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.bss.flash_data_buf</span><br><span class="line">                0x0000000000400234     0x1000 build&#x2F;src&#x2F;system&#x2F;ota.o</span><br></pre></td></tr></table></figure>

<p>对于函数内的静态变量，在 map 表中形式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.bss.flash_data_buf.5993</span><br><span class="line">               0x00000000004001fd        0x1 build&#x2F;src&#x2F;system&#x2F;main.o</span><br><span class="line">.bss.flash_data_buf.5989</span><br><span class="line">               0x00000000004001fe        0x1 build&#x2F;src&#x2F;system&#x2F;main.o</span><br></pre></td></tr></table></figure>
<p>这种情况就要结合反汇编来确定了。</p>
<h2 id="builtin-return-address-获取调用者的地址"><a href="#builtin-return-address-获取调用者的地址" class="headerlink" title="__builtin_return_address() 获取调用者的地址"></a>__builtin_return_address() 获取调用者的地址</h2><p><code>void * __builtin_return_address (unsigned int level)</code>是 GCC 的一个内建函数，<code>__builtin_return_address(0)</code>的含义是，得到当前函数返回地址，即此函数被别的函数调用，然后此函数执行完毕返回后的下一条地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printf(&quot;%s(0) &#x3D; %p\r\n&quot;, __FUNCTION__, __builtin_return_address(0));</span><br></pre></td></tr></table></figure>

<p>反汇编如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">8088088:	4674      	mov	r4, lr</span><br><span class="line">...</span><br><span class="line">80880b8:	4622      	mov	r2, r4</span><br><span class="line">80880ba:	490f      	ldr	r1, [pc, #60]	; (80880f8 &lt;application_start+0x78&gt;)</span><br><span class="line">80880bc:	480f      	ldr	r0, [pc, #60]	; (80880fc &lt;application_start+0x7c&gt;)</span><br><span class="line">80880be:	f00b fd67 	bl	8093b90 &lt;iprintf&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>所以这个函数其实就是返回 LR 的值。</p>
<h2 id="AR"><a href="#AR" class="headerlink" title="AR"></a>AR</h2><p><a href="http://sourceware.org/binutils/docs-2.31/binutils/ar-cmdline.html#ar-cmdline">http://sourceware.org/binutils/docs-2.31/binutils/ar-cmdline.html#ar-cmdline</a></p>
<p><code>ar -rcs archive objects</code>将 objects 文件打包成库</p>
<p><code>c</code> - create，创建新库</p>
<p><code>r</code> - replace，替换已有库中的目标文件</p>
<p><code>s</code> - 更新库中的索引</p>
<p><code>d</code> - delete，删除库中的目标文件</p>
<p><code>x</code> - extract，解压出库中的目标文件</p>
<p><code>t</code> - 列出库中所有的目标文件</p>
]]></content>
      <categories>
        <category>GCC</category>
      </categories>
  </entry>
  <entry>
    <title>GCC 常见错误</title>
    <url>/2020/12/11/Complie%20&amp;%20Debug/GCC/GCC%20%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>GCC 常见的错误和解决方法记录。</p>
<a id="more"></a>

<h2 id="undefined-reference-to-fini"><a href="#undefined-reference-to-fini" class="headerlink" title="undefined reference to _fini"></a>undefined reference to <code>_fini</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lib_a-fini.o): In function &#96;__libc_fini_array&#39;:</span><br><span class="line">fini.c:(.text.__libc_fini_array+0x1c): undefined reference to &#96;_fini&#39;</span><br></pre></td></tr></table></figure>
<p>__libc_fini_array 和 _fini 是负责 C++ 的析构，如果没有用到 C++ 而又出现上述错误，一般是因为 .ld 中把相关的段 KEEP 了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KEEP ((.init_array))</span><br></pre></td></tr></table></figure>
<h2 id="undefined-reference-to-locale-ctype-ptr-or-ctype-ptr"><a href="#undefined-reference-to-locale-ctype-ptr-or-ctype-ptr" class="headerlink" title="undefined reference to __locale_ctype_ptr or __ctype_ptr__"></a>undefined reference to <code>__locale_ctype_ptr</code> or <code>__ctype_ptr__</code></h2><p>在 OSX 上编译的库，在 windows 上链接时报错：undefined reference to <code>__locale_ctype_ptr</code>。</p>
<p>在 windows 上编译的苦，在 OSX 上链接时报错：undefined reference to <code>__ctype_ptr__</code>。</p>
<p>原因是代码中有用到<code>islower</code>,<code>isxdigit</code>等函数，这些函数在 GCC 的 windows 和 unix-like 上的实现有差异的，它们其实都是宏定义，但在 windows 上，是一个数组指针<code>__ctype_ptr__</code>的索引来实现，而在 OSX 上，是一个函数<code>__locale_ctype_ptr</code>的返回值的索引来实现。</p>
<p>LwIP 开发者可能也遇到了这个问题，于是他们的做法是自己重新定义了这些函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define in_range(c, lo, up)  ((u8_t)c &gt;&#x3D; lo &amp;&amp; (u8_t)c &lt;&#x3D; up)</span><br><span class="line">#define isprint(c)           in_range(c, 0x20, 0x7f)</span><br><span class="line">#define isdigit(c)           in_range(c, &#39;0&#39;, &#39;9&#39;)</span><br><span class="line">#define isxdigit(c)          (isdigit(c) || in_range(c, &#39;a&#39;, &#39;f&#39;) || in_range(c, &#39;A&#39;, &#39;F&#39;))</span><br><span class="line">#define islower(c)           in_range(c, &#39;a&#39;, &#39;z&#39;)</span><br><span class="line">#define isspace(c)           (c &#x3D;&#x3D; &#39; &#39; || c &#x3D;&#x3D; &#39;\f&#39; || c &#x3D;&#x3D; &#39;\n&#39; || c &#x3D;&#x3D; &#39;\r&#39; || c &#x3D;&#x3D; &#39;\t&#39; || c &#x3D;&#x3D; &#39;\v&#39;)</span><br></pre></td></tr></table></figure>

<p>这样就不会遇到编译的库在另外一个操作系统上链接不过的问题了。</p>
<h2 id="Multiple-definitions-of-xxx"><a href="#Multiple-definitions-of-xxx" class="headerlink" title="Multiple definitions of xxx"></a>Multiple definitions of xxx</h2><p>一般是因为重复的函数或者变量的定义，有三种情况：</p>
<ul>
<li>源代码中有多处重复的定义。</li>
<li>源代码中有一处定义，库中也有一处重复的定义。</li>
<li>库中两个目标文件包含重复的定义，但仅在开启<code>--whole-archive</code>链接选项后才会触发此错误。</li>
</ul>
<h3 id="whole-archive的作用"><a href="#whole-archive的作用" class="headerlink" title="--whole-archive的作用"></a><code>--whole-archive</code>的作用</h3><p>在两个文件中分别定义了一个 weak 函数和一个 strong 函数，然后编译打包在一个库，链接此库后生成的可执行程序内却调用了 weak 函数，这是因为 LD 会默认使用 object 文件中找到的第一个函数的地址。若 weak 函数所在 object 文件排在 strong 函数前面，则会产生此问题。</p>
<p>解决此问题的方法是实用<code>--whole-archive</code>选项，使 LD 遍历所有的 object 文件。</p>
]]></content>
      <categories>
        <category>GCC</category>
      </categories>
  </entry>
  <entry>
    <title>链接器的“两步链接”</title>
    <url>/2020/12/11/Complie%20&amp;%20Debug/GCC/%E9%93%BE%E6%8E%A5%E5%99%A8%E7%9A%84%E2%80%9C%E4%B8%A4%E6%AD%A5%E9%93%BE%E6%8E%A5%E2%80%9D/</url>
    <content><![CDATA[<p><code>两部链接</code>（Two-pass linking），是指链接的过程分为两步：<strong>地址分配 **和 **重定位</strong>。</p>
<a id="more"></a>

<h4 id="地址分配"><a href="#地址分配" class="headerlink" title="地址分配"></a>地址分配</h4><p>扫描输入的目标文件，分配各目标文件内各段的地址，并收集全局符号定义和引用，放入一个全局符号表。完成这一步后，所有的符号地址都被确定了。</p>
<h4 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h4><p>重定位各输入文件中引用的全局符号到其实际的地址。<br>在地址分配的过程中，链接器合并各输入的目标文件内相同的段，并为其分配空间和地址。</p>
<p> 在输入目标文件内有个<strong>重定位表</strong>来保存重定位的相关信息。它由符号信息和偏移组成。重定位时就是根据符号信息去找到其他输入目标文件内定义的符号的地址，再根据符号在本段内的偏移来替换为其实际的地址。</p>
<p> [1]：目标文件内符号的地址是相对于其所属段段相对地址，所以段的地址被分配后，符号的地址也确定了。</p>
<p>参考：<em>《程序员的自我修养》，第 4 章 1 ~ 2 节</em>。</p>
]]></content>
      <categories>
        <category>GCC</category>
      </categories>
  </entry>
  <entry>
    <title>GDB 实用方法</title>
    <url>/2020/12/11/Complie%20&amp;%20Debug/GDB/GDB%20%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>GDB 的一些实用方法。</p>
<a id="more"></a>

<h2 id="线程调试"><a href="#线程调试" class="headerlink" title="线程调试"></a>线程调试</h2><p>Reference <a href="https://www.sourceware.org/gdb/onlinedocs/gdb/Threads.html#Threads">4.10 Debugging Programs with Multiple Threads</a></p>
<p>显示当前所有的线程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">info threads</span><br></pre></td></tr></table></figure>

<p>切换到指定线程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread thread-id</span><br></pre></td></tr></table></figure>

<p>向指定线程执行指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread apply [thread-id-list] [all] args</span><br></pre></td></tr></table></figure>

<h3 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h3><p>Reference <a href="https://www.sourceware.org/gdb/onlinedocs/gdb/Backtrace.html">8.2 Backtraces</a></p>
<p>显示当前线程的 backtrace：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bt</span><br></pre></td></tr></table></figure>

<p>显示指定线程的 backtrace：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread apply thread-id backtrace</span><br></pre></td></tr></table></figure>

<p>显示所有线程的 backtrace：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread apply all backtrace</span><br></pre></td></tr></table></figure>

<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>2.1.3 What gdb Does During Startup</p>
<p>Here’s the description of what gdb does during session startup: </p>
<ol>
<li><p>Sets up the command interpreter as specified by the command line (see Section 2.1.2 [Mode Options], page 13). </p>
</li>
<li><p>Reads the system-wide init file (if ‘–with-system-gdbinit’ was used when building gdb; see Section C.6 [System-wide configuration and settings], page 612) and executes all the commands in that file. </p>
</li>
<li><p>Reads the init file (if any) in your home directory 1 and executes all the commands in that file. </p>
</li>
<li><p>Executes commands and command files specified by the ‘-iex’ and ‘-ix’ options in their specified order. Usually you should use the ‘-ex’ and ‘-x’ options instead, but this way you can apply settings before gdb init files get executed and before inferior gets loaded. </p>
</li>
<li><p>Processes command line options and operands. </p>
</li>
<li><p>Reads and executes the commands from init file (if any) in the current working directory as long as ‘set auto-load local-gdbinit’ is set to ‘on’ (see Section 22.7.1 [Init File in the Current Directory], page 314). This is only done if the current directory is different from your home directory. Thus, you can have more than one init file, one generic in your home directory, and another, specific to the program you are debugging, in the directory where you invoke gdb. </p>
</li>
<li><p>If the command line specified a program to debug, or a process to attach to, or a core file, gdb loads any auto-loaded scripts provided for the program or for its loaded shared libraries. See Section 22.7 [Auto-loading], page 312. If you wish to disable the auto-loading during startup, you must do something like the following:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb -iex &quot;set auto-load python-scripts off&quot; myprogram</span><br></pre></td></tr></table></figure>

<p>Option ‘-ex’ does not work because the auto-loading is then turned off too late. </p>
</li>
<li><p>Executes commands and command files specified by the ‘-ex’ and ‘-x’ options in their specified order. See Section 23.1.3 [Command Files], page 328, for more details about gdb command files. </p>
</li>
<li><p>Reads the command history recorded in the history file. See Section 22.3 [Command History], page 308, for more details about the command history and the files where gdb records it.</p>
</li>
</ol>
<p>gdb 启动时会默认执行 home 目录下的 .gdbinit，然后执行当前目录下的 .gdbinit</p>
<h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><h3 id="启动-gdb-时执行命令"><a href="#启动-gdb-时执行命令" class="headerlink" title="启动 gdb 时执行命令"></a>启动 gdb 时执行命令</h3><ol>
<li><p>单个命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-eval-command command </span><br><span class="line">-ex command </span><br><span class="line">Execute a single gdb command. This option may be used multiple times to call multiple commands. It may also be interleaved with ‘-command’ as required.</span><br><span class="line">gdb -ex &#39;target sim&#39; -ex &#39;load&#39; -x setbreakpoints -ex &#39;run&#39; a.out</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-command file</span><br><span class="line">-x file </span><br><span class="line">Execute commands from file file. The contents of this file is evaluated exactly as the source command would. See Section 23.1.3 [Command files], page 328.</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="启动-gdb-后执行脚本"><a href="#启动-gdb-后执行脚本" class="headerlink" title="启动 gdb 后执行脚本"></a>启动 gdb 后执行脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source [-s] [-v] filename </span><br><span class="line">Execute the command file filename.</span><br></pre></td></tr></table></figure>

<h3 id="执行-shell-命令"><a href="#执行-shell-命令" class="headerlink" title="执行 shell 命令"></a>执行 shell 命令</h3><p>上面说的方法都只能执行 gdb 内建的命令，若要执行 shell 命令，需要用 gdb shell 命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell command-string !command-string </span><br><span class="line">Invoke a standard shell to execute command-string. Note that no space is needed between ! and command-string. If it exists, the environment variable SHELL determines which shell to run. Otherwise gdb uses the default shell (‘&#x2F;bin&#x2F;sh’ on Unix systems, ‘COMMAND.COM’ on MS-DOS, etc.).</span><br></pre></td></tr></table></figure>

<p> 在 windows 上，shell 的命令要放到后台执行，则需使用<code>start /B</code></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>有时候需要在命令行启动 gdb 同时执行一些指令，这样就不用每次重复敲一遍了，特别是在脚本内很有用。</p>
<p>比如要在启动 gdb 时启动 openocd 并连接 openocd server，然后让程序在 main 函数停下来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arm-none-eabi-gdb -x .gdbinit -ex &#39;target remote localhost:3333&#39; -ex &#39;break main&#39; -ex &#39;continue&#39; test.elf --tui</span><br></pre></td></tr></table></figure>

<p>在 windows 上 .gdbinit 为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell start &#x2F;B .&#x2F;mico-os&#x2F;makefiles&#x2F;OpenOCD&#x2F;binary&#x2F;Win32&#x2F;openocd_mico </span><br><span class="line">-f .&#x2F;mico-os&#x2F;makefiles&#x2F;OpenOCD&#x2F;interface&#x2F;jlink_swd.cfg </span><br><span class="line">-f .&#x2F;mico-os&#x2F;makefiles&#x2F;OpenOCD&#x2F;MX1290&#x2F;MX1290.cfg</span><br></pre></td></tr></table></figure>

<p> 在 unix/like 上:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell .&#x2F;mico-os&#x2F;makefiles&#x2F;OpenOCD&#x2F;binary&#x2F;OSX&#x2F;openocd_mico </span><br><span class="line">-f .&#x2F;mico-os&#x2F;makefiles&#x2F;OpenOCD&#x2F;interface&#x2F;jlink_swd.cfg </span><br><span class="line">-f .&#x2F;mico-os&#x2F;makefiles&#x2F;OpenOCD&#x2F;MX1290&#x2F;MX1290.cfg &amp;</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li><p>寄存器的读取要使用小写，如 p $basepri</p>
</li>
<li><p>使用 display /x $basepri，可以在每次操作，如单步后自动显示此寄存器值。</p>
</li>
<li><p>开启 watch 断点会让速度变慢，不晓得为啥，可能是因为每步都要对比吧。</p>
</li>
<li><p>remote timeout，在调试 MX1101 时遇到了一个问题，先启动 OpenOCD server，再起 gdb 去连接，再等待了一会之后显示失败：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ignoring packet error, continuing...</span><br><span class="line">warning: unrecognized item &quot;timeout&quot; in &quot;qSupported&quot; response</span><br><span class="line">Remote replied unexpectedly to &#39;vMustReplyEmpty&#39;: PacketSize&#x3D;3fff;qXfer:memory-map:read-;qXfer:features:read+;QStartNoAckMode+</span><br></pre></td></tr></table></figure>

<p>OpenOCD 端显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Warn : negative reply, retrying</span><br><span class="line">Warn : negative reply, retrying</span><br><span class="line">Warn : negative reply, retrying</span><br><span class="line">Error: GDB missing ack(2) - assumed good</span><br><span class="line">Error: GDB missing ack(2) - assumed good</span><br><span class="line">Error: GDB missing ack(2) - assumed good</span><br></pre></td></tr></table></figure>

<p>只要在 gdb 命令里加上 set remotetimeout 20 就好了。</p>
<p>那么为什么连接时间这么久呢，原来是因为我设置的 jtag 速度太慢了 100KHz，所以连接的很慢。并且读写 RAM 的速度也很慢。</p>
</li>
<li><p>watch *address 可以监视某个地址是否被写。</p>
</li>
<li><p>bkpt</p>
</li>
</ol>
]]></content>
      <categories>
        <category>GDB</category>
      </categories>
  </entry>
  <entry>
    <title>OpenOCD 实用方法</title>
    <url>/2020/12/11/Complie%20&amp;%20Debug/OpenOCD/OpenOCD%20%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>OpenOCD 的一些实用方法。</p>
<a id="more"></a>

<h2 id="Flash-Commands"><a href="#Flash-Commands" class="headerlink" title="Flash Commands"></a>Flash Commands</h2><p><em>Referencd openocd.pdf</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flash write_image [erase] [unlock] filename [offset] [type]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Write the image filename to the current target’s flash bank(s). Only loadable sections from the image are written. A relocation offset may be specified, in which case it is added to the base address for each section in the image. The file [type] can be specified explicitly as bin (binary), ihex (Intel hex), elf (ELF file), s19 (Motorola s19). mem, or builder. The relevant flash sectors will be erased prior to programming if the erase parameter is given. If unlock is provided, then the flash banks are unlocked before erase and program. The flash bank to use is inferred from the address of each image section.</p>
<p><strong>Warning:</strong> Be careful using the erase flag when the flash is holding data you want to preserve. Portions of the flash outside those described in the image’s sections might be erased with no notice.</p>
<ul>
<li>When a section of the image being written does not fill out all the sectors it uses, the unwritten parts of those sectors are necessarily also erased, because sectors can’t be partially erased.</li>
<li>Data stored in sector “holes” between image sections are also af- fected. For example, “flash write_image erase …” of an image with one byte at the beginning of a flash bank and one byte at the end erases the entire bank – not just the two sectors being written.</li>
</ul>
<p>Also, when flash protection is important, you must re-apply it after it has been removed by the unlock flag.</p>
</blockquote>
<h2 id="Image-loading-commands"><a href="#Image-loading-commands" class="headerlink" title="Image loading commands"></a>Image loading commands</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dump_image filename address size</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Dump size bytes of target memory starting at address to the binary file named filename.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load_image filename address [[bin|ihex|elf|s19] min_addr max_length]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Load image from file filename to target memory offset by address from its load address. The file format may optionally be specified (bin, ihex, elf, or s19). In addition the following arguments may be specifed: min addr - ignore data below min addr (this is w.r.t. to the target’s load address + address) max length - maximum number of bytes to load. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proc load_image_bin &#123;fname foffset address length &#125; &#123; </span><br><span class="line">  # Load data from fname filename at foffset offset to </span><br><span class="line">  # target at address. Load at most length bytes. </span><br><span class="line">  load_image $fname [expr $address - $foffset] bin $address $length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Breakpoint-and-Watchpoint-commands"><a href="#Breakpoint-and-Watchpoint-commands" class="headerlink" title="Breakpoint and Watchpoint commands"></a>Breakpoint and Watchpoint commands</h2><p>CPUs often make debug modules accessible through JTAG, with hardware support for a handful of code breakpoints and data watchpoints. In addition, CPUs almost always support software breakpoints.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bp [address len [hw]]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>With no parameters, lists all active breakpoints. Else sets a breakpoint on code execution starting at address for length bytes. This is a software breakpoint, unless hw is specified in which case it will be a hardware breakpoint. (See [arm9 vector catch], page 117, or see [xscale vector catch], page 120, for similar mechanisms that do not consume hardware breakpoints.)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rbp address</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Remove the breakpoint at address. </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rwp address </span><br></pre></td></tr></table></figure>

<blockquote>
<p>Remove data watchpoint on address</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wp [address len [(r|w|a) [value [mask]]]]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>With no parameters, lists all active watchpoints. Else sets a data watchpoint on data from address for length bytes. The watch point is an “access” watchpoint unless the r or w parameter is provided, defining it as respectively a read or write watchpoint. If a value is provided, that value is used when determining if the watchpoint should trigger. The value may be first be masked using mask to mark “don’t care” fields.</p>
</blockquote>
<h2 id="TCP-IP-Ports"><a href="#TCP-IP-Ports" class="headerlink" title="TCP/IP Ports"></a>TCP/IP Ports</h2><blockquote>
<p>The OpenOCD server accepts remote commands in several syntaxes. Each syntax uses a different TCP/IP port, which you may specify only during configuration (before those ports are opened).</p>
<p>For reasons including security, you may wish to prevent remote access using one or more of these ports. In such cases, just specify the relevant port number as “disabled”. If you disable all access through TCP/IP, you will need to use the command line -pipe option.</p>
</blockquote>
<p>OpenOCD 默认会起三个 tcp server：gdb_port，tcl_port 和 telnet_port，默认端口分别为：3333，4444，6666。若不想开启某个 tcp server，指定其端口号为 disabled 即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb_port [number]</span><br><span class="line">tcl_port [number]</span><br><span class="line">telnet_port [number]</span><br></pre></td></tr></table></figure>

<h2 id="Get-serial-number-of-J-Link"><a href="#Get-serial-number-of-J-Link" class="headerlink" title="Get serial number of J-Link"></a>Get serial number of J-Link</h2><p>对于连接了多个 J-Link 的情况，OpenOCD 提供了一个命令 jlink serial [number] 来指定其中一个。</p>
<p>但是 OpenOCD 没有提供查询 J-Link SN 的指令，这就需要我们自己来实现了。</p>
<p>参考源码中 jlink_init 函数中对 J-Link serial 查询的那部分代码，对 jlink_serial_command 函数进行改造：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMMAND_HANDLER(jlink_serial_command)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	struct jaylink_device **devs;</span><br><span class="line">	unsigned int i;</span><br><span class="line">	uint32_t tmp;</span><br><span class="line">	enum jaylink_usb_address address;</span><br><span class="line">	size_t num_devices;</span><br><span class="line">	uint32_t host_interfaces;</span><br><span class="line">    struct jaylink_context *_jayctx;</span><br><span class="line">	</span><br><span class="line">	if (CMD_ARGC &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		LOG_DEBUG(&quot;Using libjaylink %s (compiled with %s).&quot;,</span><br><span class="line">			jaylink_version_package_get_string(), JAYLINK_VERSION_PACKAGE_STRING);</span><br><span class="line"></span><br><span class="line">		if (!jaylink_library_has_cap(JAYLINK_CAP_HIF_USB) &amp;&amp; use_usb_address) &#123;</span><br><span class="line">			LOG_ERROR(&quot;J-Link driver does not support USB devices.&quot;);</span><br><span class="line">			return ERROR_JTAG_INIT_FAILED;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ret &#x3D; jaylink_init(&amp;_jayctx);</span><br><span class="line"></span><br><span class="line">		if (ret !&#x3D; JAYLINK_OK) &#123;</span><br><span class="line">			LOG_ERROR(&quot;jaylink_init() failed: %s.&quot;, jaylink_strerror(ret));</span><br><span class="line">			return ERROR_JTAG_INIT_FAILED;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		host_interfaces &#x3D; JAYLINK_HIF_USB;</span><br><span class="line"></span><br><span class="line">		if (use_serial_number)</span><br><span class="line">			host_interfaces |&#x3D; JAYLINK_HIF_TCP;</span><br><span class="line"></span><br><span class="line">		ret &#x3D; jaylink_discovery_scan(_jayctx, host_interfaces);</span><br><span class="line"></span><br><span class="line">		if (ret !&#x3D; JAYLINK_OK) &#123;</span><br><span class="line">			LOG_ERROR(&quot;jaylink_discovery_scan() failed: %s.&quot;,</span><br><span class="line">				jaylink_strerror(ret));</span><br><span class="line">			jaylink_exit(_jayctx);</span><br><span class="line">			return ERROR_JTAG_INIT_FAILED;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ret &#x3D; jaylink_get_devices(_jayctx, &amp;devs, &amp;num_devices);</span><br><span class="line"></span><br><span class="line">		if (ret !&#x3D; JAYLINK_OK) &#123;</span><br><span class="line">			LOG_ERROR(&quot;jaylink_get_devices() failed: %s.&quot;, jaylink_strerror(ret));</span><br><span class="line">			jaylink_exit(_jayctx);</span><br><span class="line">			return ERROR_JTAG_INIT_FAILED;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for (i &#x3D; 0; devs[i]; i++) &#123;</span><br><span class="line">				ret &#x3D; jaylink_device_get_serial_number(devs[i], &amp;tmp);</span><br><span class="line"></span><br><span class="line">				if (ret &#x3D;&#x3D; JAYLINK_ERR_NOT_AVAILABLE) &#123;</span><br><span class="line">					continue;</span><br><span class="line">				&#125; else if (ret !&#x3D; JAYLINK_OK) &#123;</span><br><span class="line">					LOG_WARNING(&quot;jaylink_device_get_serial_number() failed: %s.&quot;,</span><br><span class="line">						jaylink_strerror(ret));</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				ret &#x3D; jaylink_device_get_usb_address(devs[i], &amp;address);</span><br><span class="line"></span><br><span class="line">				if (ret &#x3D;&#x3D; JAYLINK_ERR_NOT_SUPPORTED) &#123;</span><br><span class="line">					continue;</span><br><span class="line">				&#125; else if (ret !&#x3D; JAYLINK_OK) &#123;</span><br><span class="line">					LOG_WARNING(&quot;jaylink_device_get_usb_address() failed: %s.&quot;,</span><br><span class="line">						jaylink_strerror(ret));</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				command_print(CMD_CTX, &quot;Found device %d, SN: %08x, USB address: %d&quot;, i, tmp, address);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		jaylink_exit(_jayctx);</span><br><span class="line"></span><br><span class="line">		return ERROR_OK;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret &#x3D; jaylink_parse_serial_number(CMD_ARGV[0], &amp;serial_number);</span><br><span class="line"></span><br><span class="line">	if (ret &#x3D;&#x3D; JAYLINK_ERR) &#123;</span><br><span class="line">		command_print(CMD_CTX, &quot;Invalid serial number: %s.&quot;, CMD_ARGV[0]);</span><br><span class="line">		return ERROR_FAIL;</span><br><span class="line">	&#125; else if (ret !&#x3D; JAYLINK_OK) &#123;</span><br><span class="line">		command_print(CMD_CTX, &quot;jaylink_parse_serial_number() failed: %s.&quot;,</span><br><span class="line">			jaylink_strerror(ret));</span><br><span class="line">		return ERROR_FAIL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	use_serial_number &#x3D; true;</span><br><span class="line">	use_usb_address &#x3D; false;</span><br><span class="line"></span><br><span class="line">	return ERROR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Make-Raspberry-Pi-as-a-OpenOCD-debugger-🐂"><a href="#Make-Raspberry-Pi-as-a-OpenOCD-debugger-🐂" class="headerlink" title="Make Raspberry Pi as a OpenOCD debugger !!! 🐂"></a>Make Raspberry Pi as a OpenOCD debugger !!! 🐂</h2><p><a href="https://blog.csdn.net/wanshiyingg/article/details/52705913">https://blog.csdn.net/wanshiyingg/article/details/52705913</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_7cedb56d0102v141.html">http://blog.sina.com.cn/s/blog_7cedb56d0102v141.html</a></p>
<h2 id="OpenOCD-在-linux-上的权限问题"><a href="#OpenOCD-在-linux-上的权限问题" class="headerlink" title="OpenOCD 在 linux 上的权限问题"></a>OpenOCD 在 linux 上的权限问题</h2><p><a href="https://www.cnblogs.com/jxhd1/p/6528574.html">https://www.cnblogs.com/jxhd1/p/6528574.html</a></p>
<blockquote>
<h2 id="Permissions-delegation"><a href="#Permissions-delegation" class="headerlink" title="Permissions delegation"></a>Permissions delegation</h2><p>Running OpenOCD with root/administrative permissions is strongly<br>discouraged for security reasons.</p>
<p>For USB devices on GNU/Linux you should use the contrib/60-openocd.rules<br>file. It probably belongs somewhere in /etc/udev/rules.d, but<br>consult your operating system documentation to be sure. Do not forget<br>to add yourself to the “plugdev” group.</p>
<p>For parallel port adapters on GNU/Linux and FreeBSD please change your<br>“ppdev” (parport* or ppi*) device node permissions accordingly.</p>
<p>For parport adapters on Windows you need to run install_giveio.bat<br>(it’s also possible to use “ioperm” with Cygwin instead) to give<br>ordinary users permissions for accessing the “LPT” registers directly.</p>
</blockquote>
<h2 id="重定向-stdout-到-log-file"><a href="#重定向-stdout-到-log-file" class="headerlink" title="重定向 stdout 到 log file"></a>重定向 stdout 到 log file</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--log_output | -l redirect log output to file &lt;name&gt;</span><br><span class="line">log_output [filename]</span><br><span class="line">	Redirect logging to filename; the initial log output channel is stderr.</span><br></pre></td></tr></table></figure>

<p>openocd 提供 -l 来定向 log file，但是 openocd 的输出默认是 stderr，所以 stdout 是没有定向到 log file 内的。</p>
<p>所以还是用 &gt;&gt; 重定向符来把 stdout/err 都定向到 log file 内。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt; openocd.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<h2 id="hla"><a href="#hla" class="headerlink" title="hla"></a>hla</h2><p>hla 是什么？hla_swd 和 swd 有什么区别？</p>
<p>有些调试适配器（STLink, TI ICDI），不开放底层功能，只能使用高层的 API，OpenOCD 为这些适配器定义了一个专有的接口 -  High Level Adapters，缩写为 hla。OpenOCD 内这些调试器不能使用诸如 cortex_m 等底层指令。</p>
<p><a href="https://sourceforge.net/p/openocd/mailman/message/33133520/">https://sourceforge.net/p/openocd/mailman/message/33133520/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">On Fri, Nov 21, 2014 at 12:41:30PM -0800, Myles Watson wrote:</span><br><span class="line">&gt; I&#39;d like to disable the debugging mode as part of programming the chip.  In</span><br><span class="line">&gt; order to do that, the RESET register in the POWER module needs to be</span><br><span class="line">&gt; written, and then swdioclk and swdio need to be held low for a minimum of</span><br><span class="line">&gt; 100us.</span><br><span class="line">&gt; </span><br><span class="line">&gt; Since the nRF51822 has a shared swdio&#x2F;nreset line, the reset doesn&#39;t work</span><br><span class="line">&gt; if the chip is not returned to normal mode.</span><br><span class="line">&gt; </span><br><span class="line">&gt; Where should I add a &quot;hard-reset&quot; function which is specific to the</span><br><span class="line">&gt; nRF51822 and SWD?</span><br><span class="line"></span><br><span class="line">Hi Myles,</span><br><span class="line"></span><br><span class="line">Did you have any luck with this? I saw the post when you originally</span><br><span class="line">made it, but I didn&#39;t reply as I didn&#39;t really have any good ideas -</span><br><span class="line">as far as I know you can&#39;t directly control the SWDIO and SWCLK pins</span><br><span class="line">on the STLinkv2 adapter, as it&#39;s a &quot;high level adapter&quot; (hla) type and</span><br><span class="line">its protocol doesn&#39;t give you that low level of control. :(</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Angus</span><br></pre></td></tr></table></figure>

<h2 id="reset-halt"><a href="#reset-halt" class="headerlink" title="reset halt"></a>reset halt</h2><p>reset halt 的效果是是在复位并停在第一条指令，它是原理是什么呢？</p>
<p>arm core从reset state马上转为debug halt state的条件, spec中的说明是：</p>
<ol>
<li><pre><code> 寄存器DHCSR.C_DEBUGEN=1, 使能debug</code></pre>
</li>
<li><pre><code> 寄存器DEMCR.VC_CORERESET=1, 可以让触发local reset的时候停在执行第一条指令前</code></pre>
</li>
<li><pre><code> Trigger reset</code></pre>
</li>
</ol>
<p>注意，拉reset pin进行hw reset对于cm4来说是power-on reset类型, 而armv7m spec是不支持power-on reset halt debug的， power-on reset类型也会将arm debug module也reset了；</p>
<p>所以触发这种reset后， reset前下的halt request就失效了，无法在上电后要执行的第一条halt住，因此就会出现目前你们所遇到的halt timeout问题。</p>
<p>对于armv7m来说，区分两种等级的reset:power-on reset(total reset)和local reset(partial reset) （local reset还可以细分有SYSRSTREQ和VECTRESET）</p>
<p>openocd中触发hw reset也是走这个流程, 但是reset后，debug相关的寄存器(DHCSR, DEMCR)被复位了，</p>
<p>我在openocd中加入一些log抓取了reset前后相关寄存器的变化</p>
<p>Reset前: DHCSR.C_DEBUGEN=1,系统有使能debug；DEMCR.VC_CORERESET=1允许reset后马上进入halt debug状态(这两个值在local reset均不会变化，power-on reset会复位)</p>
<p>Reset后: DHCSR.C_RESET_ST=1，表明系统刚刚有触发了reest，DHCSR.C_DEBUGEN=0,系统没有使能debug；DEMCR.VC_CORERESET=0，这样离开系统后系统无法立即halt住，DHCSR.S_HALT=0，表示系统是处于running状态而不是halt状态。</p>
<p>debug相关寄存器发生了复位，所以是发生了power-on reset，这样我们就没有办法在拉reset pin后马上halt住。</p>
<h2 id="RAM-Code"><a href="#RAM-Code" class="headerlink" title="RAM Code"></a>RAM Code</h2><ol>
<li><p>RAM code 不需要加载 .text 和 .data 段，但是必须清零 .bss 段即可。</p>
</li>
<li><p>使用 load app.elf 命令把 .text 和 .data 段 load 进 RAM 内，并自动设置 PC 的值为 .ld 的 ENTRY 值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arm-none-eabi-gdb build&#x2F;mx1101.elf -ex &quot;target remote localhost:3333&quot; -ex &quot;monitor reset halt&quot; -ex &quot;load build&#x2F;mx1101.elf&quot; -ex &quot;b main&quot; -ex &quot;layout split&quot; -ex &quot;focus cmd&quot; --tui</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>OpenOCD</category>
      </categories>
  </entry>
  <entry>
    <title>OpenOCD 探测目标所运行 OS 的原理</title>
    <url>/2020/12/11/Complie%20&amp;%20Debug/OpenOCD/OpenOCD%20%E6%8E%A2%E6%B5%8B%E7%9B%AE%E6%A0%87%E6%89%80%E8%BF%90%E8%A1%8C%20OS%20%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>OpenOCD 支持 OS 调试，需要在目标配置中加上选项<code>-rtos auto</code>来使能此功能。</p>
<a id="more"></a>

<p>OpenOCD 文档中关于 OS 调试的说明如下：</p>
<blockquote>
<p>OpenOCD includes RTOS support, this will however need enabling as it defaults to disabled. It can be enabled by passing -rtos arg to the target. See [RTOS Type], page 63.<br>See Section “Debugging Programs with Multiple Threads” in GDB manual, for details about relevant GDB commands.<br>An example setup is below:<br>$_TARGETNAME configure -rtos auto<br>This will attempt to auto detect the RTOS within your application. Currently supported rtos’s include:<br>• eCos<br>• ThreadX<br>• FreeRTOS • linux<br>• ChibiOS<br>• embKernel • mqx<br>• uCOS-III<br>Note: Before an RTOS can be detected, it must export certain symbols; other- wise, it cannot be used by OpenOCD.</p>
</blockquote>
<p>OpenOCD 探测目标所运行 OS 的原理是，它查询目标所运行的程序中有无 OS 所含有的变量符号，例如 FreeRTOS 有如下符号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pxCurrentTCB, pxReadyTasksLists, xDelayedTaskList1, xDelayedTaskList2, pxDelayedTaskList, pxOverowDelayedTaskList, xPendingReadyList, uxCurrentNumberOfTasks, uxTopUsedPriority.</span><br></pre></td></tr></table></figure>

<p>如果这些符号都有，那就说明目标所运行的 OS 是 FreeRTOS。</p>
<p>但是 OpenOCD 是在硬件层的调试，它只是根据 gdb 的命令来读写内存和寄存器，如何能查询目标程序内的符号的呢？</p>
<p>下面是一个 OpenOCD 的启动日志，此时 gdb 还没有 attach 上来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Open On-Chip Debugger 0.9.0 (2016-10-26-15:30)</span><br><span class="line">Licensed under GNU GPL v2</span><br><span class="line">For bug reports, read</span><br><span class="line">	http:&#x2F;&#x2F;openocd.org&#x2F;doc&#x2F;doxygen&#x2F;bugs.html</span><br><span class="line">Info : JLink SWD mode enabled</span><br><span class="line">swd</span><br><span class="line">adapter speed: 10000 kHz</span><br><span class="line">adapter_nsrst_delay: 100</span><br><span class="line">adapter_nsrst_delay: 100</span><br><span class="line">none separate</span><br><span class="line">cortex_m reset_config sysresetreq</span><br><span class="line">jtag_init</span><br><span class="line">Info : J-Link V9 compiled Sep  1 2016 18:29:50</span><br><span class="line">Info : J-Link caps 0xb9ff7bbf</span><br><span class="line">Info : J-Link hw version 94000</span><br><span class="line">Info : J-Link hw type J-Link</span><br><span class="line">Info : J-Link max mem block 69920</span><br><span class="line">Info : J-Link configuration</span><br><span class="line">Info : USB-Address: 0x0</span><br><span class="line">Info : Kickstart power on JTAG-pin 19: 0xffffffff</span><br><span class="line">Info : Vref &#x3D; 3.312 TCK &#x3D; 0 TDI &#x3D; 0 TDO &#x3D; 0 TMS &#x3D; 1 SRST &#x3D; 1 TRST &#x3D; 0</span><br><span class="line">Info : J-Link JTAG Interface ready</span><br><span class="line">Info : clock speed 10000 kHz</span><br><span class="line">Info : SWD IDCODE 0x2ba01477</span><br><span class="line">Info : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints</span><br><span class="line">Info : accepting &#39;gdb&#39; connection on tcp&#x2F;3333</span><br><span class="line">target state: halted</span><br><span class="line">target halted due to debug-request, current mode: Thread </span><br><span class="line">xPSR: 0x01000000 pc: 0x08000034 msp: 0x2000dd1c</span><br></pre></td></tr></table></figure>

<p>可以看出，此时 OpenOCD 还探测不到目标所运行的 OS。</p>
<p>在 gdb attach 上以后，OpenOCD 日志如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Info : device id &#x3D; 0x10006431</span><br><span class="line">Info : flash size &#x3D; 512kbytes</span><br><span class="line">Info : Auto-detected RTOS: FreeRTOS</span><br></pre></td></tr></table></figure>

<p>可以看出，在 gdb attach 上以后，OpenOCD 才探测出目标所使用的 OS 是 FreeRTOS。</p>
<p>不难猜测，OpenOCD 应该是查询 gdb 所加载的 ELF 文件中的符号表来探测 OS 的。</p>
<p>那么 OpenOCD 如何能查询到 ELF 文件内的符号表呢？</p>
<p>原来 OpenOCD 可以向 gdb 发送查询符号命令 - <code>qSymbol:sym_name</code>，来查询 ELF 文件内的符号地址。</p>
<p>gdb 文档中关于此部分的说明如下：</p>
<blockquote>
<p>‘qSymbol:sym_name’<br>The target requests the value of symbol sym name (hex encoded). gdb may provide the value by using the ‘qSymbol:sym_value:sym_name’ message, described below.<br>‘qSymbol:sym_value:sym_name’<br>Set the value of sym name to sym value.<br>sym name (hex encoded) is the name of a symbol whose value the target has previously requested.<br>sym value (hex) is the value for symbol sym name. If gdb cannot supply a value for sym name, then this  eld will be empty.</p>
</blockquote>
<p>用 wireshark 抓取 gdb attach 时的 gdb 和 OpenOCD 的通信包，其中有一段即是查询符号的部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$qSymbol:5f74785f7468726561645f63757272656e745f707472</span><br><span class="line">$qSymbol::5f74785f7468726561645f63757272656e745f707472</span><br><span class="line">$qSymbol:757843757272656e744e756d6265724f665461736b73</span><br><span class="line">$qSymbol:20000b6c:757843757272656e744e756d6265724f665461736b73</span><br></pre></td></tr></table></figure>

<p>OpenOCD 首先发出 <code>qSymbol</code> 命令，数据是 <code>5f74785f7468726561645f63757272656e745f707472</code>，转化成 ASCII 码是 <code>_tx_thread_current_ptr</code>，这是 ThreadX 的 symbol，因为我们的目标运行的是 FreeRTOS，所以 gdb 回复的 sym_value 是空的，代表没有这个符号。</p>
<p>然后 OpenOCD 查询 <code>uxCurrentNumberOfTasks</code>，gdb 回复中的 sym_value 的值是 20000b6c，即 <code>uxCurrentNumberOfTasks</code> 的地址。</p>
]]></content>
      <categories>
        <category>OpenOCD</category>
      </categories>
  </entry>
  <entry>
    <title>编译 OpenOCD</title>
    <url>/2020/12/11/Complie%20&amp;%20Debug/OpenOCD/%E7%BC%96%E8%AF%91%20OpenOCD/</url>
    <content><![CDATA[<p>在各个平台下编译 OpenOCD 的方法。</p>
<a id="more"></a>

<h2 id="Download-and-compile-source-code"><a href="#Download-and-compile-source-code" class="headerlink" title="Download and compile source code"></a>Download and compile source code</h2><p><strong>Download：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git:&#x2F;&#x2F;repo.or.cz&#x2F;openocd.git</span><br></pre></td></tr></table></figure>

<p><strong>Compile：</strong></p>
<p><em>Reference README 和 README.OSX.</em></p>
<ol>
<li><p>Install Dependencies:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install libtool pkg-config autoconf automake texinfo libusb libusb-compat hidapi libftdi</span><br></pre></td></tr></table></figure>
</li>
<li><p>Compiling:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bootstrap (when building from the git repository)</span><br><span class="line">.&#x2F;configure [options]</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
</li>
<li><p>Find src/openocd</p>
</li>
</ol>
]]></content>
      <categories>
        <category>OpenOCD</category>
      </categories>
  </entry>
  <entry>
    <title>MQT 学习</title>
    <url>/2020/12/11/Network/MQTT/MQT%20%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>MQTT 学习笔记。</p>
<a id="more"></a>

<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><a href="https://zhuanlan.zhihu.com/p/20888181">MQTT入门篇</a></p>
<p><a href="https://www.jianshu.com/p/1553c1686337">MQTT example</a></p>
<p><a href="http://blog.csdn.net/github_33304260/article/details/73562071">MQTT服务器Mosquitto安装及使用</a></p>
<p><a href="https://github.com/mqtt/mqtt.github.io/wiki/libraries">libraries</a></p>
<p>[MQTT Essentials – A Lightweight IoT Protocol](../resources/MQTT Essentials – A Lightweight IoT Protocol.epub) — Good Book !!! 🐂</p>
<p>MQTT 是种基于<code>订阅-发布</code>机制的<code>异步</code>通信技术，核心是<code>解耦</code>。</p>
<p>解耦(Decouple)是 [MQTT Essentials – A Lightweight IoT Protocol](resources/MQTT Essentials – A Lightweight IoT Protocol.epub) 内反复多次提到的一个词 。</p>
<blockquote>
<h3 id="发布-订阅模式-Publish-subscribe-pattern"><a href="#发布-订阅模式-Publish-subscribe-pattern" class="headerlink" title="发布/订阅模式(Publish-subscribe pattern)"></a>发布/订阅模式(Publish-subscribe pattern)</h3><p>与请求/回答这种同步模式不同，发布/定义模式解耦了发布消息的客户（发布者）与订阅消息的客户（订阅者）之间的关系，这意味着发布者和订阅者之间并不需要直接建立联系。打个比方，你打电话给朋友，一直要等到朋友接电话了才能够开始交流，是一个典型的同步请求/回答的场景；而给一个好友邮件列表发电子邮件就不一样，你发好电子邮件该干嘛干嘛，好友们到有空了去查看邮件就是了，是一个典型的异步发布/订阅的场景。</p>
<p>熟悉编程的同学一定非常熟悉这种设计模式了，因为它带来了这些好处：</p>
<ul>
<li>发布者与订阅者不必了解彼此，只要认识同一个消息代理即可。</li>
<li>发布者和订阅者不需要交互，发布者无需等待订阅者确认而导致锁定。</li>
<li>发布者和订阅者不需要同时在线，可以自由选择时间来消费消息。</li>
</ul>
<h3 id="主题-Topic"><a href="#主题-Topic" class="headerlink" title="主题(Topic)"></a>主题(Topic)</h3><p>MQTT是通过主题对消息进行分类的，本质上就是一个UTF-8的字符串，不过可以通过反斜杠表示多个层级关系。主题并不需要创建，直接使用就是了。</p>
<p>主题还可以通过通配符进行过滤。其中，+可以过滤一个层级，而*只能出现在主题最后表示过滤任意级别的层级。举个例子：</p>
<ul>
<li>building-b/floor-5：代表B楼5层的设备。</li>
<li>+/floor-5：代表任何一个楼的5层的设备。</li>
<li>building-b/*：代表B楼所有的设备。</li>
</ul>
<p>注意，MQTT允许使用通配符订阅主题，但是并不允许使用通配符广播。</p>
</blockquote>
<h2 id="遗言机制-Last-will"><a href="#遗言机制-Last-will" class="headerlink" title="遗言机制(Last will)"></a>遗言机制(Last will)</h2><p>遗言机制可以让订阅者知道设备异常离线，最重要的是离线后要做什么操作，这也是遗言的现实意义。</p>
<p><a href="https://segmentfault.com/a/1190000007266638">https://segmentfault.com/a/1190000007266638</a></p>
<p><a href="https://stackoverflow.com/questions/17270863/mqtt-what-is-the-purpose-or-usage-of-last-will-testament/17385293#17385293">https://stackoverflow.com/questions/17270863/mqtt-what-is-the-purpose-or-usage-of-last-will-testament/17385293#17385293</a></p>
<blockquote>
<p>I’m surely missing something about how the whole MQTT protocol works, as I can’t grasp the usage pattern of <em>Last Will Testament</em> messages: what’s their purpose?<br>One example I often see is about informing that a device has gone offline. It doesn’t make very much sense to me, since it’s obvious that if a device isn’t publishing any data it may be offline or there could be some network problems.</p>
<p>So, what are some practical usages of the LWT? What was it invented for?</p>
<hr>
<p>LWT messages are not really concerned about detecting whether a client has gone offline or not (that task is handled by keepAlive messages). LWT messages are about <strong>what happens after the client has gone offline</strong>. </p>
<p>The analogy is that of a <em>real</em> last will: If a person dies, she can formulate a testament, in which she declares what actions should be taken after she has passed away. An executor will heed those wishes and execute them on her behalf. The analogy in the MQTT world is that a client can formulate a testament, in which it declares what message should be sent on it’s behalf by the broker, after it has gone offline.</p>
<p><strong>A fictitious example:</strong></p>
<p>I have a sensor, which sends crucial data, but very infrequently. It has formulated a last will statement in the form of [topic: ‘/node/gone-offline’, message: ‘:id’], with :id being a unique id for the sensor. I also have a <em>emergency-subscriber</em> for the topic ‘node/gone-offline’, which will send a SMS to my phone every time a message is published on that channel.</p>
<p>During normal operation, the sensor will keep the connection to the MQTT-broker open by sending periodic keepAlive messages interspersed with the actual sensor readings. If the sensor goes offline, the connection to the broker will time out, due to the lack of keepAlives. </p>
<p>This is where LWT comes in: If no LWT is specified, the broker doesn’t care and just closes the connection. In our case however, the broker will execute the sensor’s last will and publish the LWT-message ‘/node/gone-offline: :id’. The message will then be consumed to my <em>emergency-subscriber</em>and I will be notified of the sensor’s ID via SMS so that I can check up on what’s going on.</p>
<p><strong>In short:</strong></p>
<p>Instead of just closing the connection after a client has gone offline, LWT messages can be leveraged to define a message to be published by the broker on behalf of the client, since the client is offline and cannot publish anymore.</p>
<p>Furthermore, keepAlive messages are only sent and received by the broker and there’s the main difference with the Last Will: anyone can suscribe to this topic and be aware of the client going offline</p>
</blockquote>
<h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p>page 69</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Client            Server</span><br><span class="line">   |--- CONNECT ---&gt;|</span><br><span class="line">   |&lt;-- CONNACK ----|</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MQTT</category>
      </categories>
  </entry>
  <entry>
    <title>mosquitto</title>
    <url>/2020/12/11/Network/MQTT/mosquitto/</url>
    <content><![CDATA[<p>Mosquitto 是一个开源免费的 MQTT 代理服务。</p>
<a id="more"></a>

<h2 id="Mosquitto"><a href="#Mosquitto" class="headerlink" title="Mosquitto"></a>Mosquitto</h2><p>安装 mosquitto:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install mosquitto</span><br></pre></td></tr></table></figure>

<p>启动 MQTT broker 服务:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew services start mosquitto</span><br></pre></td></tr></table></figure>

<p>Or</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;sbin&#x2F;mosquitto -c &#x2F;usr&#x2F;local&#x2F;etc&#x2F;mosquitto&#x2F;mosquitto.conf</span><br></pre></td></tr></table></figure>

<p>停止 MQTT broker 服务:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew services mosquitto stop</span><br></pre></td></tr></table></figure>

<h2 id="Mosquitto-with-TLS"><a href="#Mosquitto-with-TLS" class="headerlink" title="Mosquitto with TLS"></a>Mosquitto with TLS</h2><h3 id="tlsv1-alert-internal-error"><a href="#tlsv1-alert-internal-error" class="headerlink" title="tlsv1 alert internal error"></a>tlsv1 alert internal error</h3><p>按 “MQTT Essentials – A Lightweight IoT Protocol” 书中 “Configuring TLS transport security in Mosquitto” 章节所述的 Client subscribe 命令会报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mosquitto_sub -V mqttv311 -p 8883 --cafile &#x2F;usr&#x2F;local&#x2F;etc&#x2F;mosquitto&#x2F;certificates&#x2F;ca.crt -t sensors&#x2F;drone01&#x2F;altitude -d</span><br><span class="line">Client mosqsub|1181-yangshiwei sending CONNECT</span><br><span class="line">Error: A TLS error occurred.</span><br></pre></td></tr></table></figure>

<p>Broker 端错误日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1517841349: OpenSSL Error: error:14094438:SSL routines:ssl3_read_bytes:tlsv1 alert internal error</span><br><span class="line">1517841349: OpenSSL Error: error:140940E5:SSL routines:ssl3_read_bytes:ssl handshake failure</span><br><span class="line">1517841349: Socket error on client &lt;unknown&gt;, disconnecting.</span><br></pre></td></tr></table></figure>

<p>Wireshark 抓包数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5	::1	::1	TLSv1.2	 383 Client Hello</span><br><span class="line">7	::1	::1	TLSv1.2	2439 Server Hello, Certificate, Server Key Exchange, Server Hello Done</span><br><span class="line">9	::1	::1	TLSv1.2	  83 Alert (Level: Fatal, Description: Internal Error)</span><br></pre></td></tr></table></figure>

<pre><code>Transmission Control Protocol, Src Port: 49355, Dst Port: 8883, Seq: 308, Ack: 2364, Len: 7
Secure Sockets Layer
    TLSv1.2 Record Layer: Alert (Level: Fatal, Description: Internal Error)
        Content Type: Alert (21)
        Version: TLS 1.2 (0x0303)
        Length: 2
        Alert Message
            Level: Fatal (2)
            Description: Internal Error (80)</code></pre>
<p>无论是错误日志还是抓包数据都看不出来具体原因，只能知道是 Client 发生了内部错误，主动断开了连接。</p>
<p>最终在 google 上找到了答案：</p>
<p>原来是因为我的 CA root certificate 是自签名的，mosquiito 认为有安全风险，所以主动断开了连接。</p>
<p><a href="https://mcuoneclipse.com/2017/04/23/tuturial-mbedtls-sll-certificate-verification-with-mosquitto-lwip-and-mqtt/">Tuturial: mbedTLS SSL Certificate Verification with Mosquitto, lwip and MQTT</a></p>
<blockquote>
<h3 id="Mosquitto-Client-and-Server-Certificate-Usage"><a href="#Mosquitto-Client-and-Server-Certificate-Usage" class="headerlink" title="Mosquitto Client and Server Certificate Usage"></a>Mosquitto Client and Server Certificate Usage</h3><p>I’m running the broker with the following server certificate setting:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">certfile C:\Program Files (x86)\mosquitto\certs\m2mqtt_srv.crt</span><br></pre></td></tr></table></figure>

<p>Using the mosquitto client to subscribe, I can subscribe to a topic with the following command line, using that same certificate:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mosquitto_sub -c -i MyMQTTclient -h localhost -p 8883 -q 0 -t HSLU&#x2F;test -v --cafile c:\tmp\tls_ssl\client\m2mqtt_srv.crt --insecure</span><br></pre></td></tr></table></figure>

<p>Notice that I have to specify the option <strong>–insecure</strong>. Without the –insecure it will give an error message like this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1492934878: OpenSSL Error: error:14094438:SSL routines:ssl3_read_bytes:tlsv1 alert internal error</span><br><span class="line">1492934878: OpenSSL Error: error:140940E5:SSL routines:ssl3_read_bytes:ssl handshake failure</span><br><span class="line">1492934878: Socket error on client &lt;unknown&gt;, disconnecting.</span><br></pre></td></tr></table></figure>

<p>It took me while to find out why it is failing. A good way to test the TLS handshaking and connection is to use</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl s_client -connect localhost:8883</span><br></pre></td></tr></table></figure>

<p>which gives me the reason in the last line of the output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----END CERTIFICATE-----</span><br><span class="line">subject&#x3D;&#x2F;C&#x3D;CH&#x2F;ST&#x3D;Switzerland&#x2F;L&#x3D;Lucerne&#x2F;O&#x3D;HSLU&#x2F;OU&#x3D;T&amp;A&#x2F;CN&#x3D;ErichStyger-PC&#x2F;emailAddress&#x3D;mail@hslu.ch</span><br><span class="line">issuer&#x3D;&#x2F;C&#x3D;CH&#x2F;ST&#x3D;Switzerland&#x2F;L&#x3D;Lucerne&#x2F;O&#x3D;HSLU&#x2F;OU&#x3D;T&amp;A&#x2F;CN&#x3D;ErichStyger-PC&#x2F;emailAddress&#x3D;mail@hslu.ch</span><br><span class="line">---</span><br><span class="line">No client certificate CA names sent</span><br><span class="line">Peer signing digest: SHA512</span><br><span class="line">Server Temp Key: ECDH, P-256, 256 bits</span><br><span class="line">---</span><br><span class="line">SSL handshake has read 1605 bytes and written 434 bytes</span><br><span class="line">---</span><br><span class="line">New, TLSv1&#x2F;SSLv3, Cipher is ECDHE-RSA-AES256-GCM-SHA384</span><br><span class="line">Server public key is 2048 bit</span><br><span class="line">Secure Renegotiation IS supported</span><br><span class="line">Compression: NONE</span><br><span class="line">Expansion: NONE</span><br><span class="line">No ALPN negotiated</span><br><span class="line">SSL-Session:</span><br><span class="line">    Protocol  : TLSv1.2</span><br><span class="line">    Cipher    : ECDHE-RSA-AES256-GCM-SHA384</span><br><span class="line">    Session-ID: D241F3BFA8D26BDEE381353E2C517E46F8D04B48F307467A0E46FD7A2F3EB6BB</span><br><span class="line">    Session-ID-ctx:</span><br><span class="line">    Master-Key: &lt;cut&gt;</span><br><span class="line">    Key-Arg   : None</span><br><span class="line">    PSK identity: None</span><br><span class="line">    PSK identity hint: None</span><br><span class="line">    SRP username: None</span><br><span class="line">    TLS session ticket lifetime hint: 7200 (seconds)</span><br><span class="line">    TLS session ticket:</span><br><span class="line">    0000 - a0 fa a5 f5 8d 54 78 1a-7c 4e 86 51 4c 24 45 30   .....Tx.|N.QL$E0</span><br><span class="line">    0010 - 97 44 de c1 fb c7 06 96-46 ed ef 27 67 c2 91 6f   .D......F..&#39;g..o</span><br><span class="line">    0020 - 40 38 ef 86 2a 12 59 cb-f0 60 0d 34 e6 be 2a ef   @8..*.Y..&#96;.4..*.</span><br><span class="line">    0030 - e5 7c c8 ee c3 ac cb 25-ef 63 49 3c 27 2e b0 3c   .|.....%.cI&lt;&#39;..&lt;</span><br><span class="line">    0040 - e3 a6 88 53 08 20 4b 53-2f 2b 6e 44 20 1a e7 24   ...S. KS&#x2F;+nD ..$</span><br><span class="line">    0050 - 60 a3 1a b0 08 74 74 56-46 13 22 0a 76 df 32 53   &#96;....ttVF.&quot;.v.2S</span><br><span class="line">    0060 - d7 b1 6b 82 63 34 fc c8-9c 2c a6 16 a2 73 75 9d   ..k.c4...,...su.</span><br><span class="line">    0070 - 33 03 dc c7 db e0 c7 89-d0 49 ac fd 7d d3 33 0e   3........I..&#125;.3.</span><br><span class="line">    0080 - 35 eb df fc 05 b3 d0 bb-b7 02 25 67 86 71 76 f4   5.........%g.qv.</span><br><span class="line">    0090 - 56 59 3b 39 2a dc 04 0e-e1 60 ae e4 17 1c 8f 62   VY;9*....&#96;.....b</span><br><span class="line">    00a0 - b9 bf f1 99 5e c5 15 3c-ae 60 60 cb 8e 63 1a af   ....^..&lt;.&#96;&#96;..c..</span><br><span class="line"></span><br><span class="line">    Start Time: 1492935504</span><br><span class="line">    Timeout   : 300 (sec)</span><br><span class="line">    Verify return code: 18 (self signed certificate)</span><br><span class="line">---</span><br><span class="line">closed</span><br></pre></td></tr></table></figure>

<p>Ah, that makes sense: I have used a self-signed certificate :-). Now I know why I have to use the option <strong>–insecure</strong> with mosquitto_sub. I guess I could get rid of this with an non-self-signed certificate, but that’s too much of an effort for me now, as I’m only testing the connection.</p>
</blockquote>
<h4 id="mcuoneclipse-com"><a href="#mcuoneclipse-com" class="headerlink" title="mcuoneclipse.com"></a>mcuoneclipse.com</h4><p><a href="https://mcuoneclipse.com/">https://mcuoneclipse.com</a> 是个非常好的 MCU 开发网站。</p>
<p>关于 MQTT 还有一系列文章：</p>
<p><a href="https://mcuoneclipse.com/2017/04/17/tutorial-secure-tls-communication-with-mqtt-using-mbedtls-on-top-of-lwip/">Tutorial: Secure TLS Communication with MQTT using mbedTLS on top of lwip</a></p>
<p><a href="https://mcuoneclipse.com/2017/04/14/enable-secure-communication-with-tls-and-the-mosquitto-broker/">Enable Secure Communication with TLS and the Mosquitto Broker</a></p>
<h4 id="self-signed-certificate"><a href="#self-signed-certificate" class="headerlink" title="self-signed certificate"></a>self-signed certificate</h4><p><a href="https://en.wikipedia.org/wiki/Self-signed_certificate">Self-signed certificate</a></p>
<blockquote>
<p>In technical terms a self-signed certificate is one signed with its own <a href="https://en.wikipedia.org/wiki/Public-key_cryptography">private key</a>.</p>
</blockquote>
<h4 id="root-certificate"><a href="#root-certificate" class="headerlink" title="root certificate"></a>root certificate</h4><p><a href="https://zh.wikipedia.org/wiki/%E6%A0%B9%E8%AF%81%E4%B9%A6">wikipeida</a></p>
<blockquote>
<p>根证书没有上层机构再为其本身作数字签名，所以都是<a href="https://zh.wikipedia.org/w/index.php?title=%E8%87%AA%E7%B0%BD%E8%AD%89%E6%9B%B8&action=edit&redlink=1">自签证书</a>。许多<a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6">应用软件</a>（例如<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>、<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8">网页浏览器</a>）会预先安装可被信任的根证书，这代表用户授权了应用软件代为审核哪些根证书机构属于可靠，例如是公认可靠的政府机关（如<a href="https://zh.wikipedia.org/wiki/%E9%A6%99%E6%B8%AF%E9%83%B5%E6%94%BF">香港邮政</a>[<a href="https://zh.wikipedia.org/wiki/%E6%A0%B9%E8%AF%81%E4%B9%A6#cite_note-2">2]</a>）、专职机构（如<a href="https://zh.wikipedia.org/wiki/Google">Google</a>[<a href="https://zh.wikipedia.org/wiki/%E6%A0%B9%E8%AF%81%E4%B9%A6#cite_note-3">3]</a>、<a href="https://zh.wikipedia.org/wiki/Let%27s_Encrypt">Let’s Encrypt</a>、<a href="https://zh.wikipedia.org/wiki/CAcert">CAcert.org</a>、<a href="https://zh.wikipedia.org/wiki/%E7%A7%91%E6%91%A9%E5%A4%9A%E9%9B%86%E5%9B%A2">Comodo</a>、<a href="https://zh.wikipedia.org/wiki/DigiCert">DigiCert</a>、<a href="https://zh.wikipedia.org/wiki/GlobalSign">GlobalSign</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A8%81%E7%91%9E%E4%BF%A1">Verisign</a>）等。</p>
</blockquote>
]]></content>
      <categories>
        <category>MQTT</category>
      </categories>
  </entry>
  <entry>
    <title>PPP</title>
    <url>/2020/12/11/Network/TCPIP/PPP/</url>
    <content><![CDATA[<p><code>Point-to-Point Protocol</code>，是<code>点对点</code>的<code>数据链路层</code>协议。</p>
<a id="more"></a>

<h2 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a>PPP</h2><h3 id="PPP-是神马？"><a href="#PPP-是神马？" class="headerlink" title="PPP 是神马？"></a>PPP 是神马？</h3><p><code>Point-to-Point Protocol</code>，是<code>点对点</code>的<code>数据链路层</code>协议。</p>
<p>组成如下：</p>
<ul>
<li>封装成帧。如帧定界符，CRC 校验。</li>
<li>链路建立，配置和监控协议（Link Control Protocol) LCP。如拨号验证，监控链路是否正常。</li>
<li>网络控制协议（Network Control Protocol) NCP。如协商来知晓或者配置网络层地址（如 IP 地址）。</li>
</ul>
<h3 id="PPP-文档在哪里？"><a href="#PPP-文档在哪里？" class="headerlink" title="PPP 文档在哪里？"></a>PPP 文档在哪里？</h3><p>入门在<a href="https://en.wikipedia.org/wiki/Point-to-Point_Protocol">WiKi</a>，详解在 RFC (其实也是 WiKi 跳过去的)。</p>
<ul>
<li><a href="https://tools.ietf.org/html/rfc1662">PPP 帧格式</a></li>
<li><a href="https://tools.ietf.org/html/rfc1661">PPP 和 LCP</a></li>
<li><a href="https://tools.ietf.org/html/rfc1332#page-2">NCP 和 IPCP</a></li>
<li><a href="https://tools.ietf.org/html/rfc1340#page-65">Protocol and Configure Field Number Assignments</a></li>
<li><a href="https://tools.ietf.org/html/rfc1661#page-6">PPP 流程</a></li>
</ul>
<h3 id="PPP-的层次"><a href="#PPP-的层次" class="headerlink" title="PPP 的层次"></a>PPP 的层次</h3><table>
<thead>
<tr>
<th align="left">Layer Name</th>
<th align="left">Example</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Network Layer</td>
<td align="left">IP, IPX</td>
</tr>
<tr>
<td align="left">Abstract Link Data Layer</td>
<td align="left">PPPoE, PPPoS</td>
</tr>
<tr>
<td align="left">Physical Link Data Layer</td>
<td align="left">Ethernet, Serial</td>
</tr>
<tr>
<td align="left">Physical Layer</td>
<td align="left">Coaxial cable, RS232</td>
</tr>
</tbody></table>
<p>PPP 是位于数据链路层和网络层之间的一个抽象的链路层，它可以让上层协议无需修改就可以在多种数据链路层上运行，比如通过 PPPoE 和 PPPoS，同一套TCP/IP 协议栈可以在各种厂家的以太网/串行接口网卡上运行（类比 Java 虚拟机）。</p>
<h3 id="PPP-的应用场合"><a href="#PPP-的应用场合" class="headerlink" title="PPP 的应用场合"></a>PPP 的应用场合</h3><p>无论是帧格式还是功能， PPP 看起来和以太网等链路协议都很相似，那么为什么不直接使用以太网，还要用 PPPoE(以太网上的 PPP) 呢，或者说 PPP 的应用场合是什么呢？</p>
<p>除了上节所述 PPP 向网络层提供了统一的抽象链路层功能外，PPP 还解决两个需求：</p>
<ul>
<li>用户鉴权<br>拨号上网方式需要认证用户的身份（如账号和密码），显然以太网协议中没有这个功能。</li>
<li>网络协商<br>局域网中新入网设备通过 DHCP 协议来获取 IP 地址，但显然拨号上网没有这个功能。</li>
</ul>
<p>PPP 提供了用户鉴权和网络协商，其实是个 2.5 层的协议。</p>
<h3 id="PPP-工作的三个阶段"><a href="#PPP-工作的三个阶段" class="headerlink" title="PPP 工作的三个阶段"></a>PPP 工作的三个阶段</h3><ul>
<li>配置协商阶段</li>
<li>用户鉴权阶段</li>
<li>网络协商阶段</li>
</ul>
<p><em>参考 &lt;计算机网络教程（第4版）&gt; - 3.2 点对点协议 PPP</em></p>
<h3 id="PPP-帧格式"><a href="#PPP-帧格式" class="headerlink" title="PPP 帧格式"></a>PPP 帧格式</h3><h3 id="PPP-转义"><a href="#PPP-转义" class="headerlink" title="PPP 转义"></a>PPP 转义</h3><h3 id="ACCM"><a href="#ACCM" class="headerlink" title="ACCM"></a>ACCM</h3><p>为什么 LCP 中控制字符会转义，而 NCP 中不被转义？<br>因为默认的 ACCM 是 0xFFFFFFFF，代表着所有的控制字符都要转义，所以 LCP 阶段的控制字符要转义，在 LCP 协商后，ACCM 协商为 0x00000000，代表着所遇的控制字符都不转义，所以在 LCP 阶段后就不被转义了。</p>
<h3 id="PPP-流程"><a href="#PPP-流程" class="headerlink" title="PPP 流程"></a>PPP 流程</h3><h2 id="PPPoS"><a href="#PPPoS" class="headerlink" title="PPPoS"></a>PPPoS</h2><p>PPP on Serial，即运行于串行接口上的 PPP 协议。例如 PC 通过 PPPoS 协议连接 GRPS 网卡实现上网。</p>
<h3 id="AT-指令和-PPP-的关系"><a href="#AT-指令和-PPP-的关系" class="headerlink" title="AT 指令和 PPP 的关系"></a>AT 指令和 PPP 的关系</h3><p>AT 指令和 PPP <code>没有半毛钱关系</code>。</p>
<p>PPP 是<code>数据链路层协议</code>；而 AT 指令是<code>终端指令集</code>，比如开关机，休眠，复位等。它们之间的区别就好像是 TCP/IP 和 Shell 命令之间的区别。</p>
<p>在实际应用中，主机要先通过 AT 指令来初始化和配置网卡，然后切换到数据模式来发起PPP协商，获取IP地址和鉴权，然后就可以上网了。</p>
<p>参考：<a href="https://www.cnblogs.com/emlslxl/p/6101181.html">关于PPP拨号 和 AT指令实现GPRS模块联网的疑问</a></p>
<h3 id="GPRS-模块-AT-模式和数据模式的切换"><a href="#GPRS-模块-AT-模式和数据模式的切换" class="headerlink" title="GPRS 模块 AT 模式和数据模式的切换"></a>GPRS 模块 AT 模式和数据模式的切换</h3><p>不同厂家的 GPRS 模块的初始化和配置流程是不同的，但一般都是在 ATD call 指令成功后自动切换到数据模式。</p>
<p>比如 MC35 的 ATD call 指令格式为ATDT<em>99**</em>1#rn，若在该指令执行之后给定的时间内返回CONNECT信息，则表明与服务提供商的连接建立成功；否则，表明拨号失败，无线传输功能无法正常启动。MC35成功登录移动梦网网关之后，将自动从命令模式切换到数据通信模式。</p>
<p>参考：<br><a href="http://www.eeworld.com.cn/mcu/2014/1114/article_17155.html">基于S3C2410的三导联远程心电监护</a><br><a href="http://bbs.csdn.net/topics/210057079/">ATD<em>99**</em>1这条AT命令是做什么用的</a></p>
<blockquote>
<p>对于会话管理层消息流程来说，PDP上下文激活和ATD＊99＃是完全一样地效果。<br>但是ATD＊99＃除了激活PDP上下文，MODEM内部一些状态也会发生改变，不会再保持AT命令状态，转而进入分组数据收发模式，这样才可以进行PPP协商。</p>
</blockquote>
<h3 id="GPRS-常见初始化指令"><a href="#GPRS-常见初始化指令" class="headerlink" title="GPRS 常见初始化指令"></a>GPRS 常见初始化指令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: GSM register</span><br><span class="line">op1&#x3D;&gt;operation: GPRS attach</span><br><span class="line">e&#x3D;&gt;end: PDP active</span><br><span class="line">st-&gt;op1-&gt;e</span><br></pre></td></tr></table></figure>

<p><a href="http://blog.sina.com.cn/s/blog_893e7cc101014hze.html">AT命令控制上网</a></p>
<h3 id="PPPoS-是运行在-MCU-和-GPRS-modem-之间的协议。"><a href="#PPPoS-是运行在-MCU-和-GPRS-modem-之间的协议。" class="headerlink" title="PPPoS 是运行在 MCU 和 GPRS modem 之间的协议。"></a>PPPoS 是运行在 MCU 和 GPRS modem 之间的协议。</h3><p>最初接触 PPPoS 时我以为 GPRS modem 仅仅是个透明传输，用户终端和 ISP 之间通过 PPP 协议来通信，其实并非这样，PPP 协议只存在于用户终端和 GPRS modem 之间，GPRS modem 和 ISP 之间使用的是 GPRS 内部协议来通信。也即 GPRS modem 内运行着一套 PPP stack，实现了 PPP 协议的各种功能（部分需要通过 GPRS 协议来实现）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[MCU]--&gt;| PPP |B[GRPS modem]</span><br><span class="line">B--&gt;|GPRS|C[ISP]</span><br></pre></td></tr></table></figure>

<p>比如 PPP 的 IPCP 用以获取 IP 地址，实际流程是这样的： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">MCU-&gt;&gt;GPRS modem: IPCP request (need IP)</span><br><span class="line">GPRS modem-&gt;&gt;ISP: PDP active</span><br><span class="line">ISP-&gt;&gt;GPRS modem: PDP context (contain IP)</span><br><span class="line">GPRS modem-&gt;&gt;MCU: IPCP ACK (contain IP)</span><br></pre></td></tr></table></figure>

<p>参考：<br><a href="http://www.xuebuyuan.com/924787.html">GPRS与PPP</a><br><a href="http://blog.chinaunix.net/uid-22477616-id-3511474.html">GPRS-PDP上下文的激活过程(外部协议栈)</a></p>
<h2 id="PPPoS-in-LwIP"><a href="#PPPoS-in-LwIP" class="headerlink" title="PPPoS in LwIP"></a>PPPoS in LwIP</h2><p><strong>以下内容均来自：<a href="resources/LwIP/doc/ppp.txt">doc/ppp.txt</a>，这是个牛逼且详细的关于在 LwIP 上使用 PPP 的文档，必须仔细读！</strong></p>
<p>在 LwIP 中使用（移植） PPPoS 只需要两步操作：</p>
<ol>
<li>开启 PPP 功能</li>
<li>配置 PPPoS</li>
</ol>
<h4 id="Enable-PPP"><a href="#Enable-PPP" class="headerlink" title="Enable PPP"></a>Enable PPP</h4><p>在用户定义的 lwipopts.h 内开启 PPP 的编译即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define PPP_SUPPORT 1</span><br></pre></td></tr></table></figure>

<p>因为 GPRS modem 还需要 PAP 鉴权，所以还要开启 PPP 的 PAP 部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define PAP_SUPPORT 1</span><br></pre></td></tr></table></figure>
<p>就酱</p>
<h4 id="Setup-PPPoS"><a href="#Setup-PPPoS" class="headerlink" title="Setup PPPoS"></a>Setup PPPoS</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A&#x3D;&gt;operation: Initialize GPRS modem.</span><br><span class="line">B&#x3D;&gt;operation: Create a new PPP connection(include interface).</span><br><span class="line">C&#x3D;&gt;operation: Set the PPP interface as the default network interface.</span><br><span class="line">D&#x3D;&gt;operation: Set PPP Authentication type, User name and Password.</span><br><span class="line">E&#x3D;&gt;operation: Initiate the PPP connection.</span><br><span class="line">F&#x3D;&gt;operation: Receive data from GPRS modem through UART.</span><br><span class="line">G&#x3D;&gt;operation: Pass received raw characters to PPPoS to be decoded through lwIP TCPIP thread.</span><br><span class="line">A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G-&gt;F</span><br></pre></td></tr></table></figure>
<ol>
<li>实现一个 UART 发送函数以供 PPP 协议栈内使用来发送 PPP 帧。比如:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static uint32_t ppp_output_callback(ppp_pcb *pcb, u8_t *data, uint32_t len, void *ctx)</span><br><span class="line">&#123;</span><br><span class="line">    return uart_write_bytes(data, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>实现一个事件回调函数以供 PPP 协议栈内使用来通知应用层各种事件。比如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void ppp_status_cb(ppp_pcb *pcb, int err_code, void *ctx)</span><br><span class="line">&#123;</span><br><span class="line">    switch (err_code) </span><br><span class="line">    &#123;</span><br><span class="line">    case PPPERR_NONE:</span><br><span class="line">    case PPPERR_PARAM:</span><br><span class="line">    case PPPERR_OPEN:</span><br><span class="line">    case PPPERR_DEVICE:</span><br><span class="line">    case PPPERR_ALLOC:</span><br><span class="line">    case PPPERR_USER:</span><br><span class="line">    case PPPERR_CONNECT:</span><br><span class="line">    case PPPERR_AUTHFAIL:</span><br><span class="line">    case PPPERR_PROTOCOL:</span><br><span class="line">    case PPPERR_PEERDEAD:</span><br><span class="line">    case PPPERR_IDLETIMEOUT:</span><br><span class="line">    case PPPERR_CONNECTTIME:</span><br><span class="line">    case PPPERR_LOOPBACK:</span><br><span class="line">    default:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建一个 PPP 连接。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* The PPP control block *&#x2F;</span><br><span class="line">ppp_pcb *ppp;</span><br><span class="line">&#x2F;* The PPP IP interface *&#x2F;</span><br><span class="line">struct netif ppp_netif;</span><br><span class="line"></span><br><span class="line">ppp &#x3D; pppapi_pppos_create(&amp;ppp_netif, ppp_output_callback, ppp_status_cb, NULL);</span><br></pre></td></tr></table></figure></li>
<li>设置为默认的网卡：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pppapi_set_default(ppp);</span><br></pre></td></tr></table></figure></li>
<li>配置鉴权方式，用户名和密码(中国移动不需要，所以为空)：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pppapi_set_auth(ppp, PPPAUTHTYPE_PAP, NULL, NULL);</span><br></pre></td></tr></table></figure></li>
<li>开始 PPP 连接：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pppapi_connect(ppp, 0);</span><br></pre></td></tr></table></figure></li>
<li>循环接收串口数据并交付给协议栈处理：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int len</span><br><span class="line">uint8_t data[1024];</span><br><span class="line"></span><br><span class="line">for(;;) </span><br><span class="line">&#123;</span><br><span class="line">    len &#x3D; uart_read_bytes(data, 1024, 10);</span><br><span class="line">    if (len &gt; 0) </span><br><span class="line">    &#123;</span><br><span class="line">        pppos_input_tcpip(ppp, (u8_t *)data, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>指示 PPP 的各个阶段：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void ppp_notify_phase_cb(ppp_pcb *pcb, u8_t phase, void *ctx) &#123;</span><br><span class="line">  switch (phase) &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Session is down (either permanently or briefly) *&#x2F;</span><br><span class="line">  case PPP_PHASE_DEAD:</span><br><span class="line">    led_set(PPP_LED, LED_OFF);</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">  &#x2F;* We are between two sessions *&#x2F;</span><br><span class="line">  case PPP_PHASE_HOLDOFF:</span><br><span class="line">    led_set(PPP_LED, LED_SLOW_BLINK);</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Session just started *&#x2F;</span><br><span class="line">  case PPP_PHASE_INITIALIZE:</span><br><span class="line">    led_set(PPP_LED, LED_FAST_BLINK);</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Session is running *&#x2F;</span><br><span class="line">  case PPP_PHASE_RUNNING:</span><br><span class="line">    led_set(PPP_LED, LED_ON);</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">  default:</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>TCPIP</category>
      </categories>
  </entry>
  <entry>
    <title>TCP 协议抓包分析</title>
    <url>/2020/12/11/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>通过抓包分析和学习 TCP 协议。</p>
<a id="more"></a>

<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="延迟确认"><a href="#延迟确认" class="headerlink" title="延迟确认"></a>延迟确认</h3><p><code>192.168.3.6</code>向<code>192.168.3.10</code>发送了一个数据报，<code>192.168.3.10</code>并没有马上回复 ACK，而是选择先等待一段时间…</p>
<p><strong>捎带确认</strong></p>
<p><img src="/2020/12/11/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/%5Btcp%5D-piggybacking-client.png" alt="tcp-piggybacking-client"></p>
<p><img src="/2020/12/11/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/%5Btcp%5D-piggybacking-server.png" alt="piggybacking-server"></p>
<p>刚好在 20 ms 后有数据报要发送给对方，于是就捎带上了这个 ACK。</p>
<p><strong>累计确认</strong></p>
<p><img src="/2020/12/11/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/%5Btcp%5D-delayedack-2seg.png" alt="delayedack"></p>
<p>很快它又收到了一个数据报，于是就回复了一个 ACK 来确认两个数据报。</p>
<p><strong>超时之后</strong></p>
<p><img src="/2020/12/11/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/%5Btcp%5D-delayedack-timeout.png" alt="delayedack"></p>
<p>过了 300 ms 后，即没有待发的数据报，也没有收到新的数据报，于是就回复了一个 ACK。</p>
<p><strong>总结</strong><br>一个 ACK 没有携带用户数据，却要发送至少 40 个字节长度的数据包，是对网络流量的浪费。不管捎带确认还是累计确认，目的都是尽量减少网络中的小包数量。</p>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p><code>192.168.3.6</code>向<code>192.168.3.10</code>连续发送数据。</p>
<p><img src="/2020/12/11/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/fast_retransmit.png" alt="fast_retransmit"></p>
<p>其中序号<code>3241</code>的数据报丢失了，所以<code>192.168.3.10</code>对所有后续到来的数据报都立即回复<code>ACK=3241</code>，如<code>78``79</code>号包。TCP 协议规定在连续收到 3 个相同的 ACK 后要快速重传，此处只有 2 个相同的 ACK 所以<code>192.168.3.6</code>会继续发送数据报。</p>
<p>在第 3 个相同的 ACK 后（<code>82</code>号包），<code>192.168.3.6</code>开始快速重传序号<code>3241</code>的数据报（<code>87</code>号包）。</p>
<p><code>192.168.3.10</code>收到序号<code>3241</code>的数据报后，应该回复<code>ACK=3241+536=3777</code>，但是事实上回复的是<code>ACK=8065</code>（<code>88</code>号包），为什么呢？因为虽然序号<code>3241</code>的数据报丢失了，但是序号<code>3777</code>到<code>7529</code>的数据报被<code>192.168.3.10</code>收到并且缓存了起来。所以当收到重传的序号<code>3241</code>的数据报后，<code>192.168.3.10</code>回复的是<code>ACK=8065</code>。</p>
<p>再往下看<code>94``95</code>号包又是两个重复<code>ACK=8065</code>，这是为什么呢？<strong>因为快速重传只会重传丢失的那一个数据报，而不会把后面所有未确认的包全部重传。</strong><code>192.168.3.6</code>只重传了序号<code>3241</code>的包，然后接着从序号<code>11817</code>的数据报开始发送了，但是<code>192.168.3.10</code>的期待接收的下个数据报序号是<code>8065</code>，所以回复了重复的 ACK。</p>
<h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p><code>192.168.3.6</code>向<code>192.168.3.10</code>连续发送数据。</p>
<p><img src="/2020/12/11/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/retransmit_timeout.png" alt="retransmit_timeout"></p>
<p>在发送完序号<code>13229</code>的数据报后等了 300ms 没有收到 ACK（<code>192.168.3.10</code>异常掉线），于是<code>192.168.3.6</code>开始超时重传。</p>
<p>第一个重传间隔是<code>RTO</code>，后面的重传间隔都是前面的 2 倍，也就是说重传间隔是按 2 的指数方式增长（术语：backoff，退避算法），直到第 12 次重传仍然没有收到 ACK，于是<code>192.168.3.6</code>就认为<code>192.168.3.10</code>已经异常掉线，就向它发送了一个<code>RST</code>。</p>
<h3 id="零窗口探测"><a href="#零窗口探测" class="headerlink" title="零窗口探测"></a>零窗口探测</h3><p><code>192.168.3.6</code>向<code>192.168.3.10</code>连续发送数据。</p>
<p><img src="/2020/12/11/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/zero_window_probe.png" alt="zero_window_probe"></p>
<p>发送完序号<code>22</code>包后，<code>192.168.3.10</code>向<code>192.168.3.6</code>回复了一个零窗口 ACK，表示自己的不能再接收数据了。然后<code>192.168.3.6</code>就会发送<code>TCP ZeroWindowProbe</code>。</p>
<p>TCP 通过接收窗口来实现流量控制。发送方接到零窗口通告时，则会停止报文段的发送，直到接收方通告非零的窗口。非零窗口通告一般在一个不含任何数据的ACK报文中发送，但ACK的传输并不可靠（ACK报文段不会被确认和重传），假设一个非零窗口通告丢失了，接收方等待接收数据（因为它已通告了一个非零的窗口），而发送方在等待非零窗口更新，就会产生死锁。为了解决这个问题，发送方使用一个坚持定时器<code>persist timer</code>来周期性地向接收方窗口是否被非零，这样的报文段称为窗口探査报文<code>window probe</code>。 </p>
<p>在 LwIP 中，<strong>窗口探测报本质是个长度为 1，序号为待确认报文段（如果没有，则是待发送报文段）的第 1 个字节的 TCP 数据报</strong>，对方一定会返回一个 ACK。协议栈收到一个零窗口通告后就开始窗口探查，收到非零窗口通告后就停止窗口探查。窗口探测的间隔时间会递增，但达到一个值后就不再改变。</p>
<p>关于零窗口探测包的实现，<a href="https://www.rfc-editor.org/rfc/rfc793.txt">RFC 793-Section 3.7-Page 42</a>中描述如下：</p>
<blockquote>
<p>The sending TCP must be prepared to accept from the user and send at least one octet of new data even if the send window is zero.  The sending TCP must regularly retransmit to the receiving TCP even when the window is zero.  Two minutes is recommended for the retransmission interval when the window is zero.  This retransmission is essential to guarantee that when either TCP has a zero window the re-opening of the window will be reliably reported to the other.</p>
<p>When the receiving TCP has a zero window and a segment arrives it must still send an acknowledgment showing its next expected sequence number and current window (zero).</p>
</blockquote>
<p>也就是说 TCP 发送方的零窗口探测报至少要包含一个字节的数据。但是在一些系统的实现中并没有严格遵守这个规范，比如吊吊的 Linux 中实际上发送的是长度为 0，序号为对方期望接收的序号减 1 的 TCP ACK 包（和 keep alive 报一毛一样）。</p>
<p>关于 Linux 上零窗口探测报的实现，老外的提问和解答 (<a href="http://linux.derkeiler.com/Newsgroups/comp.os.linux.networking/2004-04/0184.html">原文链接</a>):</p>
<blockquote>
<h4 id="Re-TCP-zero-window-probing"><a href="#Re-TCP-zero-window-probing" class="headerlink" title="Re: TCP zero window probing"></a>Re: TCP zero window probing</h4><p>From: Tauno Voipio (tauno.voipio_at_iki.fi.NOSPAM.invalid)<br>Date: 04/05/04</p>
<p>Louis Laborde wrote: </p>
<blockquote>
<p>It seems that to probe a closed receive window,<br>linux TCP implementation sends an empty segment<br>with its sequence number set to SND.UNA-1.<br>I was wondering if this was compliant with RFC<br>793 which does not seem to describe precisely<br>what such a probe should contain. </p>
<p>Thanks,<br>Louis. </p>
</blockquote>
<p>It is sensed as an extra retransmit/ACK for a byte<br>lready transferred. The peer should respond to<br>t with the current sequence &amp; acknowledgement<br>alues - which also carries the current window<br>nformation. </p>
<p>This is, IMHO, easier to handle than the pure<br>FC version of sending one byte over the window<br>size.</p>
<p>Tauno Voipio<br>tauno voipio @ iki fi </p>
</blockquote>
<p>还有一个(<a href="http://www.linuxsa.org.au/pipermail/linuxsa/2004-April/068243.html">原文链接</a>)，这个没有解答，但是抓包可供参考:</p>
<blockquote>
<p>Hi,</p>
<p>I am running a  client-server  program with client  running on a linux machine with 2.4.18-14 kernel installed.</p>
<p>When the server  announces  zero-window  to the  client,  client starts  sending   zero-window   probes  which  are  nothing  but unacceptable segments.</p>
<p>A short trace  obtained  using  tcpdump  and  interpreted  using ethereal is shown below:</p>
<blockquote>
<p>16:27:17.979349 e.f.g.h.33464 &gt; a.b.c.d.40000: P Seq=76441951 Ack=802335667 Win 5840 len=1080<br>27:18.040407 a.b.c.d.40000 &gt; e.f.g.h.33464: . Seq=802335667 Ack=764413031 Win 0 len=0<br>27:18.256213 e.f.g.h.33464 &gt; a.b.c.d.40000: . Seq=76443030 Ack=802335667 Win 5840 len=0</p>
</blockquote>
<p>This sequence continues as per retransmission algorithm.</p>
<p>It can be seen above that unacceptable  zero-length packets with a  sequence  no.  already   unacknowledged   is  being  used  as zero-window probes.</p>
<p>Zero  window  probes are defined in RFC 793 and  RFC1122 to be a data  segment  containing  atleast  one byte of data  beyond the window of the receiver who has closed the window.</p>
<p>This  seems  to be a bug.  Has it been  already  fixed in  later kernel versions or is this how it is intended to remain?</p>
<p>Regards,</p>
<p>Praveen</p>
</blockquote>
<p>从 Linux 的观点来看，不管使用什么方法，只要能让对方返回 ACK 就行了。</p>
<p>规范也是人定出来的，并不是真理，要不然也不会有那么多的修订版了，所以不要一昧迷信书本，须知尽信书不如无书，黑猫白猫抓到老鼠就是好猫。</p>
<h3 id="保活机制"><a href="#保活机制" class="headerlink" title="保活机制"></a>保活机制</h3><p>客户端<code>192.168.3.6</code>连接服务器<code>192.168.3.10</code>。</p>
<p><img src="/2020/12/11/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/keep_alive.png" alt="keep_alive"></p>
<p>客户端发送序号<code>14</code>的数据报后，过了很久（一般是 2 个小时）也没有新的数据发送，服务器为了确认客户端是否仍然正常运行，开始周期性（一般是 75 秒）的发送<code>Keep-Alive</code>探测包，当发送了 N 次（一般为 9 次）探测包客户端仍然没有相应时，就认为客户端已经异常掉线了，发送一个 RST 包。</p>
<p>在 LwIP 中，<strong>保活探查报本质上是长度为 0，序号为对方期望接收的序号减 1 的 TCP ACK 包</strong>，对方认为这是个失序的 TCP 报，就一定会返回一个 ACK。协议栈中 Keep alive 默认是关闭的，打开和配置代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int optval;</span><br><span class="line"></span><br><span class="line">&#x2F;* Enable keep alive *&#x2F;</span><br><span class="line">optval &#x3D; 1;</span><br><span class="line">setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, sizeof(optval));</span><br><span class="line"></span><br><span class="line">&#x2F;* Idle time before first KEEPALIVE probe is sent *&#x2F;</span><br><span class="line">optval &#x3D; 10;</span><br><span class="line">setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;optval, sizeof(optval));</span><br><span class="line"></span><br><span class="line">&#x2F;* Interval between probes *&#x2F;</span><br><span class="line">optval &#x3D; 5;</span><br><span class="line">setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &amp;optval, sizeof(optval));</span><br><span class="line"></span><br><span class="line">&#x2F;* Total number of probes sent *&#x2F;</span><br><span class="line">optval &#x3D; 5;</span><br><span class="line">setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &amp;optval, sizeof(optval));</span><br></pre></td></tr></table></figure>

<h3 id="伪重传"><a href="#伪重传" class="headerlink" title="伪重传"></a>伪重传</h3><p>在 wireshark 抓去 Wi-Fi 包时经常遇到<code>spurious retransmission</code>的情况：</p>
<p><img src="/2020/12/11/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/spurious_retransmission.png" alt="spurious_retransmission"></p>
<p>三次重传的间隔只有几毫秒，远小于超时重传的间隔，事实上这是 Wi-Fi 层的重传，并不是<code>伪重传</code>，只是 wireshark 显示的问题。</p>
<p>判断是 Wi-Fi 重传还是 TCP 重传的方法就是看 IP 包的 ID，如果一样那就是 Wi-Fi 重传，否则就是 TCP 重传，因为 TCP 重传包是新的 IP 包，所以 ID 也是不同。</p>
<h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><h3 id="ARP-的本质"><a href="#ARP-的本质" class="headerlink" title="ARP 的本质"></a>ARP 的本质</h3><p>ARP 的本质是<code>IP 和 MAC 的映射</code>，核心是<code>ARP 缓存表</code>。</p>
<h3 id="ARP-表更新的途径"><a href="#ARP-表更新的途径" class="headerlink" title="ARP 表更新的途径"></a>ARP 表更新的途径</h3><ul>
<li>收到发给自己的 ARP 回复</li>
<li>收到 ARP 请求</li>
<li>收到 IP 包</li>
</ul>
<h3 id="Wireshark-抓包"><a href="#Wireshark-抓包" class="headerlink" title="Wireshark 抓包"></a>Wireshark 抓包</h3><ul>
<li><p>Request</p>
<p><img src="/2020/12/11/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/%5Barp%5D-request.png" alt="arp-request"></p>
</li>
<li><p>Response</p>
<p><img src="/2020/12/11/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/%5Barp%5D-reponse.png" alt="arp-reponse"></p>
</li>
<li><p>Gratuitous</p>
<p><img src="/2020/12/11/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/%5Barp%5D-gratuitous.png" alt="arp-gratuitous"></p>
</li>
</ul>
<h3 id="无回报-Gratuitous-ARP请求"><a href="#无回报-Gratuitous-ARP请求" class="headerlink" title="无回报 (Gratuitous) ARP请求"></a>无回报 (Gratuitous) ARP请求</h3><p>主机在刚启动后一般会向局域网广播一个自己的<code>&lt;IP : MAC&gt;</code>信息，称为<code>无回报(gratuitous)ARP请求</code>。<br>无回报 ARP 请求其实就是<strong>目的 IP 是自己的 ARP 请求</strong>。</p>
<h3 id="ARP-欺骗：发送伪造的网关-Gratuitous-ARP-包"><a href="#ARP-欺骗：发送伪造的网关-Gratuitous-ARP-包" class="headerlink" title="ARP 欺骗：发送伪造的网关 Gratuitous ARP 包"></a>ARP 欺骗：发送伪造的网关 Gratuitous ARP 包</h3><p>比如一个局域网的网关地址是<code>192.168.31.1</code>，在此局域网内不停地发送伪造的 Gratuitous ARP 包，那么局域网内的所有的主机 ARP 表中的<code>192.168.31.1</code>就会被更新为伪造的 MAC 值，进而导致主机发送的数据包都到不了网关。</p>
<h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><h3 id="频繁重连后DHCP无法获取地址或获取地址慢"><a href="#频繁重连后DHCP无法获取地址或获取地址慢" class="headerlink" title="频繁重连后DHCP无法获取地址或获取地址慢"></a>频繁重连后DHCP无法获取地址或获取地址慢</h3><p><strong>摘要：</strong>WIFI上网时，有时会出现无线用户接入后获取地址慢，而且经常无线网卡提示连接受限的现象。该情况将直接影响到用户的使用感受。本文主要分析了该问题发生的主要原因以及解决方案。</p>
<p><strong>关键词：</strong>WIFI  连接受限  DHCP获取地址慢</p>
<p><strong>正文：</strong></p>
<p>在无锡市区的一些热点区域，经常会有用户反映出现无线接入后获取地址慢，而且有时会出现无线网卡提示受限连接的现象。该情况将直接影响到用户的使用感受。  </p>
<p>针对上面的现象，我们进行了现场的分析和定位，确定了最终的原因：<strong>该现象的最终原因不是WLAN接入造成，而是DHCP server所引起的。</strong> </p>
<p><strong>DHCP Server进行了一定的保护，也就是当DHCP server成功分配出一个地址以后，对于再次来自于客户端设备的DHCP请求将不作处理，只有原来的表项老化以后，才可能继续重新为客户端设备分配地址。</strong></p>
<p>由于无线的特殊性，网卡在信号不稳的时候会出现重新连接，或者最终用户在使用过程中可能直接拔插网卡的情况，这样相当于链路异常断开，最终导致DHCP server不知道用户已经下线。<strong>而当用户再次申请地址的时候，DHCP server可能认为报文非法而不进行处理，最终出现了获取地址慢的现象。</strong></p>
<p>通过有线进行测试也验证同样存在该问题。先使用有线网卡连接，保证成功获取地址，之后直接将网卡禁用后在使能，可以发现该网卡同样无法在短时间内获取地址。  </p>
<p>下面是用户DHCP申请地址的流程：</p>
<p><img src="/2020/12/11/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/%5Bdhcp%5D-dhcp_flow.png" alt="dhcp-dhcp_flow"></p>
<p>造成获取地址慢的原因：当DHCP server成功发送DHCP ACK报文之后，DHCP server将认为它已经成功为Client分配了一个IP地址，在没有接收到Release报文之前，或者自己的表项没有老化之前，再次收到来自于Client的报文，DHCP server将作为非法报文处理。  </p>
<ul>
<li><strong>获取地址慢的出现情况一：</strong>  </li>
</ul>
<p>如果客户端出现异常断开（也就是客户端虽然断开连接，但是没有发送DHCP Release报文），当该客户端再次连接的时候会出现无法获取地址，只有等待足够的一段时间后，才可以获取地址的问题。</p>
<p>能够造成该种情况的操作：  </p>
<ol>
<li>直接将有线网卡禁用；</li>
<li>直接将无线网卡禁用；</li>
<li>直接拔插无线网卡； </li>
</ol>
<ul>
<li><strong>获取地址慢的出现情况二：</strong></li>
</ul>
<p>由于客户端和服务器经过了大量的有线网络，所以在获取地址的瞬间，有可能出现报文延时的问题，特别当DHCP server回复的DHCP ACK报文延时到达客户端的时候，此时客户端会认为它已经发送的DHCP request报文超时，状态机回到初始位置，重新发送DHCP discovery报文。但是由于DHCP服务器已经发送了ACK，所以认为已经成功给客户端分配了地址，所以会忽略掉客户端的新的DHCP discovery请求。造成客户端获取不到地址或者需要经过一段时间后才可以获取地址。</p>
<p>下面是在AP上行端口抓包，第110条报文，AP将客户端的DHCP request报文成功发送出去，但是等待了10ms之后没有收到服务器的DHCP ACK报文，所以重新发送DHCP discovery报文申请地址；但是此时服务器实际上已经发送了一个DHCP ACK报文（只是该报文在60ms之后到达）。这样就造成了客户端和服务器的状态机不一致，服务器不再处理新的DHCP Discovery请求。</p>
<p><img src="/2020/12/11/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/%5Bdhcp%5D-dhcp_timeout.png" alt="dhcp-dhcp_timeout"></p>
<p>这个现象只能通过DHCP server上面的优化，目前该现象与WLAN网络和有线网络都没有关系，WLAN设备没有问题。由于DHCP服务器管理了很多的接入服务，需要仔细考虑如何进行优化。</p>
]]></content>
      <categories>
        <category>TCPIP</category>
      </categories>
  </entry>
  <entry>
    <title>TCPIP Hacking</title>
    <url>/2020/12/11/Network/TCPIP/TCPIP%20Hacking/</url>
    <content><![CDATA[<p>常见的 TCPIP 攻击方法。</p>
<a id="more"></a>

<h2 id="ARP-欺骗：发送伪造的网关-Gratuitous-ARP-包"><a href="#ARP-欺骗：发送伪造的网关-Gratuitous-ARP-包" class="headerlink" title="ARP 欺骗：发送伪造的网关 Gratuitous ARP 包"></a>ARP 欺骗：发送伪造的网关 Gratuitous ARP 包</h2><h3 id="无回报-Gratuitous-ARP请求"><a href="#无回报-Gratuitous-ARP请求" class="headerlink" title="无回报 (Gratuitous) ARP请求"></a>无回报 (Gratuitous) ARP请求</h3><p>主机在刚启动后一般会向局域网广播一个自己的<code>&lt;IP : MAC&gt;</code>信息，称为<code>无回报(gratuitous)ARP请求</code>。<br>无回报 ARP 请求其实就是<strong>目的 IP 是自己的 ARP 请求</strong>。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>比如一个局域网的网关地址是<code>192.168.31.1</code>，在此局域网内不停地发送伪造的 Gratuitous ARP 包，那么局域网内的所有的主机 ARP 表中的<code>192.168.31.1</code>就会被更新为伪造的随机 MAC 地址，进而导致主机发送的数据包都到不了网关，也无法与外界通信。</p>
<p>防御 ARP 欺骗的唯一方法就是在主机上为此网关添加一条静态的ARP映射，但是一般用户不会操作。</p>
<h3 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h3><p>在linux中提供了PF_PACKET接口可以操作链路层的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IP|ETH_P_ARP|ETH_P_ALL))</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>TCPIP</category>
      </categories>
  </entry>
  <entry>
    <title>AliOS-Things KV</title>
    <url>/2020/12/11/OS/AliOS-Things/AliOS-Things%20KV/</url>
    <content><![CDATA[<p>AliOS-Things 中 KV 代码分析。</p>
<a id="more"></a>

<h2 id="block"><a href="#block" class="headerlink" title="block"></a>block</h2><p>block 的头部如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* Flash block header description *&#x2F;</span><br><span class="line">typedef struct _block_header_t &#123;</span><br><span class="line">    uint8_t     magic;          &#x2F;* The magic number of block *&#x2F;</span><br><span class="line">    uint8_t     state;          &#x2F;* The state of the block *&#x2F;</span><br><span class="line">    uint8_t     reserved[2];</span><br><span class="line">&#125; __attribute__((packed)) block_hdr_t;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">magic</th>
<th align="left">state</th>
<th align="left">reserved</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ASCII ‘K’</td>
<td align="left">1B</td>
<td align="left">2B</td>
</tr>
</tbody></table>
<p>magic 是 ASCII 码 ‘K’：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static const uint8_t BLK_MAGIC_NUM  &#x3D; &#39;K&#39;; &#x2F;* The block header magic number *&#x2F;</span><br></pre></td></tr></table></figure>

<p>state 有 3 种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define BLK_STATE_USED  0xCC &#x2F;* Block state: USED --&gt; block is inused and without dirty data *&#x2F;</span><br><span class="line">#define BLK_STATE_CLEAN 0xEE &#x2F;* Block state: CLEAN --&gt; block is clean, ready for used *&#x2F;</span><br><span class="line">#define BLK_STATE_DIRTY 0x44 &#x2F;* Block state: DIRTY --&gt; block is inused and with dirty data *&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="item"><a href="#item" class="headerlink" title="item"></a>item</h2><p>item 的头部如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* Key-value item header description *&#x2F;</span><br><span class="line">typedef struct _item_header_t &#123;</span><br><span class="line">    uint8_t     magic;          &#x2F;* The magic number of key-value item *&#x2F;</span><br><span class="line">    uint8_t     state;          &#x2F;* The state of key-value item *&#x2F;</span><br><span class="line">    uint8_t     crc;            &#x2F;* The crc-8 value of key-value item *&#x2F;</span><br><span class="line">    uint8_t     key_len;        &#x2F;* The length of the key *&#x2F;</span><br><span class="line">    uint16_t    val_len;        &#x2F;* The length of the value *&#x2F;</span><br><span class="line">    uint16_t    origin_off;     &#x2F;* The origin key-value item offset, it will be used when updating *&#x2F;</span><br><span class="line">&#125; __attribute__((packed)) item_hdr_t;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">magic</th>
<th align="left">state</th>
<th align="left">crc</th>
<th align="left">key_len</th>
<th align="left">val_len</th>
<th align="left">origin_off</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ASCII ‘I’</td>
<td align="left">1B</td>
<td align="left">1B</td>
<td align="left">1B</td>
<td align="left">2B</td>
<td align="left">2B</td>
</tr>
</tbody></table>
<p>magic 是 ASCII 码 ‘I’：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static const uint8_t ITEM_MAGIC_NUM &#x3D; &#39;I&#39;; &#x2F;* The key-value item header magic number *&#x2F;</span><br></pre></td></tr></table></figure>

<p>state 有 2 种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define ITEM_STATE_NORMAL 0xEE &#x2F;* Key-value item state: NORMAL --&gt; the key-value item is valid *&#x2F;</span><br><span class="line">#define ITEM_STATE_DELETE 0    &#x2F;* Key-value item state: DELETE --&gt; the key-value item is deleted *&#x2F;</span><br></pre></td></tr></table></figure>

<p>crc 是 key 和 value 的 8 bit 校验码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* CRC-8: the poly is 0x31 (x^8 + x^5 + x^4 + 1) *&#x2F;</span><br><span class="line">static uint8_t utils_crc8(uint8_t *buf, uint16_t length)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t crc &#x3D; 0x00;</span><br><span class="line">    uint8_t i;</span><br><span class="line"></span><br><span class="line">    while (length--) &#123;</span><br><span class="line">        crc ^&#x3D; *buf++;</span><br><span class="line">        for (i &#x3D; 8; i &gt; 0; i--) &#123;</span><br><span class="line">            if (crc &amp; 0x80) &#123;</span><br><span class="line">                crc &#x3D; (crc &lt;&lt; 1) ^ 0x31;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                crc &lt;&lt;&#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return crc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>key_len 是 key 的长度</p>
<p>val_len 是 value 的长度</p>
<p>origin_off 是上个旧 item 的 offset</p>
<p>通过一个实验来理解，例如，我 set name snowyang，然后 set name snowyang-1992，再 set name snowyang-19920202，最后 dump 出来的 binary 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000h: 4B 44 00 00 49 00 98 04 08 00 00 00 6E 61 6D 65 ; KD..I.......name</span><br><span class="line">00000010h: 73 6E 6F 77 79 61 6E 67 49 00 37 04 0D 00 04 00 ; snowyangI.7.....</span><br><span class="line">00000020h: 6E 61 6D 65 73 6E 6F 77 79 61 6E 67 2D 31 39 39 ; namesnowyang-199</span><br><span class="line">00000030h: 32 00 00 00 49 EE D6 04 11 00 18 00 6E 61 6D 65 ; 2...IîÖ.....name</span><br><span class="line">00000040h: 73 6E 6F 77 79 61 6E 67 2D 31 39 39 32 30 32 30 ; snowyang-1992020</span><br><span class="line">00000050h: 32 00 00 00 FF FF FF FF FF FF FF FF FF FF FF FF ; 2...ÿÿÿÿÿÿÿÿÿÿÿÿ</span><br></pre></td></tr></table></figure>

<p>可见第二个 item 的 <code>origin_off</code> 是 0x04，也就是第一个 item 的地址，同样地，第三个 item 的 <code>origin_off</code> 是第二个 item 的地址 0x18</p>
<p>具体作用不明</p>
<h3 id="描述-item-的结构体如下："><a href="#描述-item-的结构体如下：" class="headerlink" title="描述 item 的结构体如下："></a>描述 item 的结构体如下：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* Key-value item description *&#x2F;</span><br><span class="line">typedef struct _kv_item_t &#123;</span><br><span class="line">    item_hdr_t  hdr;            &#x2F;* The header of the key-value item, detail see the item_hdr_t structure *&#x2F;</span><br><span class="line">    char       *store;          &#x2F;* The store buffer for key-value *&#x2F;</span><br><span class="line">    uint16_t    len;            &#x2F;* The length of the buffer *&#x2F;</span><br><span class="line">    uint16_t    pos;            &#x2F;* The store position of the key-value item *&#x2F;</span><br><span class="line">&#125; kv_item_t;</span><br></pre></td></tr></table></figure>

<p>需要注意：这个结构体是用来描述一个 item 的，是一个变量，不是描述 item 的存储结构的</p>
<p>hdr 是上述头部</p>
<p>store 是实际存储 key 和 value 的 buffer，一般是 malloc 来的</p>
<p>len 是 header + key + value 的长度，注意是 4 字节对齐</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">len &#x3D; (ITEM_HEADER_SIZE + hdr-&gt;key_len + hdr-&gt;val_len + ~KV_ALIGN_MASK) &amp; KV_ALIGN_MASK;</span><br></pre></td></tr></table></figure>

<p>pos 是 item 在 flash 中的地址</p>
]]></content>
      <categories>
        <category>AliOS-Things</category>
      </categories>
  </entry>
  <entry>
    <title>EasyOs</title>
    <url>/2020/12/11/OS/EasyOS/EasyOs/</url>
    <content><![CDATA[<p><code>EasyOS</code>是我在大约七、八年前，将 FreeRTOS 和 uCOS-II 研究透测后，自以为是的写了一个融汇二者精华的 RTOS😄。</p>
<p>下面是做 EasyOS 的一些记录，还有一些待整理。</p>
<a id="more"></a>

<h3 id="上下文切换时，应该保存什么？保存到哪里？"><a href="#上下文切换时，应该保存什么？保存到哪里？" class="headerlink" title="上下文切换时，应该保存什么？保存到哪里？"></a>上下文切换时，应该保存什么？保存到哪里？</h3><p>答: 应该保存3个信息：<strong>PC</strong>、<strong>SP</strong>和<strong>CPU寄存器组</strong>。它们组成了程序运行所需的<strong>CPU运行环境</strong>，切换任务，其实就是切换程序运行环境。</p>
<p><em>注：程序运行环境-程序运行所需的必要条件。</em></p>
<p><img src="/2020/12/11/OS/EasyOS/EasyOs/wpsjlk4Vv.png" alt="img"></p>
<p><em>注：栈用来存放断点数据和函数的活动记录-临时变量（CPU寄存器组），局部变量（参数和返回值本质上也是局部变量）和返回地址(PC)。</em></p>
<p><img src="/2020/12/11/OS/EasyOS/EasyOs/wps5wD6sI.png" alt="img"></p>
<p>对于Cortex M3，PC和寄存器组压在栈内，SP指向栈顶。所以，只需找到SP，就可以获得CPU运行环境——切换CPU运行环境变成了切换SP。</p>
<p><img src="/2020/12/11/OS/EasyOS/EasyOs/wpsmUQc0O.png" alt="img"></p>
]]></content>
      <categories>
        <category>EasyOS</category>
      </categories>
  </entry>
  <entry>
    <title>FreeRTOS 和一些感悟</title>
    <url>/2020/12/11/OS/FreeRTOS/FreeRTOS%20%E5%92%8C%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<p>这是我在 2012 年刚刚使用 FreeRTOS 时写的笔记，转眼八年过去了。</p>
<a id="more"></a>

<h2 id="用“WWH”方法分析FreeRTOS中的链表"><a href="#用“WWH”方法分析FreeRTOS中的链表" class="headerlink" title="用“WWH”方法分析FreeRTOS中的链表"></a>用“WWH”方法分析FreeRTOS中的链表</h2><h3 id="What？FreeRTOS的链表结构是什么样的？"><a href="#What？FreeRTOS的链表结构是什么样的？" class="headerlink" title="What？FreeRTOS的链表结构是什么样的？"></a>What？FreeRTOS的链表结构是什么样的？</h3><p><img src="/2020/12/11/OS/FreeRTOS/FreeRTOS%20%E5%92%8C%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F/wps4jx5Sx.png" alt="img"></p>
<p>如上图所示，FreeRTOS的链表由list item和list组成。</p>
<p>List item有4个指针， 分别指向前，后，owner和container。</p>
<p>List只有3个指针，分别指向前，后和index。</p>
<h3 id="Why-这样的结构有什么用处？"><a href="#Why-这样的结构有什么用处？" class="headerlink" title="Why? 这样的结构有什么用处？"></a>Why? 这样的结构有什么用处？</h3><p>List item：</p>
<p>前，后指针用来插入和移出某个链表。</p>
<p>owner指针用来寻找其属于的TCB。</p>
<p>container指针用来寻找其所在的链表。</p>
<p>List:</p>
<p>前，后指针用来寻找前后的list item，方便查找有序链表的表头。</p>
<p>Index用来遍历链表，实现同一优先级的任务时间片调度机制。</p>
<h2 id="链表的insert和insert-end"><a href="#链表的insert和insert-end" class="headerlink" title="链表的insert和insert end"></a>链表的insert和insert end</h2><p><img src="/2020/12/11/OS/FreeRTOS/FreeRTOS%20%E5%92%8C%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F/wps8QFHVH.png" alt="img"></p>
<p>感悟：学习最忌讳一开始就一头扎进去。古人云：不是庐山真面目，只缘身在此山中。如果揪住一个细节不放，很容易陷入困境，应该跳出来看全局，看框架，然后再分步细细分析。</p>
<p>经常会看一段代码，看完后好像懂了，但如果问自己，这段代码作什么用的？什么时候会用到？却是一脸茫然，这是个很不好的习惯。</p>
<h2 id="Start-scheduler，面向对象分析法"><a href="#Start-scheduler，面向对象分析法" class="headerlink" title="Start scheduler，面向对象分析法"></a>Start scheduler，面向对象分析法</h2><p>经典的程序分析方法是面向过程，也就是所谓的“流程图“，这样的方法很详细，但往往让人眼花头晕，经常是看完后好像懂了，但是一问，又是一脸茫然，陷入繁文细节中，只记得一个个if else。</p>
<p>如下图所示，是面向对象分析法，将程序中操作的对象一个个抽象出来，这样一看就一目了然，知道这段程序是对什么操作，有什么用处。</p>
<p>程序 ＝ 对象 ＋ 对象</p>
<p><img src="/2020/12/11/OS/FreeRTOS/FreeRTOS%20%E5%92%8C%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F/wpsGa3njS.png" alt="img"></p>
<h3 id="Create-task"><a href="#Create-task" class="headerlink" title="Create task"></a>Create task</h3><p><img src="/2020/12/11/OS/FreeRTOS/FreeRTOS%20%E5%92%8C%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F/wpsXaI1nY.png" alt="img"></p>
<h3 id="RTOS-＝-scheduler-ITC-timer-tasks"><a href="#RTOS-＝-scheduler-ITC-timer-tasks" class="headerlink" title="RTOS ＝ scheduler + ITC + timer + tasks"></a>RTOS ＝ scheduler + ITC + timer + tasks</h3><p><img src="/2020/12/11/OS/FreeRTOS/FreeRTOS%20%E5%92%8C%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F/wpsZs6F7l.png" alt="img"></p>
<p>简单的来说，RTOS就是实现任务调度和通信的软件。</p>
<p>感悟：面向对象思想就是， 一切都由“对象”和“操作”组成。对象是实体，操作是动作。</p>
<p>用面向对象的思想来看，</p>
<p>函数 ＝ 变量 ＋ … + 变量。语句是“操作”。</p>
<p>任务 ＝ 函数 ＋ 栈 ＋ TCB。</p>
<p>RTOS ＝ Scheduler + Task + ITC + Timer</p>
<p>RTOS是一种系统设计思想（就好比面向对象是一种思想），而不是一门技术。</p>
<p>感悟：程序是对实体的抽象，是为了实现某种事物，所以在写程序或者看程序时，要用面向对象的方法。</p>
<p>比如实现LED闪烁的一个函数，可以把它看作LED闪烁器。实现按键处理的函数，将其看作键盘。</p>
<p>扩展思考：人类创作的一切东西，都是来自于真实生活，都是有实体对象的，电子界也是如此，比如以前学习I2C协议，用面向对象法就是，起始检测器，传输器，ACK器，结束检测器，这也更符合实际的实现电路。</p>
<p><img src="/2020/12/11/OS/FreeRTOS/FreeRTOS%20%E5%92%8C%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F/wpsTHTLmu.png" alt="img"></p>
<p>嵌入式系统 ＝ 线程 ＋ 事件 ＋ 硬件，如下图</p>
<p><img src="/2020/12/11/OS/FreeRTOS/FreeRTOS%20%E5%92%8C%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F/wpsirLf7N.png" alt="img"></p>
<p>重新定义RTOS：</p>
<p>RTOS = 任务管理器 + 任务</p>
<p>任务管理器 ＝ 调度器 + 通信器 + 定时器</p>
<p>任务 = 任务函数 + 任务栈 + 任务控制块</p>
<p>为什么要用RTOS，原因有两点：</p>
<p>一. 有些应用需要硬实时性，而传统的前后台系统无法实现，必须用RTOS。</p>
<p>二. 有些应用只需软实时，用前后台系统也可以实现，但是依然推荐RTOS，因为其两大优点 -&gt; 模块性和规范性。</p>
<p>模块性: 独立，易维护和易扩展。</p>
<p>规范性: 系统模型统一 -&gt; 硬件产生事件，事件驱动线程，线程控制硬件，线程之间互相通信。</p>
<p>感悟：诺基亚920光荣退居二线了，筹备着新机，预算定在千元内，细细甄选后相中了魅蓝note2，799元，性价比极高，准备定下，忽然想到，既然换就换一个好的，能用个两三年，于是放弃魅蓝note2，左挑右选后看中乐1，1499元的价格，性能堪比旗舰，敲定，付money，一天后，又发现魅族MX5，1799元，比乐1多了指纹识别，全金属机身，2070万相机，激光对焦，CPU也更好，但价钱上只多了300元，心动，不如多花点钱买这个？想退款重买，又忽然发现了小米note，1999元，号称安卓机皇，性能怪兽，屏幕更大，价格上只比MX5多了200元，哇，就它了。</p>
<p>忽然想起来，本来我要花的钱是799元，为何最后变成了1999元？</p>
<p>“反正才多了几百元，但是性能强大了这么多，还是很值的。”</p>
<p>就是这个心理，让我的预算一而再的向上翻。</p>
<p>（未完待续）</p>
<p>做一个WIFI智能插座，嵌入式工程师会觉得难，因为他要考虑硬件选型， 画原理图，画PCB，测试天线，继电器性能，然后要考虑底层驱动编写，TCP/IP协议栈移植，RTOS移植，稳定性测试等等。</p>
<p>但是软件工程师会说，啊，很简单啊，WIFI模块＋控制模块就OK了。</p>
<p>软件工程师已经在不知觉中使用了面向对象的思考方法。</p>
<p>而嵌入式工程师正在用面向过程的方法思考同样的问题。</p>
<p>面向对象是简单易解的，因为它是最直观的。</p>
]]></content>
      <categories>
        <category>FreeRTOS</category>
      </categories>
  </entry>
  <entry>
    <title>FreeRTOS 记录</title>
    <url>/2020/12/11/OS/FreeRTOS/FreeRTOS%20%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>FreeRTOS 一些记录。</p>
<a id="more"></a>

<h2 id="FreeRTOS"><a href="#FreeRTOS" class="headerlink" title="FreeRTOS"></a>FreeRTOS</h2><ul>
<li><p>老版本的 FreeRTOS 如何下载？<br><a href="https://sourceforge.net/p/freertos/code/HEAD/tree/%EF%BC%8C%E7%82%B9%E5%87%BB">https://sourceforge.net/p/freertos/code/HEAD/tree/，点击</a> tags 进入，选择版本然后点击<code>Download Snapshot</code>按钮即可启动下载。</p>
</li>
<li><p>FreeRTOS 配置选项<br>FreeRTOSConfig.h 的说明：<a href="https://www.freertos.org/a00110.html">https://www.freertos.org/a00110.html</a></p>
</li>
<li><p>如何移植<br><a href="https://www.freertos.org/FreeRTOS-porting-guide.html">https://www.freertos.org/FreeRTOS-porting-guide.html</a></p>
</li>
<li><p>中断优先级设置？</p>
<p>在移植 5062 时遇到了 StartScheduler 函数内执行 SVC 0 指令后触发 Hardfault 的错误，调试发现是 SVC 中断被屏蔽所导致的。FreeRTOS 在 StartScheduler 前会 portDISABLE_INTERRUPTS，Cortex-M 是通过写 BASEPRI 来屏蔽中断的，5062 的BASRPRI 的值被写为 0x20，而 SVC 的优先级恰好也被设置成了 0x20，所以 SVC 中断被屏蔽了。在 SVC 中断被屏蔽时去触发它会产生一个用法错误 - Hardfaut。</p>
<blockquote>
<p>configMAX_SYSCALL_INTERRUPT_PRIORITY needs to be a raw priority value as it is written to the NVIC priority registers in the Cortex-M3 device, as documented in the ARM manuals. The priorities of 0..15 are not real Cortex-M3 priorities, and are simplified priorities for use in some library calls (because the real priorities are so complex on Cortex-M devices).<br>If you want a simplified priority of 8, then you need to set configMAX_SYSCALL_INTERRUPT_PRIORITY to 0x8n, where n can be any value, but by convention, and for future proofing in case future STM32 parts implement more priority bits, should be set to f. Therefore, the priority you want is 0x8f.<br>“the code app-faults at “svc 0” in vPortStartFirstTask”<br>Presumably a hard fault because you are attempting a call to effectively a synchronous interrupt while simultaneously having that interrupt masked out.</p>
</blockquote>
</li>
<li><p>FreeRTOS 只有在任务切换时才会检查栈当前栈是否溢出，所以不是所有的线程的栈溢出都能被检查到的。</p>
</li>
<li><p>在移植 STM32L431RC 时遇到了上位机发送数据后，UART 接收线程却没有接收到数据的问题。</p>
<p>UART 接收大致流程如下：</p>
<blockquote>
<p>用户线程：拿 semphr -&gt; 读取数据<br>UART 接收中断：给 semphr</p>
</blockquote>
<p>调试发现中断中给了 semphr ，但是线程没有拿到，原来是在拿 semphr 中的临界区出了问题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">taskENTER_CRITICAL();</span><br><span class="line"><span class="keyword">const</span> UBaseType_t uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;</span><br><span class="line"><span class="keyword">if</span>( uxMessagesWaiting &gt; ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get data</span></span><br><span class="line">    <span class="comment">// Return</span></span><br><span class="line">&#125;</span><br><span class="line">taskEXIT_CRITICAL();</span><br><span class="line"><span class="comment">// Block current thread untill semphr is gived</span></span><br></pre></td></tr></table></figure>

<p>taskENTER_CRITICAL 是把优先级低于 CORTEX_NVIC_PRIO_BITS 的中断全部屏蔽。</p>
<p>STM32L431RC 的抢占优先级数是 4，而我把 CORTEX_NVIC_PRIO_BITS 设置成了 3，刚好 UART 中断配的是最高优先级 0，所以 taskENTER_CRITICAL 实际上对 UART 中断不起作用，若在第 2 行后刚好来了一个 UART 接收中断，虽然中断内给了 semphr，但是中断返回后，第 4 行还是认为没有给 semphr，所以出错。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>FreeRTOS</category>
      </categories>
  </entry>
  <entry>
    <title>Zephyr Primer</title>
    <url>/2020/12/11/OS/Zephyr/Zephyr%20Primer/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Zephyr 最初是<code>Wind River</code>公司在 2015 年推出的为 IoT 开发的<code>Rocket内核</code>，更早时称为<code>Microkernel Profile for VxWorks</code>。代码移植于2001年并购<code>Eonic Systems</code>得来的<code>Virtuoso DSP RTOS</code>。在2016年，它成为Linux基金会的项目而改称 zephyr。</p>
<p>参考：<a href="https://zh.wikipedia.org/wiki/Zephyr">Zephyr Wiki</a></p>
<a id="more"></a>

<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p><strong>官网</strong>：<a href="https://zephyrproject.org/">https://zephyrproject.org</a></p>
<p><strong>文档</strong>：<a href="https://docs.zephyrproject.org/latest">https://docs.zephyrproject.org/latest</a></p>
<p><strong>源代码</strong>：<a href="https://github.com/zephyrproject-rtos/zephyr">https://github.com/zephyrproject-rtos/zephyr</a></p>
<p><strong>Wiki</strong>：<a href="https://github.com/zephyrproject-rtos/zephyr/wiki">https://github.com/zephyrproject-rtos/zephyr/wiki</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>参考<a href="https://docs.zephyrproject.org/latest/getting_started/index.html">Getting Started Guide</a></p>
<h2 id="配置-Kconfig"><a href="#配置-Kconfig" class="headerlink" title="配置 Kconfig"></a>配置 Kconfig</h2><p>参考<a href="https://docs.zephyrproject.org/latest/guides/kconfig/menuconfig.html">Interactive Kconfig interfaces</a></p>
<p>有两个交互式配置界面可以配置 Kconfig选项：<code>menuconfig</code>和 <code>guiconfig</code>。<code>menuconfig</code>是在终端中运行的基于curses的界面，<code>guiconfig</code>而是图形配置界面。</p>
<p>要运行 menuconfig，请执行以下操作：</p>
<ol>
<li><p>使用<code>west</code>或者<code>cmake</code>构建您的应用程序：</p>
<p>使用west</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">west build -b &lt;board&gt;</span><br></pre></td></tr></table></figure>

<p>使用CMake和忍者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line">cmake -GNinja -DBOARD&#x3D;&lt;board&gt; ..</span><br><span class="line">ninja</span><br></pre></td></tr></table></figure>
</li>
<li><p>要运行基于终端的<code>menuconfig</code>界面，请使用以下命令之一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">west build -t menuconfig</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ninja menuconfig</span><br></pre></td></tr></table></figure>

<p>要运行图形<code>guiconfig</code>，请使用以下命令之一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">west build -t guiconfig</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ninja guiconfig</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">west build -b nrf52dk_nrf52832 samples&#x2F;hello_world</span><br><span class="line">west flash</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Zephyr</category>
      </categories>
  </entry>
  <entry>
    <title>C 入口函数分析</title>
    <url>/2020/12/11/Programing%20Language/C/C%20%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>Linux系统下一般程序的入口是<code>_start</code>，这个函数是Linux系统库（Glibc）的一部分。同样地，newlib等C库也是以<code>_start</code>作为入口函数。</p>
<p>对于C++程序，有两个特殊的段：<code>.init</code> 和 <code>.fini</code>。这两个段.init和.fini的存在有着特别的目的，如果一个函数放到.init段，在main函数执行前系统就会执行它。同理，假如一个函数放到.fint段，在main函数返回后该函数就会被执行。利用这两个特性，C++的全局构造和析构函数就由此实现。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>C 整型转换</title>
    <url>/2020/12/11/Programing%20Language/C/C%20%E6%95%B4%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int8_t a &#x3D; -1;</span><br><span class="line">uint32_t b &#x3D; a;</span><br><span class="line">b &#x3D; ?</span><br></pre></td></tr></table></figure>

<p>这要用到整型转换规则， <strong>C Programming Language(K &amp; R)</strong> (A.6.2)上这样解释：</p>
<blockquote>
<p>将任何整数转换为某种指定的无符号数类型数的方法是：以该无符号数类型能够表示的最大值加1为模，找出与此整数同余的最小的非负值。<br>在对二的补码表示中，如果该无符号类型的位模式较窄，这就相当于左截取；如果该符号类型的位模式较宽，这就相当于对带符号的值进行符号扩展和对无符号的值进行0填充。</p>
</blockquote>
<p>将任何整数转换为带符号类型时，如果它可以在新的类型中表示出来，则其值保持不变，否则它的值同具体的实现有关。</p>
<p>其中<code>以该无符号数类型能够表示的最大值加1为模，找出与此整数同余的最小的非负值</code>，我觉得太拗口，下面那段才比较好理解<code>在对二的补码表示中，如果该无符号类型的位模式较窄，这就相当于左截取；如果该符号类型的位模式较宽，这就相当于对带符号的值进行符号扩展和对无符号的值进行0填充。</code></p>
<p>比如把 0x1234 放到一个 uint8_t 类型变量 x 中，那么高 8 位就被截掉，低 8 位被放到变量中，最终 x 的值为 0x34。<br>比如把 -1 放到 x 中，因为 -1 的二进制码是 0xFFFFFFFF，那么 x 的值就等于 0xFF。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>C 整形提升</title>
    <url>/2020/12/11/Programing%20Language/C/C%20%E6%95%B4%E5%BD%A2%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<p>摘自<a href="https://zh.wikipedia.org/wiki/%E6%95%B4%E5%9E%8B%E6%8F%90%E5%8D%87">维基百科</a>：</p>
<p>整型提升是C程序设计语言中的一项规定：在表达式计算时，各种整形首先要提升为int类型，如果int类型不足以表示则要提升为unsigned int类型；然后执行表达式的运算。[1]</p>
<p>这一规则是由C语言的发明人丹尼斯·里奇与肯·汤普逊创设的：[2]</p>
<blockquote>
<p>A character, a short integer, or an integer bit-field, all either signed or not, or an object of enumeration type, may be used in an expression wherever an integer maybe used. If an int can represent all the values of the original type, then the value is converted to int; otherwise the value is converted to unsigned int. This process is called integral promotion.</p>
</blockquote>
<p>这段话的大意是：表达式中可以使用整数的地方，就可以使用枚举类型，或有符号或无符号的字符、短整数、整数位域。如果一个int可以表示上述类型，则该值被转化为int类型的值；否则，该值被转化为unsigned int类型的值。这一过程被称作integral promotion。</p>
<p>整型提升的意义在于：表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节长度，同时也是CPU的通用寄存器的长度。因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。通用CPU（general-purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令中可能有这种字节相加指令）。所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>C 隐式类型转换</title>
    <url>/2020/12/11/Programing%20Language/C/C%20%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>在项目中遇到一个奇怪的问题，伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int8_t  a &#x3D; 0x8F;</span><br><span class="line">uint8_t b &#x3D; 0x8F；</span><br><span class="line"></span><br><span class="line">if( a &#x3D;&#x3D; b )</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;a &#x3D; b\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;a !&#x3D; b, a &#x3D; %02x, b &#x3D; %02x\n&quot;, a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照我的理解，<code>if(a == b)</code>一定为真。但运行结果却让我大跌眼镜:</p>
<p><code>a != b, a = ffffff8f, b = 8F</code></p>
<p>首先，变量<code>a</code>不等于<code>b</code>已经让我吃惊了，然后，打印出来<code>a</code>的值竟然是<code>ffffff8f</code>！<br>查了一通资料，我才知道，原来在 C 语言中有<code>隐式类型转换</code>这么一个规则。<br><code>隐式类型转换</code>是指变量在运算中的一种隐式的类型转换，主要分两种：<code>算术</code>和<code>赋值</code>转换。</p>
<a id="more"></a>

<h2 id="算术转换"><a href="#算术转换" class="headerlink" title="算术转换"></a>算术转换</h2><p>算术转换的规则可以用一张图来表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HIGH</span><br><span class="line">  ^</span><br><span class="line">double &lt;-- float</span><br><span class="line">  |</span><br><span class="line">long</span><br><span class="line">  |</span><br><span class="line">unsigned </span><br><span class="line">  |</span><br><span class="line">int &lt;-- char, short</span><br><span class="line">  ^</span><br><span class="line">LOW  </span><br></pre></td></tr></table></figure>

<p>此图中有两个箭头。</p>
<p>竖向箭头表示不同的数据类型在进行混合运算的时候，会有一个低字节向高字节转换的过程。术语叫<code>寻常算术转换</code>（<code>usual arithmetic conversion</code>）。</p>
<p>横向箭头表示不管该类型有没有进行混合运算都势必会进行转换，再进行运算，术语叫<code>整型提升</code>（<code>Integral promotions</code>）。</p>
<p>##赋值转换</p>
<hr>
<p>进行赋值操作时，赋值运算符右边的数据类型必须转换成赋值号左边的类型，若右边的数据类型的长度大于左边，则要进行求余的截取操作。</p>
<p>如定义变量<code>uint8_t a = 257；</code>，因为<code>uint8_t</code>类型的最大值是<code>256</code>，所以要求余的截取操作，最终<code>a = 257 % 256 = 1</code>。</p>
<p>又如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int8_t a &#x3D; -1;</span><br><span class="line">int32_t b &#x3D; a;</span><br><span class="line">printf(&quot;a &#x3D; %x, b &#x3D; %x\n&quot;,a, b);</span><br></pre></td></tr></table></figure>

<p>这就是一个扩展操作，<code>a</code>先被转为<code>int</code>,再被转为<code>unsigned</code>,<code>b</code>的十六进制值等于<code>0xFFFFFFFF</code>。</p>
<p>回到最开始的那个问题，在<code>==</code>运算中，<code>a</code>和<code>b</code>都被隐式地转换成了<code>int</code>型，一个是<code>-113</code>，一个是<code>143</code>,肯定不一样。</p>
<p><code>prinf</code>的参数实际上也是一种赋值转换，因为<code>%02x</code>指定了参数的类型是<code>uint32_t</code>，所以<code>a</code>被隐式地转换为了<code>uint32_t</code>的类型，也即<code>0xfffffff8</code>。</p>
<p>##参考</p>
<hr>
<p><a href="https://zh.wikipedia.org/wiki/%E6%95%B4%E5%9E%8B%E6%8F%90%E5%8D%87">整型提升</a></p>
<p><a href="https://my.oschina.net/Ccx371161810/blog/293941">C的隐式类型转换</a></p>
<p><a href="http://www.embedu.org/Column/5653.html">关于C语言的隐式类型转换</a></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>newlib 中的 crt0 流程分析</title>
    <url>/2020/12/11/Programing%20Language/C/newlib%20%E4%B8%AD%E7%9A%84%20crt0%20%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>最近对 newlib 中的启动代码 crt0 产生了兴趣，于是就分析了下其代码。crt0 的源码位于 libgloss/arm/crt0.S，为了兼容各种 ARM 架构，crt0.S 中有大量的条件判断宏定义，对于只关心 ARMv7e-M 的我来说很是痛苦。刚好手上有个基于 STM32F412 的 mbed 工程用的是 crt0 的启动方式，参考 crt0.o 的反汇编我可以提炼出 crt0.S 中和 ARMv7e-M 相关的部分代码。</p>
<a id="more"></a>

<p>crt0.o 的反汇编如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">08008220 &lt;_mainCRTStartup&gt;:</span><br><span class="line"> 8008220:    4b15          ldr    r3, [pc, #84]    ; (8008278 &lt;_mainCRTStartup+0x58&gt;)</span><br><span class="line"> 8008222:    2b00          cmp    r3, #0</span><br><span class="line"> 8008224:    bf08          it    eq</span><br><span class="line"> 8008226:    4b13          ldreq    r3, [pc, #76]    ; (8008274 &lt;_mainCRTStartup+0x54&gt;)</span><br><span class="line"> 8008228:    469d          mov    sp, r3</span><br><span class="line"> 800822a:    f5a3 3a80     sub.w    sl, r3, #65536    ; 0x10000</span><br><span class="line"> 800822e:    2100          movs    r1, #0</span><br><span class="line"> 8008230:    468b          mov    fp, r1</span><br><span class="line"> 8008232:    460f          mov    r7, r1</span><br><span class="line"> 8008234:    4813          ldr    r0, [pc, #76]    ; (8008284 &lt;_mainCRTStartup+0x64&gt;)</span><br><span class="line"> 8008236:    4a14          ldr    r2, [pc, #80]    ; (8008288 &lt;_mainCRTStartup+0x68&gt;)</span><br><span class="line"> 8008238:    1a12          subs    r2, r2, r0</span><br><span class="line"> 800823a:    f01c fcd7     bl    8024bec &lt;memset&gt;</span><br><span class="line"> 800823e:    4b0f          ldr    r3, [pc, #60]    ; (800827c &lt;_mainCRTStartup+0x5c&gt;)</span><br><span class="line"> 8008240:    2b00          cmp    r3, #0</span><br><span class="line"> 8008242:    d000          beq.n    8008246 &lt;_mainCRTStartup+0x26&gt;</span><br><span class="line"> 8008244:    4798          blx    r3</span><br><span class="line"> 8008246:    4b0e          ldr    r3, [pc, #56]    ; (8008280 &lt;_mainCRTStartup+0x60&gt;)</span><br><span class="line"> 8008248:    2b00          cmp    r3, #0</span><br><span class="line"> 800824a:    d000          beq.n    800824e &lt;_mainCRTStartup+0x2e&gt;</span><br><span class="line"> 800824c:    4798          blx    r3</span><br><span class="line"> 800824e:    2000          movs    r0, #0</span><br><span class="line"> 8008250:    2100          movs    r1, #0</span><br><span class="line"> 8008252:    0004          movs    r4, r0</span><br><span class="line"> 8008254:    000d          movs    r5, r1</span><br><span class="line"> 8008256:    480d          ldr    r0, [pc, #52]    ; (800828c &lt;_mainCRTStartup+0x6c&gt;)</span><br><span class="line"> 8008258:    2800          cmp    r0, #0</span><br><span class="line"> 800825a:    d002          beq.n    8008262 &lt;_mainCRTStartup+0x42&gt;</span><br><span class="line"> 800825c:    480c          ldr    r0, [pc, #48]    ; (8008290 &lt;_mainCRTStartup+0x70&gt;)</span><br><span class="line"> 800825e:    f00f f868     bl    8017332 &lt;__wrap_atexit&gt;</span><br><span class="line"> 8008262:    f01c f805     bl    8024270 &lt;__libc_init_array&gt;</span><br><span class="line"> 8008266:    0020          movs    r0, r4</span><br><span class="line"> 8008268:    0029          movs    r1, r5</span><br><span class="line"> 800826a:    f00f f821     bl    80172b0 &lt;__wrap_main&gt;</span><br><span class="line"> 800826e:    f00f f85d     bl    801732c &lt;__wrap_exit&gt;</span><br><span class="line"> 8008272:    bf00          nop</span><br><span class="line"> 8008274:    00080000     .word    0x00080000</span><br><span class="line"> 8008278:    20040000     .word    0x20040000</span><br><span class="line"> 800827c:    00000000     .word    0x00000000</span><br><span class="line"> 8008280:    080172a3     .word    0x080172a3</span><br><span class="line"> 8008284:    20000c00     .word    0x20000c00</span><br><span class="line"> 8008288:    2000ac58     .word    0x2000ac58</span><br><span class="line"> 800828c:    08017333     .word    0x08017333</span><br><span class="line"> 8008290:    00000000     .word    0x00000000</span><br></pre></td></tr></table></figure>

<p>提炼后的 crt0.S 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    FUNC_START  _mainCRTStartup</span><br><span class="line">    FUNC_START  _start</span><br><span class="line">&#x2F;* Start by setting up a stack *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;*  Set up the stack pointer to a fixed value *&#x2F;</span><br><span class="line">    &#x2F;*  Changes by toralf:</span><br><span class="line">        - Allow linker script to provide stack via __stack symbol - see</span><br><span class="line">          defintion of .Lstack</span><br><span class="line">        - Provide &quot;hooks&quot; that may be used by the application to add</span><br><span class="line">          custom init code - see .Lhwinit and .Lswinit  </span><br><span class="line">        - Go through all execution modes and set up stack for each of them.</span><br><span class="line">          Loosely based on init.s from ARM&#x2F;Motorola example code.</span><br><span class="line">              Note: Mode switch via CPSR is not allowed once in non-privileged</span><br><span class="line">            mode, so we take care not to enter &quot;User&quot; to set up its sp,</span><br><span class="line">            and also skip most operations if already in that mode. *&#x2F;</span><br><span class="line"></span><br><span class="line">    ldr r3, .Lstack</span><br><span class="line">    cmp r3, #0</span><br><span class="line"></span><br><span class="line">    it  eq</span><br><span class="line"></span><br><span class="line">    ldreq   r3, .LC0</span><br><span class="line">    &#x2F;* Note: This &#39;mov&#39; is essential when starting in User, and ensures we</span><br><span class="line">         always get *some* sp value for the initial mode, even if we </span><br><span class="line">         have somehow missed it below (in which case it gets the same</span><br><span class="line">         value as FIQ - not ideal, but better than nothing.) *&#x2F;</span><br><span class="line">    mov sp, r3</span><br><span class="line"></span><br><span class="line">.LC23:</span><br><span class="line">    &#x2F;* Setup a default stack-limit in-case the code has been</span><br><span class="line">       compiled with &quot;-mapcs-stack-check&quot;.  Hard-wiring this value</span><br><span class="line">       is not ideal, since there is currently no support for</span><br><span class="line">       checking that the heap and stack have not collided, or that</span><br><span class="line">       this default 64k is enough for the program being executed.</span><br><span class="line">       However, it ensures that this simple crt0 world will not</span><br><span class="line">       immediately cause an overflow event:  *&#x2F;</span><br><span class="line">    sub sl, r3, #64 &lt;&lt; 10   &#x2F;* Still assumes 256bytes below sl *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Zero the memory in the .bss section.  *&#x2F;</span><br><span class="line">    movs    a2, #0          &#x2F;* Second arg: fill value *&#x2F;</span><br><span class="line">    mov fp, a2          &#x2F;* Null frame pointer *&#x2F;</span><br><span class="line">    mov r7, a2          &#x2F;* Null frame pointer for Thumb *&#x2F;</span><br><span class="line">    </span><br><span class="line">    ldr a1, .LC1        &#x2F;* First arg: start of memory block *&#x2F;</span><br><span class="line">    ldr a3, .LC2    </span><br><span class="line">    subs    a3, a3, a1      &#x2F;* Third arg: length of block *&#x2F;</span><br><span class="line">    </span><br><span class="line">    bl  memset</span><br><span class="line"></span><br><span class="line">&#x2F;* Changes by toralf: Taken from libgloss&#x2F;m68k&#x2F;crt0.S</span><br><span class="line"> * initialize target specific stuff. Only execute these</span><br><span class="line"> * functions it they exist.</span><br><span class="line"> *&#x2F;</span><br><span class="line">    ldr r3, .Lhwinit</span><br><span class="line">    cmp r3, #0</span><br><span class="line">    beq .LC24</span><br><span class="line">    indirect_call r3</span><br><span class="line">.LC24:  </span><br><span class="line">    ldr r3, .Lswinit</span><br><span class="line">    cmp r3, #0</span><br><span class="line">    beq .LC25</span><br><span class="line">    indirect_call r3</span><br><span class="line"></span><br><span class="line">.LC25:  </span><br><span class="line">    movs    r0, #0      &#x2F;*  no arguments  *&#x2F;</span><br><span class="line">    movs    r1, #0      &#x2F;*  no argv either *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Some arm&#x2F;elf targets use the .init and .fini sections</span><br><span class="line">       to create constructors and destructors, and for these</span><br><span class="line">       targets we need to call the _init function and arrange</span><br><span class="line">       for _fini to be called at program exit.  *&#x2F;</span><br><span class="line">    movs    r4, r0</span><br><span class="line">    movs    r5, r1e</span><br><span class="line"></span><br><span class="line">    &#x2F;* Make reference to atexit weak to avoid unconditionally pulling in</span><br><span class="line">       support code.  Refer to comments in __atexit.c for more details.  *&#x2F;</span><br><span class="line">    ldr r0, .Latexit</span><br><span class="line">    cmp r0, #0</span><br><span class="line">    beq .Lweak_atexit</span><br><span class="line"></span><br><span class="line">    ldr r0, .Lfini</span><br><span class="line">    bl  atexit</span><br><span class="line">.Lweak_atexit:</span><br><span class="line">    bl  _init</span><br><span class="line">    movs    r0, r4</span><br><span class="line">    movs    r1, r5</span><br><span class="line"></span><br><span class="line">    bl  main</span><br><span class="line"></span><br><span class="line">    bl  exit        &#x2F;* Should not return.  *&#x2F;</span><br><span class="line">    </span><br><span class="line">    &#x2F;* For Thumb, constants must be after the code since only </span><br><span class="line">       positive offsets are supported for PC relative addresses.  *&#x2F;</span><br><span class="line">.LC0:</span><br><span class="line">    .word   0x80000         &#x2F;* Top of RAM on the PIE board.  *&#x2F;</span><br><span class="line">.Lstack:    </span><br><span class="line">    .word   __stack</span><br><span class="line">.Lhwinit:   </span><br><span class="line">    .word   ardware_init_hook</span><br><span class="line">.Lswinit:</span><br><span class="line">    .word   software_init_hook</span><br><span class="line"></span><br><span class="line">    &#x2F;* Set up defaults for the above variables in the form of weak symbols</span><br><span class="line">       - so that application will link correctly, and get value 0 in</span><br><span class="line">       runtime (meaning &quot;ignore setting&quot;) for the variables, when the user</span><br><span class="line">       does not provide the symbols. (The linker uses a weak symbol if,</span><br><span class="line">       and only if, a normal version of the same symbol isn&#39;t provided</span><br><span class="line">       e.g. by a linker script or another object file.) *&#x2F;  </span><br><span class="line"></span><br><span class="line">    .weak __stack</span><br><span class="line">    .weak hardware_init_hook</span><br><span class="line">    .weak software_init_hook</span><br><span class="line"></span><br><span class="line">.LC1:</span><br><span class="line">  .word __bss_start__</span><br><span class="line">.LC2:</span><br><span class="line">  .word __bss_end__</span><br><span class="line"></span><br><span class="line">  .weak atexit</span><br><span class="line">.Latexit:</span><br><span class="line">  .word atexit</span><br><span class="line"></span><br><span class="line">  &#x2F;* Weak reference _fini in case of lite exit.  *&#x2F;</span><br><span class="line">  .weak _fini</span><br><span class="line">.Lfini:</span><br><span class="line">  .word _fini</span><br></pre></td></tr></table></figure>

<p>crt0 启动流程如下：</p>
<ol>
<li>设置 SP 为 __stack，若 __stack 未被用户定义，则使用默认的值（0x80000处的值）。</li>
<li>清空 .bss 段，起始地址为 <strong>bss_start__，结束地址为 __bss_end</strong> 。</li>
<li>若用户定义了 hardware_init_hook 和 software_init_hook ，则调用它们。</li>
<li>若用户定义了 atexit，则调用它，并将传递参数 _fini（_fini 被宏定义为 __libc_fini_array）。</li>
<li>调用 _init（_ini 被宏定义为 __libc_ini_array）。</li>
<li>调用 main（argc 和 argv 都等于 0）。</li>
<li>调用 exit。</li>
</ol>
<p>其中 <strong>stack，__bss_start__ 和 __bss_end</strong> 必须被定义。</p>
<p>hardware_init_hook 和 software_init_hook 可以实现一些需要在 main 之前的功能。</p>
<p>aiexit，exit，_init 和 _fini 一般是和 C++ 的全局构造和析构有关，这个放在下一节来分析。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>pypi 镜像使用帮助</title>
    <url>/2020/12/11/Programing%20Language/Python/pypi%20%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9/</url>
    <content><![CDATA[<p>Python 默认使用国外镜像，切换到国内镜像可以大大提升速度。</p>
<a id="more"></a>

<h2 id="清华大学开源软件镜像站"><a href="#清华大学开源软件镜像站" class="headerlink" title="清华大学开源软件镜像站"></a>清华大学开源软件镜像站</h2><p>pypi 镜像每 5 分钟同步一次。</p>
<h3 id="临时使用"><a href="#临时使用" class="headerlink" title="临时使用"></a>临时使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple some-package</span><br></pre></td></tr></table></figure>

<p>注意，<code>simple</code> 不能少, 是 <code>https</code> 而不是 <code>http</code></p>
<h3 id="设为默认"><a href="#设为默认" class="headerlink" title="设为默认"></a>设为默认</h3><p>升级 pip 到最新的版本 (&gt;=10.0.0) 后进行配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pip -U</span><br><span class="line">pip config set global.index-url https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br></pre></td></tr></table></figure>

<p>如果您到 pip 默认源的网络连接较差，临时使用本镜像站来升级 pip：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple pip -U</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/">https://mirrors.tuna.tsinghua.edu.cn/help/pypi/</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>BLE spec 全部版本</title>
    <url>/2020/12/11/Wireless/BLE/BLE%20spec%20%E5%85%A8%E9%83%A8%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<p>最新版本下载：<a href="https://www.bluetooth.com/specifications/bluetooth-core-specification/">https://www.bluetooth.com/specifications/bluetooth-core-specification/</a></p>
<p>历史版本下载：<a href="https://www.bluetooth.com/specifications/archived-specifications/">https://www.bluetooth.com/specifications/archived-specifications/</a></p>
<p>PDF 列表：</p>
<ul>
<li><a href="Core_v4.0.pdf">4.0</a></li>
<li><a href="Core_v4.1.pdf">4.1</a></li>
<li><a href="Core_v4.2.pdf">4.2</a></li>
<li><a href="Core_v5.0.pdf">5.0</a></li>
<li><a href="Core_v5.1.pdf">5.1</a></li>
<li><a href="Core_v5.2.pdf">5.2</a></li>
</ul>
]]></content>
      <categories>
        <category>BLE</category>
      </categories>
  </entry>
  <entry>
    <title>BLE 最大化吞吐量</title>
    <url>/2020/12/11/Wireless/BLE/BLE%20%E6%9C%80%E5%A4%A7%E5%8C%96%E5%90%9E%E5%90%90%E9%87%8F/</url>
    <content><![CDATA[<p>Slave 通过 notification 发送 293 字节数据，ATT_MTU 为 247 字节，所以分为两次发送。</p>
<p>抓包看有三次 connection event，其中第二次 connection event 没有数据传输，这是为什么呢？</p>
<p><img src="/2020/12/11/Wireless/BLE/BLE%20%E6%9C%80%E5%A4%A7%E5%8C%96%E5%90%9E%E5%90%90%E9%87%8F/image-20201130210148848.png"></p>
<p>因为 slave 代码中调用发送 notification API 之后，要等待发送成功事件再发送下一个 notification。</p>
<p>而发送成功事件是在收到的下个 master 数据包的 NESN 后产生，此时 slave 看到 queue 中没有数据，就回复了 Empty PDU。</p>
<p>所以第三次 connection event 才将剩下的数据发送出去。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.000000	Master	Slave		35	12	-50 dBm	Sent Write Command, Handle: 0x0049 (Unknown: Unknown)</span><br><span class="line">0.000998	Slave	Master		26	12	-45 dBm	Empty PDU</span><br><span class="line">0.007012	Master	Slave		26	12	-48 dBm	Empty PDU</span><br><span class="line">0.007999	Slave	Master		26	12	-44 dBm	Empty PDU</span><br><span class="line">0.014914	Master	Slave		26	21	-49 dBm	Empty PDU</span><br><span class="line">0.015960	Slave	Master		35	21	-45 dBm	Rcvd Handle Value Notification, Handle: 0x004b (Unknown: Unknown)</span><br><span class="line">0.021647	Master	Slave		26	32	-50 dBm	Empty PDU</span><br><span class="line">0.022649	Slave	Master		26	32	-46 dBm	Empty PDU</span><br><span class="line">0.029649	Master	Slave		26	34	-52 dBm	Empty PDU</span><br><span class="line">0.030667	Slave	Master		26	34	-53 dBm	Empty PDU</span><br><span class="line">0.036895	Master	Slave		26	12	-49 dBm	Empty PDU</span><br><span class="line">0.045277	Slave	Master		277	12	-44 dBm	Rcvd Handle Value Notification, Handle: 0x004b (Unknown: Unknown)</span><br><span class="line">0.046275	Master	Slave		26	21	-49 dBm	Empty PDU</span><br><span class="line">0.047276	Slave	Master		26	21	-44 dBm	Empty PDU</span><br><span class="line">0.051274	Master	Slave		26	19	-49 dBm	Empty PDU</span><br><span class="line">0.053273	Slave	Master		82	19	-44 dBm	Rcvd Handle Value Notification, Handle: 0x004b (Unknown: Unknown)</span><br><span class="line">0.060110	Master	Slave		26	17	-48 dBm	Empty PDU</span><br><span class="line">0.060110	Slave	Master		26	17	-44 dBm	Empty PDU</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>BLE</category>
      </categories>
  </entry>
  <entry>
    <title>CLI on GATT</title>
    <url>/2020/12/11/Wireless/BLE/CLI%20on%20GATT/</url>
    <content><![CDATA[<p>利用 GATT 作为通道以实现 Command Line Interface 功能。</p>
<a id="more"></a>

<h2 id="回显延迟"><a href="#回显延迟" class="headerlink" title="回显延迟"></a>回显延迟</h2><p>设备收到一个字符后要回送此字符，称之为回显。回显速度影响和用户体验，太慢会造成卡顿的感觉。</p>
<p>根据 Core_5.2 | Vol 6, Part B, 4.5.1 Connection events，BLE connection interval 最小为 7.5ms，也即一个字符来回需要 15ms，不会造成延迟感。</p>
<blockquote>
<p>The connInterval shall be a multiple of 1.25 ms in the range 7.5 ms to 4.0 s. </p>
</blockquote>
<h2 id="Nagle-算法"><a href="#Nagle-算法" class="headerlink" title="Nagle 算法"></a>Nagle 算法</h2><p>由于 connection interval 和包头包尾的开销，payload 越长则速率越高，但让应用层来去考虑这个显然是不友好且不现实的。</p>
<p>比如要将 buf 中数据以 hex 方式输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;bufsize; i++)</span><br><span class="line">&#123;</span><br><span class="line">	cli_printf(<span class="string">&quot;%02x&quot;</span>, buf[i]);</span><br><span class="line">&#125;</span><br><span class="line">cli_printf(<span class="string">&quot;\r\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>显然会输出多次 2 字节的数据。</p>
<p>nagle 算法的思想是：<code>当收到上层的数据后，并不立即发送出去，而是稍等一会以期待可能更多的上层数据，合并后一起发送出去</code>。</p>
<p>最简单的方法就是将收到的上层数据缓存起来，有一个线程周期性的将缓存内的数据发送出去。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* API called by upper layer */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gatt_cli_send</span><span class="params">(<span class="keyword">uint8_t</span> *buf, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  write_to_cache(buf, len);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Send thread */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gatt_send_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    delay(<span class="number">10</span>);</span><br><span class="line">    len = read_from_cache(buf, bufsize);</span><br><span class="line">    gatt_send(buf, len);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分片和重组"><a href="#分片和重组" class="headerlink" title="分片和重组"></a>分片和重组</h2><p>Notification 和 Write without response 一次发送的数据长度不能超过 MTU，因此需要分片和重组机制来收发长数据包。</p>
<p>使用 SIG Mesh Proxy PDU 的分片和重组机制，数据包格式如下：</p>
<p><img src="/2020/12/11/Wireless/BLE/CLI%20on%20GATT/image-20201122134052225.png"></p>
<table>
<thead>
<tr>
<th>Filed Name</th>
<th>Size(bits)</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>SAR</td>
<td>2</td>
<td>Message segmentation and reassembly information.</td>
</tr>
<tr>
<td>Message Type</td>
<td>6</td>
<td>Type of message contained in the PDU.</td>
</tr>
<tr>
<td>Data</td>
<td>Variable</td>
<td>Full message or message segment.</td>
</tr>
</tbody></table>
<p>SAR 字段的含义如下：</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>0b00</td>
<td>Data field contains a complete message.</td>
</tr>
<tr>
<td>0b01</td>
<td>Data field contains the first segment of a message.</td>
</tr>
<tr>
<td>0b10</td>
<td>Data field contains a continuation segment of a message.</td>
</tr>
<tr>
<td>0b11</td>
<td>Data field contains the last segment of a message.</td>
</tr>
</tbody></table>
<p>Type 字段的含义如下：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>0x00</td>
<td>Command Line Interface</td>
<td>This message contain Command Line Interface characteristics.</td>
</tr>
<tr>
<td>0x01 - 0x3F</td>
<td>RFU</td>
<td>Reversed for Future Use.</td>
</tr>
</tbody></table>
<p><strong>在 CLI 中，不需要分片和重组</strong>，因为 CLI 是基于数据流的应用，它需要一个一个处理字符，并且有回车换行结束符来定帧。</p>
<h2 id="传输效率"><a href="#传输效率" class="headerlink" title="传输效率"></a>传输效率</h2><p>影响传输效率的有两个因素：</p>
<ul>
<li>ATT_MTU</li>
<li>Connection Interval</li>
</ul>
<p>根据<em>5.2 | Vol 6, Part B, 4.5.1 Connection events</em></p>
<blockquote>
<p>The connInterval shall be a multiple of 1.25 ms in the range 7.5 ms to 4.0 s.</p>
<p>The connInterval is set by the Initiator’s Link Layer in the CONNECT_IND or AUX_CONNECT_REQ PDU from the range given by the Host and can be changed using the Connection Update procedure (see Section 5.1.1) or Connection Parameters Request procedure (see Section 5.1.7).</p>
</blockquote>
<p>Connection Interval 由链路发起者（Master）设置，放在 CONNECT_IND 包中。</p>
<p><img src="/2020/12/11/Wireless/BLE/CLI%20on%20GATT/image-20201125233911750.png"></p>
<p><img src="/2020/12/11/Wireless/BLE/CLI%20on%20GATT/image-20201125235658557.png"></p>
<p>也可以在连接上后通过 Connection Update procedure 或者 Connection Parameters Request procedure 发起更新。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>无线模组一般通过串口或来调试，但已经组装到整机中的模组则很难调试。</p>
<p>比如在 VBS9010 项目中，经常需要知道一个灯的 mesh 地址，三元组，是否被重置等信息，但是目前没有方便的办法来获取。</p>
<p>GATT CLI 正是为解决这个问题，它基于 GATT 通道实现了 CLI 功能，设备端应用简单，消耗资源少，PC 端也只需要普通的串口终端即可。</p>
<p>随着 Wi-Fi&amp;BT combo 模组的推广，GATT CLI 会极大的方便整机产品的调试和生产。</p>
]]></content>
      <categories>
        <category>BLE</category>
      </categories>
  </entry>
  <entry>
    <title>Connection Update</title>
    <url>/2020/12/11/Wireless/BLE/Connection%20Update/</url>
    <content><![CDATA[<p>BLE connection upate 流程。</p>
<a id="more"></a>

<h2 id="Connection-Update-Procedure"><a href="#Connection-Update-Procedure" class="headerlink" title="Connection Update Procedure"></a>Connection Update Procedure</h2><p>根据<em>Core_4.0 | Vol 6, Part B, 5.1.1 Connection Update procedure</em></p>
<blockquote>
<p>The Link Layer parameters for a connection (<em>connInterval</em>, <em>connSlaveLatency</em> and <em>connSupervisionTimeout</em>) may be updated after entering the Connection State. The master can update the connection parameters by sending an LL_CONNECTION_UPDATE_REQ PDU. The slave shall not send this PDU; the slave may request a change to the connection parameters using the L2CAP LE signaling channel.</p>
</blockquote>
<h2 id="Connection-Parameters-Request-procedure"><a href="#Connection-Parameters-Request-procedure" class="headerlink" title="Connection Parameters Request procedure"></a>Connection Parameters Request procedure</h2><p>根据<em>Core_5.2 | Vol 6, Part B, 5.1.7 Connection Parameters Request procedure</em></p>
<blockquote>
<p>The master or slave may initiate a Connection Parameters Request procedure to request the remote device to have the Link Layer parameters for the connection (connInterval, connSlaveLatency and connSupervisionTimeout) updated any time after entering the Connection State.</p>
</blockquote>
<p>Master 和 Slave 都可以发起 Connection Parameters Request procedure。</p>
<p>发起者发送<code>LL_CONNECTION_PARAM_REQ</code>，包含 Interval_Min 和 Interval_Max。</p>
<p>对端若是 maste，则回复<code>LL_CONNECTION_UPDATE_IND</code>，若是 slave，则回复<code> LL_CONNECTION_PARAM_RSP</code>。</p>
<p>若对端不接受参数更新请求，则回复二者之一：</p>
<ul>
<li>包含了替代参数的<code>LL_CONNECTION_PARAM_RSP</code>(slave)或者<code> LL_CONNECTION_UPDATE_IND PDU</code>（master）</li>
<li><code>LL_REJECT_EXT_IND</code>，其中<code>ErrorCode</code> 设置为<code>Unsupported LL Parameter Value</code> (0x20).</li>
</ul>
<p>Slave 发送了<code>LL_CONNECTION_PARAM_REQ</code>，Interval Min = 20，Interval Max = 40，Master 在<code>LL_CONNECTION_UPDATE_REQ</code>中选择了 Interval = 40。</p>
<p><img src="/2020/12/11/Wireless/BLE/Connection%20Update/image-20201122130447407.png"></p>
<p>在<code>Zephyr</code>中<code>bt_conn_le_create</code>函数参数<code>conn_param</code>可以设置 connInterval。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** @brief Initiate an LE connection to a remote device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Allows initiate new LE link to remote peer using its address.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  The caller gets a new reference to the connection object which must be</span></span><br><span class="line"><span class="comment"> *  released with bt_conn_unref() once done using the object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This uses the General Connection Establishment procedure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param[in]  peer         Remote address.</span></span><br><span class="line"><span class="comment"> *  @param[in]  create_param Create connection parameters.</span></span><br><span class="line"><span class="comment"> *  @param[in]  conn_param   Initial connection parameters.</span></span><br><span class="line"><span class="comment"> *  @param[out] conn         Valid connection object on success.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return Zero on success or (negative) error code on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bt_conn_le_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">bt_addr_le_t</span> *peer,</span></span></span><br><span class="line"><span class="function"><span class="params">		      <span class="keyword">const</span> struct bt_conn_le_create_param *create_param,</span></span></span><br><span class="line"><span class="function"><span class="params">		      <span class="keyword">const</span> struct bt_le_conn_param *conn_param,</span></span></span><br><span class="line"><span class="function"><span class="params">		      struct bt_conn **conn)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Helper to declare connection parameters inline</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param int_min  Minimum Connection Interval (N * 1.25 ms)</span></span><br><span class="line"><span class="comment"> *  @param int_max  Maximum Connection Interval (N * 1.25 ms)</span></span><br><span class="line"><span class="comment"> *  @param lat      Connection Latency</span></span><br><span class="line"><span class="comment"> *  @param to       Supervision Timeout (N * 10 ms)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BT_LE_CONN_PARAM(int_min, int_max, lat, to) \</span></span><br><span class="line">	((struct bt_le_conn_param[]) &#123; \</span><br><span class="line">		BT_LE_CONN_PARAM_INIT(int_min, int_max, lat, to) \</span><br><span class="line">	 &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><code>Connection Update Procedure</code>和<code>Connection Parameters Request procedure</code>都实现了在连接后设置连接参数的功能(connInterval, connSlaveLatency and connSupervisionTimeout) ，那么它们有什么区别呢？</p>
<p>一开始在 BLE 4.0 中只有<code>Connection Update Procedure</code>，只能由 master 主动发起，slave 只能请求 master 发起更新，可能后来有 slave 主动发起更新的需求，又为了向后兼容，于是定义了新的<code>Connection Parameters Request procedure</code>，支持 slave 主动发起更新。</p>
]]></content>
      <categories>
        <category>BLE</category>
      </categories>
  </entry>
  <entry>
    <title>MTU exchange</title>
    <url>/2020/12/11/Wireless/BLE/MTU%20exchange/</url>
    <content><![CDATA[<p>BLE MTU exchange 流程。</p>
<a id="more"></a>

<h2 id="MTU-exchange"><a href="#MTU-exchange" class="headerlink" title="MTU exchange"></a>MTU exchange</h2><p>根据<em>Core_5.2 | Vol 3, Part G, 4.3.1</em></p>
<p>Client 通过此 sub-procedure 来发起 ATT_MTU 协商，最终选择两个设备 ATT_MTU 中较小的那个作为本次连接的 ATT_MTU。 <strong>MTU exchange 一次连接中只能启动一次</strong>。</p>
<p><img src="/2020/12/11/Wireless/BLE/MTU%20exchange/image-20201130002648285.png"></p>
<p>Client 向 server 发送<code>ATT_EXCHANGE_MTU_REQ</code>，包含自己的 MTU</p>
<p><img src="/2020/12/11/Wireless/BLE/MTU%20exchange/image-20201130002813940.png"></p>
<p>Server 会回复<code>ATT_EXCHANGE_MTU_RSP</code>，包含自己的 MTU</p>
<p><img src="/2020/12/11/Wireless/BLE/MTU%20exchange/image-20201130002908077.png"></p>
<p>在<code>Zephyr</code>中<code>bt_gatt_exchange_mtu</code>用以实现 MTU exchange 流程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** @brief Exchange MTU</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This client procedure can be used to set the MTU to the maximum possible</span></span><br><span class="line"><span class="comment"> *  size the buffers can hold.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @note Shall only be used once per connection.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param conn Connection object.</span></span><br><span class="line"><span class="comment"> *  @param params Exchange MTU parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 0 in case of success or negative value in case of error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bt_gatt_exchange_mtu</span><span class="params">(struct bt_conn *conn,</span></span></span><br><span class="line"><span class="function"><span class="params">			 struct bt_gatt_exchange_params *params)</span></span>;</span><br></pre></td></tr></table></figure>

<p>MTU 在<code>prj.conf</code>中配置，若无配置，则默认为23</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONFIG_BT_L2CAP_RX_MTU&#x3D;247</span><br><span class="line">CONFIG_BT_L2CAP_TX_MTU&#x3D;247</span><br></pre></td></tr></table></figure>

<p>若 MTU 大于 23，则还需要配置<code>Data Length Extension</code></p>
<p><img src="/2020/12/11/Wireless/BLE/MTU%20exchange/image-20201201155230522.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONFIG_BT_CTLR_DATA_LENGTH&#x3D;y</span><br><span class="line">CONFIG_BT_CTLR_DATA_LENGTH_MAX&#x3D;251</span><br></pre></td></tr></table></figure>

<h2 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h2><p>Master 发送<code>ATT_EXCHANGE_MTU_REQ</code>，Rx MTU=251。</p>
<p>Slave 回复<code>ATT_EXCHANGE_MTU_RSP</code>，Rx MTU=247。</p>
<p>最终选择 Rx MTU 为 247。</p>
<p><img src="/2020/12/11/Wireless/BLE/MTU%20exchange/image-20201130201110426.png"></p>
<p><img src="/2020/12/11/Wireless/BLE/MTU%20exchange/image-20201130201210585.png"></p>
<p>抓包数据：<a href="MTU.pcapng">MTU.pcapng</a></p>
]]></content>
      <categories>
        <category>BLE</category>
      </categories>
  </entry>
  <entry>
    <title>bluepy - Python 版的 BLE 利器</title>
    <url>/2020/12/11/Wireless/BLE/bluepy%20-%20Python%20%E7%89%88%E7%9A%84%20BLE%20%E5%88%A9%E5%99%A8/</url>
    <content><![CDATA[<p>无意间发现了一个 python 版的 BLE 利器 - <a href="https://github.com/IanHarvey/bluepy">bluepy</a>。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>bluepy 是 github 上的一个开源项目，它用 python 封装了 linux 上的 BLE 接口。</p>
<p>作者主要基于树莓派开发，也可以运行在 x86 Debian Linux 上。</p>
<p>bluepy 其实是 BlueZ 的 python 封装。</p>
<a id="more"></a>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>对于 Windows 和 macOS 用户，可以用虚拟机安装 Ubuntu（基于 Debian 系统）。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install python3-pip libglib2.0-dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo pip3 install bluepy</span></span><br></pre></td></tr></table></figure>

<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>bluepy 的<a href="http://ianharvey.github.io/bluepy-doc/#">文档</a>中的 demo 很少，所幸 github 上有个<a href="https://github.com/rlangoy/bluepy_examples_nRF51822_mbed">仓库</a>有丰富的例程，不过都是 python2，自己转了几个 python3 的例子。</p>
<p>注意：需要 root 权限来运行这些脚本。</p>
<h4 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bluepy.btle <span class="keyword">import</span> Scanner, DefaultDelegate</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScanDelegate</span>(<span class="params">DefaultDelegate</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        DefaultDelegate.__init__(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handleDiscovery</span>(<span class="params">self, dev, isNewDev, isNewData</span>):</span></span><br><span class="line">        <span class="keyword">if</span> isNewDev:</span><br><span class="line">            print(<span class="string">&quot;Discovered device&quot;</span>, dev.addr)</span><br><span class="line">        <span class="keyword">elif</span> isNewData:</span><br><span class="line">            print(<span class="string">&quot;Received new data from&quot;</span>, dev.addr)</span><br><span class="line"></span><br><span class="line">scanner = Scanner().withDelegate(ScanDelegate())</span><br><span class="line">devices = scanner.scan(<span class="number">10.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> dev <span class="keyword">in</span> devices:</span><br><span class="line">    print(<span class="string">&quot;Device %s (%s), RSSI=%d dB&quot;</span> % (dev.addr, dev.addrType, dev.rssi))</span><br><span class="line">    <span class="keyword">for</span> (adtype, desc, value) <span class="keyword">in</span> dev.getScanData():</span><br><span class="line">        print(<span class="string">&quot;  %s = %s&quot;</span> % (desc, value))</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Scanner([index=0])</code>用于产生并初始化一个新的scanner对象，index 用来指名哪一个蓝牙设备就会被用（默认0表示使用/dev/hci0）。调用start或scan函数之后开始扫描。</li>
<li><code>withDelegate(delegate)</code>存储对委托对象的引用，委托对象在接收来自设备的广播时接收回调。有关详细信息，请参阅DefaultDelegate的文档。</li>
<li><code>scan([timeout = 10])</code>开始扫描并带有扫描时间，在此扫描期间扫描到的设备会触发Delegate的回调函数，我们可以在其回调函数中实时获取并打印。当扫描结束后后会返回一个设备列表。</li>
</ul>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Discovered device 01:d1:c5:88:91:8e</span><br><span class="line">Discovered device 0d:1e:9d:f4:5a:62</span><br><span class="line">Received new data from 01:d1:c5:88:91:8e</span><br><span class="line">Discovered device 3c:32:dc:9d:24:6b</span><br><span class="line">Discovered device f4:d7:60:14:88:84</span><br><span class="line">Discovered device ab:36:be:b6:43:43</span><br><span class="line">Discovered device 96:bb:75:92:ca:8a</span><br><span class="line">Discovered device fb:ac:56:d9:44:cf</span><br><span class="line"></span><br><span class="line">Device 01:d1:c5:88:91:8e (public), RSSI&#x3D;-62 dB</span><br><span class="line">  Manufacturer &#x3D; a8010a05c90e000038d2ca307de1</span><br><span class="line">  Complete Local Name &#x3D; MeshDevice</span><br><span class="line">Device 0d:1e:9d:f4:5a:62 (public), RSSI&#x3D;-61 dB</span><br><span class="line">Device 3c:32:dc:9d:24:6b (public), RSSI&#x3D;-76 dB</span><br><span class="line">  Manufacturer &#x3D; 8f030a101c0000fa987f4f5e80ec</span><br><span class="line">Device f4:d7:60:14:88:84 (public), RSSI&#x3D;-86 dB</span><br><span class="line">  Manufacturer &#x3D; 8f030a101c0000590435ee35acec</span><br><span class="line">Device ab:36:be:b6:43:43 (public), RSSI&#x3D;-69 dB</span><br><span class="line">Device 96:bb:75:92:ca:8a (public), RSSI&#x3D;-59 dB</span><br><span class="line">Device fb:ac:56:d9:44:cf (public), RSSI&#x3D;-70 dB</span><br></pre></td></tr></table></figure>

<h4 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> bluepy.btle <span class="keyword">import</span> UUID, Peripheral</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">2</span>:</span><br><span class="line">  print(<span class="string">&quot;Fatal, must pass device address:&quot;</span>, sys.argv[<span class="number">0</span>], <span class="string">&quot;&lt;device address&gt;&quot;</span>)</span><br><span class="line">  quit()</span><br><span class="line"></span><br><span class="line">p = Peripheral(sys.argv[<span class="number">1</span>], <span class="string">&quot;public&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get all services</span></span><br><span class="line">services=p.getServices()</span><br><span class="line"><span class="keyword">for</span> service <span class="keyword">in</span> services:</span><br><span class="line">   print(service)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get all characteristics</span></span><br><span class="line">chList = p.getCharacteristics()</span><br><span class="line">print(<span class="string">&quot;Handle   UUID                                Properties&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;-------------------------------------------------------&quot;</span>)                     </span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> chList:</span><br><span class="line">   print(<span class="string">&quot;  0x&quot;</span>+ <span class="built_in">format</span>(ch.getHandle(),<span class="string">&#x27;02X&#x27;</span>)  +<span class="string">&quot;   &quot;</span>+<span class="built_in">str</span>(ch.uuid) +<span class="string">&quot; &quot;</span> + ch.propertiesToString())</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Peripheral(sys.argv[1],&quot;public&quot;)</code>是用mac地址创建一个连接，由于我们上一步用scan搜索到的mac地址为public类型，因此这里第二个参数为”public”。</li>
<li><code>getServices</code>会返回所连接设备的服务。</li>
<li><code>getCharacteristics</code>会返回所连接设备的特征值。</li>
</ul>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Service &lt;uuid&#x3D;feb3 handleStart&#x3D;1 handleEnd&#x3D;13&gt;</span><br><span class="line">Service &lt;uuid&#x3D;1828 handleStart&#x3D;14 handleEnd&#x3D;20&gt;</span><br><span class="line">Handle   UUID                                Properties</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">  0x03   0000fed4-0000-1000-8000-00805f9b34fb READ </span><br><span class="line">  0x05   0000fed5-0000-1000-8000-00805f9b34fb READ WRITE </span><br><span class="line">  0x07   0000fed6-0000-1000-8000-00805f9b34fb READ INDICATE </span><br><span class="line">  0x09   0000fed7-0000-1000-8000-00805f9b34fb READ WRITE NO RESPONSE </span><br><span class="line">  0x0B   0000fed8-0000-1000-8000-00805f9b34fb READ NOTIFY </span><br><span class="line">  0x10   00002add-0000-1000-8000-00805f9b34fb WRITE NO RESPONSE </span><br><span class="line">  0x12   00002ade-0000-1000-8000-00805f9b34fb NOTIFY</span><br></pre></td></tr></table></figure>

<h4 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h4><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>[<a href="https://www.cnblogs.com/zjutlitao/p/10171913.html">python] bluepy 一款python封装的BLE利器</a></li>
</ul>
]]></content>
      <categories>
        <category>BLE</category>
      </categories>
  </entry>
  <entry>
    <title>最大包长的变化</title>
    <url>/2020/12/11/Wireless/BLE/%E6%9C%80%E5%A4%A7%E5%8C%85%E9%95%BF%E7%9A%84%E5%8F%98%E5%8C%96/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>版本</th>
<th>ATT MTU</th>
</tr>
</thead>
<tbody><tr>
<td>4.0 - 4.1</td>
<td>23</td>
</tr>
<tr>
<td>4.2 - 5.0</td>
<td>247</td>
</tr>
<tr>
<td>5.1 - 5.2</td>
<td>248</td>
</tr>
</tbody></table>
<p>为什么不一开始就定义更大的 ATT MTU 呢，因为数据包越长则射频电路发热越严重进而导致频偏，ATT MTU 是根据当时的芯片工艺和成本来制定的。</p>
<a id="more"></a>

<p>以 4.2 为例，其 Linker Layer packet 格式如下：</p>
<p><img src="/2020/12/11/Wireless/BLE/%E6%9C%80%E5%A4%A7%E5%8C%85%E9%95%BF%E7%9A%84%E5%8F%98%E5%8C%96/image-20201201231940316.png"></p>
<p>其中 PDU 格式如下：</p>
<p><img src="/2020/12/11/Wireless/BLE/%E6%9C%80%E5%A4%A7%E5%8C%85%E9%95%BF%E7%9A%84%E5%8F%98%E5%8C%96/image-20201201232003913.png"></p>
<p>其中 Payload 就是 L2CAP，格式如下：</p>
<p><img src="/2020/12/11/Wireless/BLE/%E6%9C%80%E5%A4%A7%E5%8C%85%E9%95%BF%E7%9A%84%E5%8F%98%E5%8C%96/image-20201201220730783.png"></p>
<p>其中 Information payload 就是 ATT MTU，最大为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">257 (LL PDU) - 6 (Data Channel PDU Header + MIC) - 4 (L2CAP header) &#x3D; 247</span><br></pre></td></tr></table></figure>

<p>需要注意的是，虽然 4.0 的 Link Layer packet 中 PDU 最长为 39，按照上述计算应该是 39 - 6 - 4 = 29，但实际上是 23。</p>
<p>因为 Advertising Channel PDU 最长为 39，包含了 6 字节的 Advertising address，而 Data Channel PDU 最长为 39 - 6 = 33。</p>
<p><img src="/2020/12/11/Wireless/BLE/%E6%9C%80%E5%A4%A7%E5%8C%85%E9%95%BF%E7%9A%84%E5%8F%98%E5%8C%96/image-20201201232417478.png"></p>
]]></content>
      <categories>
        <category>BLE</category>
      </categories>
  </entry>
  <entry>
    <title>LwIP 跨线程操作 socket</title>
    <url>/2020/12/11/Network/TCPIP/LwIP/LwIP%20%E8%B7%A8%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%20socket/</url>
    <content><![CDATA[<p>LwIP 不能跨线程操作 socket，否则可能会导致系统 crash。</p>
<a id="more"></a>

<p><code>tcpip_thread</code>有一个<code>tcpip_mbox</code>用以接收应用层或底层的消息。</p>
<p>每个 socket 对应一个<code>netconn</code>，其中有一个<code>op_completed</code>信号量，用以同步在<code>tcpip_thread</code>中执行的函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netconn</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/** sem that is used to synchronously execute functions in the core context */</span></span><br><span class="line">  <span class="keyword">sys_sem_t</span> op_completed;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用<code>write/read</code>的函数会有一个局部变量<code>apimsg</code>来放执行函数和参数等信息，并通过邮箱<code>tcpip_mbox</code>发送给<code>tcipip_thread</code>，其中包含了<code>netconn</code>的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">api_msg</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/** The netconn which to process - always needed: it includes the semaphore</span></span><br><span class="line"><span class="comment">      which is used to block the application thread until the function finished. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netconn</span> *<span class="title">conn</span>;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>比如 A 线程调用 write，将自己的 apimsg(A) 的<code>指针</code>发送给<code>tcpip_mbox</code>（注意，是<code>指针</code>），然后 B 线程也调用 write，将自己的 apimsg(B) 的<code>指针</code>发送给<code>tcpip_mbox</code>，<code>tcpip_thread</code>从<code>tcpip_mbox</code>中取出<code>apimsg(A)</code>的指针，执行发送后，给出 semaphore，结果唤醒了 B 线程，B 线程的 write 函数退出后， msg_B 被释放。然后 tcipip_thread 又 pop 出 msg_B 的指针，此时 msg_B 已经内容不对了。</p>
]]></content>
      <categories>
        <category>LwIP</category>
      </categories>
  </entry>
  <entry>
    <title>Python 实用方法</title>
    <url>/2020/12/11/Programing%20Language/Python/Python%20%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>一些 Python 的实用方法整理。</p>
<a id="more"></a>

<h2 id="各种格式转换"><a href="#各种格式转换" class="headerlink" title="各种格式转换"></a>各种格式转换</h2><h3 id="39-0102-39-to-b-39-x01-x02-39"><a href="#39-0102-39-to-b-39-x01-x02-39" class="headerlink" title="&#39;0102&#39;  to  b&#39;\x01\x02&#39;"></a><code>&#39;0102&#39;</code>  to  <code>b&#39;\x01\x02&#39;</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bytes.fromhex(&#39;0102&#39;)</span><br><span class="line">b&#39;\x01\x02&#39;</span><br></pre></td></tr></table></figure>

<h3 id="b-39-x01-x02-39-to-39-0102-39"><a href="#b-39-x01-x02-39-to-39-0102-39" class="headerlink" title="b&#39;\x01\x02&#39; to &#39;0102&#39;"></a><code>b&#39;\x01\x02&#39;</code> to <code>&#39;0102&#39;</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b&#39;\x01\x02&#39;.hex()</span><br><span class="line">&#39;0102&#39;</span><br></pre></td></tr></table></figure>

<h3 id="b-39-x01-x02-39-to-1-2"><a href="#b-39-x01-x02-39-to-1-2" class="headerlink" title="b&#39;\x01\x02&#39; to [1, 2]"></a><code>b&#39;\x01\x02&#39;</code> to <code>[1, 2]</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; list(b&#39;\x01\x02&#39;)</span><br><span class="line">[1, 2]</span><br></pre></td></tr></table></figure>

<h3 id="1-2-to-b-39-x01-x02-39"><a href="#1-2-to-b-39-x01-x02-39" class="headerlink" title="[1, 2] to b&#39;\x01\x02&#39;"></a><code>[1, 2]</code> to <code>b&#39;\x01\x02&#39;</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bytes([1, 2])</span><br><span class="line">b&#39;\x01\x02&#39;</span><br></pre></td></tr></table></figure>

<h3 id="b-39-x31-x32-39-to-39-12-39"><a href="#b-39-x31-x32-39-to-39-12-39" class="headerlink" title="b&#39;\x31\x32&#39; to &#39;12&#39;"></a><code>b&#39;\x31\x32&#39;</code> to <code>&#39;12&#39;</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b&#39;\x31\x32&#39;.decode()</span><br><span class="line">&#39;12&#39;</span><br></pre></td></tr></table></figure>

<h3 id="39-12-39-to-b-39-x31-x32-39"><a href="#39-12-39-to-b-39-x31-x32-39" class="headerlink" title="&#39;12&#39; to b&#39;\x31\x32&#39;"></a><code>&#39;12&#39;</code> to <code>b&#39;\x31\x32&#39;</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;12&#39;.encode()</span><br><span class="line">b&#39;\x31\x32&#39;</span><br></pre></td></tr></table></figure>

<h3 id="0x1234-to-b-39-x12-x34-39"><a href="#0x1234-to-b-39-x12-x34-39" class="headerlink" title="0x1234 to b&#39;\x12\x34&#39;"></a><code>0x1234</code> to <code>b&#39;\x12\x34&#39;</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; struct.pack(&#39;&gt;H&#39;,0x1234)</span><br><span class="line">b&#39;\x12\x34&#39;</span><br></pre></td></tr></table></figure>

<p>或者（推荐）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 0x1234</span><br><span class="line">a.to_bytes(2, &#39;big)</span><br></pre></td></tr></table></figure>

<h3 id="b-39-x12-x34-39-to-0x1234"><a href="#b-39-x12-x34-39-to-0x1234" class="headerlink" title="b&#39;\x12\x34&#39; to 0x1234"></a><code>b&#39;\x12\x34&#39;</code> to <code>0x1234</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; struct.unpack(&#39;&gt;H&#39;, b&#39;\x12\x34&#39;)</span><br><span class="line">(4660,)</span><br></pre></td></tr></table></figure>

<p>或者（推荐）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int.from_bytes(b&#39;\x12\x34&#39;, &#39;big&#39;)</span><br></pre></td></tr></table></figure>

<h2 id="中文字符导致的错误"><a href="#中文字符导致的错误" class="headerlink" title="中文字符导致的错误"></a>中文字符导致的错误</h2><p>Python 文件中若存在中文字符，在执行过程会报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SyntaxError: Non-ASCII character &#39;\xe4&#39; in file test.py on line 2, but no encoding declared;</span><br></pre></td></tr></table></figure>

<p>Python中默认的编码格式是 ASCII 格式，在没修改编码格式时无法正确打印汉字，所以在读取中文时会报错。</p>
<p>解决方法为只要在文件开头加入<code># -*- coding: UTF-8 —</code>或者<code>#coding=utf-8</code>就行了。</p>
<h2 id="获取命令行执行结果（成功-失败）"><a href="#获取命令行执行结果（成功-失败）" class="headerlink" title="获取命令行执行结果（成功/失败）"></a>获取命令行执行结果（成功/失败）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">proc &#x3D; subprocess.Popen(&#39;ps aux&#39;, shell&#x3D;True, stdout&#x3D;subprocess.PIPE)</span><br><span class="line">ret &#x3D; proc.wait()</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<p>proc.wait() 返回 0 代表成功，返回 1 代表失败</p>
<hr>
<p>2018-04-06 更新</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>关于 wait，官网文档描述如下：</p>
<blockquote>
<p>Popen.wait(<em>timeout=None</em>)</p>
<p>Wait for child process to terminate. Set and return <a href="https://docs.python.org/3.5/library/subprocess.html#subprocess.Popen.returncode"><code>returncode</code></a> attribute.</p>
<p>If the process does not terminate after <em>timeout</em> seconds, raise a <a href="https://docs.python.org/3.5/library/subprocess.html#subprocess.TimeoutExpired"><code>TimeoutExpired</code></a> exception. It is safe to catch this exception and retry the wait.</p>
<blockquote>
<p>Note</p>
<p>This will deadlock when using <code>stdout=PIPE</code> or <code>stderr=PIPE</code> and the child process generates enough output to a pipe such that it blocks waiting for the OS pipe buffer to accept more data. Use <a href="https://docs.python.org/3.5/library/subprocess.html#subprocess.Popen.communicate"><code>Popen.communicate()</code></a> when using pipes to avoid that.</p>
</blockquote>
<blockquote>
<p>Note</p>
<p>The function is implemented using a busy loop (non-blocking call and short sleeps). Use the <a href="https://docs.python.org/3.5/library/asyncio.html#module-asyncio"><code>asyncio</code></a> module for an asynchronous wait: see <a href="https://docs.python.org/3.5/library/asyncio-subprocess.html#asyncio.create_subprocess_exec"><code>asyncio.create_subprocess_exec</code></a>.</p>
</blockquote>
</blockquote>
<p>也就是说，在 stdout/err 定向到 PIPE 后，若子进程的输出超过了 PIPE 大小，那么就会死等 PIPE 被读取，而此时我们的进程又在 wait 内轮询死等子进程结束，所以就造成了死锁。</p>
<p>wait 其实是频繁的轮询子进程结果，等于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while proc.poll() !&#x3D; None:</span><br><span class="line">	sleep(0.0001)</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/guogaoan/article/details/37034565">https://blog.csdn.net/guogaoan/article/details/37034565</a></p>
<blockquote>
<p>那死锁问题如何避免呢？官方文档里推荐使用 <code>Popen.communicate()</code>。这个方法会把输出放在内存，而不是管道里，所以这时候上限就和内存大小有关了，一般不会有问题。而且如果要获得程序返回值，可以在调用 <code>Popen.communicate()</code> 之后取 <code>Popen.returncode</code> 的值。</p>
<p>结论：如果使用 <code>subprocess.Popen</code>，就不使用 <code>Popen.wait()</code>，而使用 <code>Popen.communicate()</code> 来等待外部程序执行结束。</p>
</blockquote>
<p>wait() 方式来获取结果有个很大的问题，stdout PIPE buffer是 64K，就是当子进程打印超过时就会卡住，此时死锁就产生了，导致 wait() 始终等不到结果，所以用 communicate 最稳妥。</p>
<p>当然，如果不定向 stdou 到 PIPE，死锁就不会发生。</p>
<h3 id="读取stdout"><a href="#读取stdout" class="headerlink" title="读取stdout"></a>读取stdout</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p &#x3D; subprocess.Popen(&quot;dir&quot;, shell&#x3D;True, stdout&#x3D;subprocess.PIPE, stderr&#x3D;subprocess.STDOUT)</span><br><span class="line">while True:</span><br><span class="line">    buff &#x3D; p.stdout.readline()</span><br><span class="line">    if buff &#x3D;&#x3D; &#39;&#39; and p.poll() !&#x3D; None:</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>

<h3 id="stdout-缓冲问题"><a href="#stdout-缓冲问题" class="headerlink" title="stdout 缓冲问题"></a>stdout 缓冲问题</h3><p>2018-04-08 更新</p>
<p><a href="http://blog.sina.com.cn/s/blog_4513dde60100oql9.html">http://blog.sina.com.cn/s/blog_4513dde60100oql9.html</a></p>
<p>PP3E上说过这个问题，说一个程序如果不是以交互的方式运行的话，那么stdout这些都是完全缓冲的，即使设置bufsize也没用，可行的办法是使用pty或者在源码中使用fflush强制flush stdout。</p>
<p>2018-06-24 更新</p>
<p>使用 setbuf 函数关闭 stdout 缓冲区，即可实时输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setbuf(stdout, NULL);</span><br></pre></td></tr></table></figure>

<h2 id="subprocess-Popen-命令类型详解"><a href="#subprocess-Popen-命令类型详解" class="headerlink" title="subprocess.Popen 命令类型详解"></a>subprocess.Popen 命令类型详解</h2><p>参考：<a href="http://www.cnblogs.com/zhoug2020/p/5079407.html">python中的subprocess.Popen使用</a></p>
<p>subprocess模块定义了一个类： Popen</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class subprocess.Popen( args, </span><br><span class="line">      bufsize&#x3D;0, </span><br><span class="line">      executable&#x3D;None,</span><br><span class="line">      stdin&#x3D;None,</span><br><span class="line">      stdout&#x3D;None, </span><br><span class="line">      stderr&#x3D;None, </span><br><span class="line">      preexec_fn&#x3D;None, </span><br><span class="line">      close_fds&#x3D;False, </span><br><span class="line">      shell&#x3D;False, </span><br><span class="line">      cwd&#x3D;None, </span><br><span class="line">      env&#x3D;None, </span><br><span class="line">      universal_newlines&#x3D;False, </span><br><span class="line">      startupinfo&#x3D;None, </span><br><span class="line">      creationflags&#x3D;0)</span><br></pre></td></tr></table></figure>

<p>args参数。可以是一个字符串，可以是一个包含程序参数的列表。要执行的程序一般就是这个列表的第一项，或者是字符串本身。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subprocess.Popen([&quot;cat&quot;,&quot;test.txt&quot;])</span><br><span class="line">subprocess.Popen(&quot;cat test.txt&quot;)</span><br></pre></td></tr></table></figure>

<p>这两个之中，后者将不会工作。因为如果是一个字符串的话，必须是程序的路径才可以。(考虑unix的api函数exec，接受的是字符串<br>列表)</p>
<p>但是下面的可以工作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subprocess.Popen(&quot;cat test.txt&quot;, shell&#x3D;True)</span><br></pre></td></tr></table></figure>

<p>这是因为它相当于<br>subprocess.Popen([“/bin/sh”, “-c”, “cat test.txt”])<br>在*nix下，当shell=False（默认）时，Popen使用os.execvp()来执行子程序。args一般要是一个【列表】。如果args是个字符串的<br>话，会被当做是可执行文件的路径，这样就不能传入任何参数了。</p>
<p>在Windows下，下面的却又是可以工作的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subprocess.Popen([&quot;notepad.exe&quot;, &quot;test.txt&quot;])</span><br><span class="line">subprocess.Popen(&quot;notepad.exe test.txt&quot;)</span><br></pre></td></tr></table></figure>

<p>这是由于windows下的api函数CreateProcess接受的是一个字符串。即使是列表形式的参数，也需要先合并成字符串再传递给api函数<br><code>subprocess.Popen(&quot;notepad.exe test.txt&quot; shell=True)</code><br>等同于<br><code>subprocess.Popen(&quot;cmd.exe /C &quot;+&quot;notepad.exe test.txt&quot; shell=True</code></p>
<h2 id="subprocess-run"><a href="#subprocess-run" class="headerlink" title="subprocess.run"></a>subprocess.run</h2><p>官方推荐尽量使用 run 方法，如果需要更底层的才使用 Popen</p>
<p><a href="https://docs.python.org/3.5/library/subprocess.html#subprocess.run">https://docs.python.org/3.5/library/subprocess.html#subprocess.run</a></p>
<blockquote>
<p>The recommended approach to invoking subprocesses is to use the <a href="https://docs.python.org/3.5/library/subprocess.html#subprocess.run"><code>run()</code></a> function for all use cases it can handle. For more advanced use cases, the underlying <a href="https://docs.python.org/3.5/library/subprocess.html#subprocess.Popen"><code>Popen</code></a> interface can be used directly.</p>
</blockquote>
<p>其实 run 是对 Popen 和 communicate 以及结果检查的封装</p>
<h2 id="遍历文件夹-os-walk"><a href="#遍历文件夹-os-walk" class="headerlink" title="遍历文件夹 - os.walk"></a>遍历文件夹 - os.walk</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (root,dirs,files) in os.walk(&#39;firmware&#39;):</span><br><span class="line">	print(root, dirs, files)</span><br></pre></td></tr></table></figure>

<h2 id="使用国内源来-pip-install"><a href="#使用国内源来-pip-install" class="headerlink" title="使用国内源来 pip install"></a>使用国内源来 pip install</h2><p><a href="https://www.cnblogs.com/microman/p/6107879.html">https://www.cnblogs.com/microman/p/6107879.html</a></p>
<p>pip install 默认使用国外源来安装库，但有时奇慢无比，切换到国内源会快很多。</p>
<p>国内源：</p>
<p>新版ubuntu要求使用https源，要注意。</p>
<p>清华：<a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<p>阿里云：<a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a></p>
<p>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a></p>
<p>华中理工大学：<a href="http://pypi.hustunique.com/">http://pypi.hustunique.com/</a></p>
<p>山东理工大学：<a href="http://pypi.sdutlinux.org/">http://pypi.sdutlinux.org/</a> </p>
<p>豆瓣：<a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a></p>
<p>临时使用：</p>
<p>可以在使用pip的时候加参数-i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a><br>例如：pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> pyspider，这样就会从清华这边的镜像去安装pyspider库。</p>
<p>永久修改：</p>
<p>Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host&#x3D;mirrors.aliyun.com</span><br></pre></td></tr></table></figure>

<p>windows下，直接在user目录中创建一个pip目录，如：C:\Users\xx\pip，新建文件pip.ini。内容同上。</p>
<h2 id="用-pyinstaller-打包-python-脚本到可执行文件"><a href="#用-pyinstaller-打包-python-脚本到可执行文件" class="headerlink" title="用 pyinstaller 打包 python 脚本到可执行文件"></a>用 pyinstaller 打包 python 脚本到可执行文件</h2><p><a href="https://jingyan.baidu.com/article/a378c960b47034b3282830bb.html">https://jingyan.baidu.com/article/a378c960b47034b3282830bb.html</a></p>
<p>安装 pyinstaller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install pyinstaller</span><br></pre></td></tr></table></figure>

<p>打包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyinstaller -F your.py</span><br></pre></td></tr></table></figure>

<p><strong>注意：用 -D 来打包到一个目录，运行速度会比 -F 打包到一个 .exe 快。</strong></p>
<h2 id="用-spec-files-打包"><a href="#用-spec-files-打包" class="headerlink" title="用 spec files 打包"></a>用 spec files 打包</h2><p><a href="https://pyinstaller.readthedocs.io/en/v3.3.1/spec-files.html">https://pyinstaller.readthedocs.io/en/v3.3.1/spec-files.html</a></p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyinstaller master.spec</span><br></pre></td></tr></table></figure>

<h2 id="打包资源文件"><a href="#打包资源文件" class="headerlink" title="打包资源文件"></a>打包资源文件</h2><p><a href="https://pythonhosted.org/PyInstaller/runtime-information.html#run-time-information">https://pythonhosted.org/PyInstaller/runtime-information.html#run-time-information</a></p>
<p><a href="https://pythonhosted.org/PyInstaller/operating-mode.html#how-the-one-file-program-works">https://pythonhosted.org/PyInstaller/operating-mode.html#how-the-one-file-program-works</a></p>
<p>有时需要打包一些资源文件，比如图片，音乐，或者可执行文件，需要用 —add-data 选项。</p>
<p>需要注意的是，打包后的可执行文件的工作原理其实是在 /tmp 目录下创建了临时工作文件夹 __MEI<em>xxxxxx</em> ，</p>
<p>资源文件都是放在此文件夹内的，所以脚本中使用资源文件就必须使用此临时文件夹的路径：<code>sys._MEIPASS</code></p>
<h2 id="Pyinstaller-和-import"><a href="#Pyinstaller-和-import" class="headerlink" title="Pyinstaller 和 __import__"></a>Pyinstaller 和 __import__</h2><p><code>__import__</code>可以动态导入模块，在用 pyinstaller 打包时，要把所有可能被导入的模块用 –hidden-import 选项加入进去，否则打包的程序运行时会找不到这些模块。</p>
<h2 id="pip-查看已经安装的包及路径"><a href="#pip-查看已经安装的包及路径" class="headerlink" title="pip 查看已经安装的包及路径"></a>pip 查看已经安装的包及路径</h2><p><a href="http://me.iblogc.com/2015/01/01/pip%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">pip常用命令</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">显示包所在的目录</span><br><span class="line"></span><br><span class="line">pip show -f &lt;包名&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Pycharm-PyQt5-Qt5-开发"><a href="#Pycharm-PyQt5-Qt5-开发" class="headerlink" title="Pycharm + PyQt5 + Qt5 开发"></a>Pycharm + PyQt5 + Qt5 开发</h2><h3 id="安装-pyqt5"><a href="#安装-pyqt5" class="headerlink" title="安装 pyqt5"></a>安装 pyqt5</h3><p><a href="https://www.zhihu.com/question/51562598">https://www.zhihu.com/question/51562598</a></p>
<p>用 pip 来安装 pyqt5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install pyqt5</span><br></pre></td></tr></table></figure>

<h3 id="安装-Qt5"><a href="#安装-Qt5" class="headerlink" title="安装 Qt5"></a>安装 Qt5</h3><p><a href="http://download.qt.io/official_releases/qt/">http://download.qt.io/official_releases/qt/</a></p>
<p>下载 5.10.1 版本</p>
<h3 id="配置-PyCharm"><a href="#配置-PyCharm" class="headerlink" title="配置 PyCharm"></a>配置 PyCharm</h3><p><a href="http://gavinliu.cn/2016/01/17/Python-Mac%E4%B8%8BPyCharm-PyQt5%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">Python - Mac下PyQt5环境搭建</a></p>
<h3 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h3><p><a href="https://blog.csdn.net/zhulove86/article/details/52530214">https://blog.csdn.net/zhulove86/article/details/52530214</a></p>
<p><a href="https://blog.csdn.net/a359680405/article/details/45148717">https://blog.csdn.net/a359680405/article/details/45148717</a></p>
<h3 id="子线程操作-UI"><a href="#子线程操作-UI" class="headerlink" title="子线程操作 UI"></a>子线程操作 UI</h3><p><a href="https://www.zhihu.com/question/37334646">为什么大多数程序子线程都不能刷新UI？</a></p>
<p><a href="https://blog.csdn.net/AhdaiMolly/article/details/74376525">https://blog.csdn.net/AhdaiMolly/article/details/74376525</a></p>
<p><a href="https://www.2cto.com/kf/201703/608163.html">https://www.2cto.com/kf/201703/608163.html</a></p>
<p><a href="https://www.v2ex.com/t/346882">https://www.v2ex.com/t/346882</a></p>
<blockquote>
<p>signal = pyqtSignal(str)<br>signal.connect(update) # Main thread<br>signal.emit(value) # sub thread</p>
</blockquote>
<p>UI 线程和 worker 线程之间只能通过 signal 来通信</p>
<p>worker 线程通过 emit signal 来操作 UI。</p>
<p>UI 线程通过 signal connect 的函数来实现回调。</p>
<h3 id="去除标题栏"><a href="#去除标题栏" class="headerlink" title="去除标题栏"></a>去除标题栏</h3><p><a href="https://www.cnblogs.com/codeAB/p/5019439.html">https://www.cnblogs.com/codeAB/p/5019439.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QWidget.setWindowFlags(Qt.FramelessWindowHint)</span><br></pre></td></tr></table></figure>

<h3 id="全屏"><a href="#全屏" class="headerlink" title="全屏"></a>全屏</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QWidget.showFullScreen()</span><br></pre></td></tr></table></figure>

<h3 id="BOX-layout-和-Grid-layout"><a href="#BOX-layout-和-Grid-layout" class="headerlink" title="BOX layout 和 Grid layout"></a>BOX layout 和 Grid layout</h3><h3 id="QThread"><a href="#QThread" class="headerlink" title="QThread"></a>QThread</h3><p>最好不要用 QThread</p>
<p><a href="http://hgoldfish.com/blogs/article/80/">http://hgoldfish.com/blogs/article/80/</a></p>
<p><a href="http://www.hgoldfish.com/blogs/article/97/">http://www.hgoldfish.com/blogs/article/97/</a></p>
<h3 id="Progress-bar"><a href="#Progress-bar" class="headerlink" title="Progress bar"></a>Progress bar</h3><p>Progress bar 的高度是由字体决定的</p>
<h3 id="鼠标双击事件"><a href="#鼠标双击事件" class="headerlink" title="鼠标双击事件"></a>鼠标双击事件</h3><p><a href="https://blog.csdn.net/dxt1107/article/details/47806965">https://blog.csdn.net/dxt1107/article/details/47806965</a></p>
<p>为了响应双击QLabel的事件，需要重写QWidget的mouseDoubleClickEvent方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from PyQt4.QtGui import *</span><br><span class="line">from PyQt4.QtCore import *</span><br><span class="line">from PyQt4 import *</span><br><span class="line">class MyLabel(QtGui.QLabel):</span><br><span class="line">    def __init__(self,parent&#x3D;None):</span><br><span class="line">        super(MyLabel,self).__init__(parent)</span><br><span class="line">    def mouseDoubleClickEvent(self,e):</span><br><span class="line">        print &#39;mouse double clicked&#39;   </span><br><span class="line">    def mousePressEvent(self,e):</span><br><span class="line">        print &#39;mousePressEvent&#39;</span><br><span class="line">    def focusInEvent(self,e):</span><br><span class="line">        print &#39;focusInEvent&#39;</span><br><span class="line">    def focusOutEvent(self,e):</span><br><span class="line">        print &#39;focusOutEvent&#39;</span><br><span class="line">    def moveEvent(self,e):</span><br><span class="line">        print &#39;moveEvent&#39;</span><br><span class="line">    def leaveEvent(self,e): #鼠标离开label</span><br><span class="line">        print &#39;leaveEvent&#39;</span><br><span class="line">    def enterEvent(self,e): #鼠标移入label</span><br><span class="line">        print &#39;enterEvent&#39;</span><br><span class="line">    def mouseMoveEvent(self,e):</span><br><span class="line">        print &#39;mouseMoveEvent&#39;</span><br><span class="line"> </span><br><span class="line">class TestDialog(QtGui.QDialog):</span><br><span class="line">    def __init__(self,parent&#x3D;None):</span><br><span class="line">        super(TestDialog,self).__init__(parent)</span><br><span class="line">        self.statusLabel &#x3D; MyLabel(self)</span><br><span class="line">        self.statusLabel.setGeometry(QtCore.QRect(95, 220, 151, 41))</span><br><span class="line">        self.statusLabel.setText(&quot;hello label&quot;)</span><br><span class="line"> </span><br><span class="line">app&#x3D;QApplication(sys.argv)</span><br><span class="line">dialog&#x3D;TestDialog()</span><br><span class="line">dialog.show()</span><br></pre></td></tr></table></figure>

<h3 id="PyQt5-Qt-designer-开发"><a href="#PyQt5-Qt-designer-开发" class="headerlink" title="PyQt5 + Qt designer 开发"></a>PyQt5 + Qt designer 开发</h3><p><a href="https://blog.csdn.net/chlk118/article/details/72595325">https://blog.csdn.net/chlk118/article/details/72595325</a></p>
<p><a href="https://blog.csdn.net/yy123xiang/article/details/78681669">https://blog.csdn.net/yy123xiang/article/details/78681669</a></p>
<p>用 Qt designer 生成的 .ui 文件，无需转换成 .py 文件，可以直接用 PyQt5.uic.loadUi 方法来加载。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import QApplication, QMainWindow</span><br><span class="line">from PyQt5.uic import loadUi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MainWindow(QMainWindow):</span><br><span class="line">    def __init__(self, parent&#x3D;None):</span><br><span class="line">        super(MainWindow, self).__init__(parent)</span><br><span class="line">        loadUi(&#39;pyflashloader_isp.ui&#39;, self)</span><br><span class="line">        self.setFixedSize(self.sizeHint())</span><br><span class="line"></span><br><span class="line">app &#x3D; QApplication(sys.argv)</span><br><span class="line">w &#x3D; MainWindow()</span><br><span class="line">w.show()</span><br><span class="line">sys.exit(app.exec())</span><br></pre></td></tr></table></figure>

<h3 id="文件打开保存框"><a href="#文件打开保存框" class="headerlink" title="文件打开保存框"></a>文件打开保存框</h3><p><a href="https://blog.csdn.net/a359680405/article/details/45166271">https://blog.csdn.net/a359680405/article/details/45166271</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from PyQt5 import QtWidgets</span><br><span class="line">from PyQt5.QtWidgets import QFileDialog</span><br><span class="line"></span><br><span class="line">class MyWindow(QtWidgets.QWidget):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(MyWindow,self).__init__()</span><br><span class="line">        self.myButton &#x3D; QtWidgets.QPushButton(self)</span><br><span class="line">        self.myButton.setObjectName(&quot;myButton&quot;)</span><br><span class="line">        self.myButton.setText(&quot;Test&quot;)</span><br><span class="line">        self.myButton.clicked.connect(self.msg)</span><br><span class="line"></span><br><span class="line">    def msg(self):</span><br><span class="line">        directory1 &#x3D; QFileDialog.getExistingDirectory(self,</span><br><span class="line">                                    &quot;选取文件夹&quot;,</span><br><span class="line">                                    &quot;C:&#x2F;&quot;)                                 #起始路径</span><br><span class="line">        print(directory1)</span><br><span class="line"></span><br><span class="line">        fileName1, filetype &#x3D; QFileDialog.getOpenFileName(self,</span><br><span class="line">                                    &quot;选取文件&quot;,</span><br><span class="line">                                    &quot;C:&#x2F;&quot;,</span><br><span class="line">                                    &quot;All Files (*);;Text Files (*.txt)&quot;)   #设置文件扩展名过滤,注意用双分号间隔</span><br><span class="line">        print(fileName1,filetype)</span><br><span class="line"></span><br><span class="line">        files, ok1 &#x3D; QFileDialog.getOpenFileNames(self,</span><br><span class="line">                                    &quot;多文件选择&quot;,</span><br><span class="line">                                    &quot;C:&#x2F;&quot;,</span><br><span class="line">                                    &quot;All Files (*);;Text Files (*.txt)&quot;)</span><br><span class="line">        print(files,ok1)</span><br><span class="line"></span><br><span class="line">        fileName2, ok2 &#x3D; QFileDialog.getSaveFileName(self,</span><br><span class="line">                                    &quot;文件保存&quot;,</span><br><span class="line">                                    &quot;C:&#x2F;&quot;,</span><br><span class="line">                                    &quot;All Files (*);;Text Files (*.txt)&quot;)</span><br><span class="line"></span><br><span class="line">if __name__&#x3D;&#x3D;&quot;__main__&quot;:  </span><br><span class="line">    import sys  </span><br><span class="line">  </span><br><span class="line">    app&#x3D;QtWidgets.QApplication(sys.argv)  </span><br><span class="line">    myshow&#x3D;MyWindow()</span><br><span class="line">    myshow.show()</span><br><span class="line">    sys.exit(app.exec_())  </span><br></pre></td></tr></table></figure>

<h3 id="QWidget-背景透明"><a href="#QWidget-背景透明" class="headerlink" title="QWidget 背景透明"></a>QWidget 背景透明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.setWindowFlag(Qt.FramelessWindowHint)</span><br><span class="line">self.setStyleSheet(&#39;background_color:rgba(255,255,255,128)&#39;)</span><br></pre></td></tr></table></figure>

<p>其中 FramelessWindowHint 是必须的，没有这个 Flag，背景就不是透明的。</p>
<h3 id="PushButton-对齐边界"><a href="#PushButton-对齐边界" class="headerlink" title="PushButton 对齐边界"></a>PushButton 对齐边界</h3><p>PushButton 比较奇怪，放在布局内也会超出一截造成不对齐，所以要单独放在一个布局内，再放入布局内。</p>
<p>比如，先把 pushbutton 放在 vertical layout 内，然后再放在 Grid layout 内，就边界对齐了。</p>
<h2 id="获取本机-MAC-地址"><a href="#获取本机-MAC-地址" class="headerlink" title="获取本机 MAC 地址"></a>获取本机 MAC 地址</h2><p><a href="https://www.cnblogs.com/chenjingyi/p/5741742.html">https://www.cnblogs.com/chenjingyi/p/5741742.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import uuid</span><br><span class="line">def get_mac_address(): </span><br><span class="line">    mac&#x3D;uuid.UUID(int &#x3D; uuid.getnode()).hex[-12:] </span><br><span class="line">    return &quot;:&quot;.join([mac[e:e+2] for e in range(0,11,2)])</span><br></pre></td></tr></table></figure>

<p>需要注意的是，多网卡的机器，此方法返回的 MAC 可能不是固定的。</p>
<h2 id="AES-加密"><a href="#AES-加密" class="headerlink" title="AES 加密"></a>AES 加密</h2><p>安装 Crypto 库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install pycrypto</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/nurke/article/details/77267081">https://blog.csdn.net/nurke/article/details/77267081</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding: utf8</span><br><span class="line">import sys</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">from binascii import b2a_hex, a2b_hex</span><br><span class="line"> </span><br><span class="line">class prpcrypt():</span><br><span class="line">    def __init__(self, key):</span><br><span class="line">        self.key &#x3D; key</span><br><span class="line">        self.mode &#x3D; AES.MODE_CBC</span><br><span class="line">     </span><br><span class="line">    #加密函数，如果text不是16的倍数【加密文本text必须为16的倍数！】，那就补足为16的倍数</span><br><span class="line">    def encrypt(self, text):</span><br><span class="line">        cryptor &#x3D; AES.new(self.key, self.mode, self.key)</span><br><span class="line">        #这里密钥key 长度必须为16（AES-128）、24（AES-192）、或32（AES-256）Bytes 长度.目前AES-128足够用</span><br><span class="line">        length &#x3D; 16</span><br><span class="line">        count &#x3D; len(text)</span><br><span class="line">	if(count % length !&#x3D; 0) :</span><br><span class="line">        	add &#x3D; length - (count % length)</span><br><span class="line">	else:</span><br><span class="line">		add &#x3D; 0</span><br><span class="line">        text &#x3D; text + (&#39;\0&#39; * add)</span><br><span class="line">        self.ciphertext &#x3D; cryptor.encrypt(text)</span><br><span class="line">        #因为AES加密时候得到的字符串不一定是ascii字符集的，输出到终端或者保存时候可能存在问题</span><br><span class="line">        #所以这里统一把加密后的字符串转化为16进制字符串</span><br><span class="line">        return b2a_hex(self.ciphertext)</span><br><span class="line">     </span><br><span class="line">    #解密后，去掉补足的空格用strip() 去掉</span><br><span class="line">    def decrypt(self, text):</span><br><span class="line">        cryptor &#x3D; AES.new(self.key, self.mode, self.key)</span><br><span class="line">        plain_text &#x3D; cryptor.decrypt(a2b_hex(text))</span><br><span class="line">        return plain_text.rstrip(&#39;\0&#39;)</span><br><span class="line"> </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    pc &#x3D; prpcrypt(&#39;keyskeyskeyskeys&#39;)      #初始化密钥</span><br><span class="line">    e &#x3D; pc.encrypt(&quot;0123456789ABCDEF&quot;)</span><br><span class="line">    d &#x3D; pc.decrypt(e)                     </span><br><span class="line">    print e, d</span><br><span class="line">    e &#x3D; pc.encrypt(&quot;00000000000000000000000000&quot;)</span><br><span class="line">    d &#x3D; pc.decrypt(e)                  </span><br><span class="line">    print e, d</span><br></pre></td></tr></table></figure>

<h2 id="HASH-算法"><a href="#HASH-算法" class="headerlink" title="HASH 算法"></a>HASH 算法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import hashlib</span><br><span class="line">&gt;&gt;&gt; hashlib.sha256(&#39;123456789&#39;.encode()).hexdigest()</span><br><span class="line">&#39;15e2b0d3c33891ebb0f1ef609ec419420c20e320ce94c65fbc8c3312448eb225&#39;</span><br></pre></td></tr></table></figure>

<h2 id="程序退出-sys-exit-status"><a href="#程序退出-sys-exit-status" class="headerlink" title="程序退出 sys.exit(status)"></a>程序退出 sys.exit(status)</h2><p><a href="https://www.cnblogs.com/weiman3389/p/6047062.html">https://www.cnblogs.com/weiman3389/p/6047062.html</a></p>
<p>sys.exit(status) 的参数 status 就是此代码的执行结果，可以用 subprocess 来捕捉。</p>
<h2 id="移动-删除文件"><a href="#移动-删除文件" class="headerlink" title="移动/删除文件"></a>移动/删除文件</h2><p><a href="https://blog.csdn.net/woshisangsang/article/details/74360612">https://blog.csdn.net/woshisangsang/article/details/74360612</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#文件、文件夹的移动、复制、删除、重命名</span><br><span class="line"></span><br><span class="line">#导入shutil模块和os模块</span><br><span class="line">import shutil,os</span><br><span class="line"></span><br><span class="line">#复制单个文件</span><br><span class="line">shutil.copy(&quot;C:\\a\\1.txt&quot;,&quot;C:\\b&quot;)</span><br><span class="line">#复制并重命名新文件</span><br><span class="line">shutil.copy(&quot;C:\\a\\2.txt&quot;,&quot;C:\\b\\121.txt&quot;)</span><br><span class="line">#复制整个目录(备份)</span><br><span class="line">shutil.copytree(&quot;C:\\a&quot;,&quot;C:\\b\\new_a&quot;)</span><br><span class="line"></span><br><span class="line">#删除文件</span><br><span class="line">os.unlink(&quot;C:\\b\\1.txt&quot;)</span><br><span class="line">os.unlink(&quot;C:\\b\\121.txt&quot;)</span><br><span class="line">#删除空文件夹</span><br><span class="line">try:</span><br><span class="line">    os.rmdir(&quot;C:\\b\\new_a&quot;)</span><br><span class="line">except Exception as ex:</span><br><span class="line">    print(&quot;错误信息：&quot;+str(ex))#提示：错误信息，目录不是空的</span><br><span class="line">#删除文件夹及内容</span><br><span class="line">shutil.rmtree(&quot;C:\\b\\new_a&quot;)</span><br><span class="line"></span><br><span class="line">#移动文件</span><br><span class="line">shutil.move(&quot;C:\\a\\1.txt&quot;,&quot;C:\\b&quot;)</span><br><span class="line">#移动文件夹</span><br><span class="line">shutil.move(&quot;C:\\a\\c&quot;,&quot;C:\\b&quot;)</span><br><span class="line"></span><br><span class="line">#重命名文件</span><br><span class="line">shutil.move(&quot;C:\\a\\2.txt&quot;,&quot;C:\\a\\new2.txt&quot;)</span><br><span class="line">#重命名文件夹</span><br><span class="line">shutil.move(&quot;C:\\a\\d&quot;,&quot;C:\\a\\new_d&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="threading"><a href="#threading" class="headerlink" title="threading"></a>threading</h2><p>daemon</p>
<p><a href="https://www.cnblogs.com/xfiver/p/5189732.html">https://www.cnblogs.com/xfiver/p/5189732.html</a></p>
<h2 id="获取本机-IP-地址"><a href="#获取本机-IP-地址" class="headerlink" title="获取本机 IP 地址"></a>获取本机 IP 地址</h2><p><a href="https://blog.csdn.net/weixin_40539892/article/details/79103254">https://blog.csdn.net/weixin_40539892/article/details/79103254</a></p>
<p>这个方法是目前见过最优雅获取本机服务器的IP方法了。没有任何的依赖，也没有去猜测机器上的网络设备信息。</p>
<p>而且是利用 UDP 协议来实现的，生成一个UDP包，把自己的 IP 放如到 UDP 协议头中，然后从UDP包中获取本机的IP。</p>
<p>这个方法并不会真实的向外部发包，所以用抓包工具是看不到的。但是会申请一个 UDP 的端口，所以如果经常调用也会比较耗时的，这里如果需要可以将查询到的IP给缓存起来，性能可以获得很大提升。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在 shell 中可以一行调用，获取到本机IP</span><br><span class="line">python -c &quot;import socket;print([(s.connect((&#39;8.8.8.8&#39;, 53)), s.getsockname()[0], s.close()) for s in [socket.socket(socket.AF_INET, socket.SOCK_DGRAM)]][0][1])&quot;</span><br><span class="line">10.12.189.16</span><br><span class="line"># 可以封装成函数，方便 Python 的程序调用</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line">def get_host_ip():</span><br><span class="line">    try:</span><br><span class="line">        s &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">        s.connect((&#39;8.8.8.8&#39;, 80))</span><br><span class="line">        ip &#x3D; s.getsockname()[0]</span><br><span class="line">    finally:</span><br><span class="line">        s.close()</span><br><span class="line"></span><br><span class="line">    return ip</span><br></pre></td></tr></table></figure>
<h2 id="requests-加了-timeout-为啥还是会卡住？"><a href="#requests-加了-timeout-为啥还是会卡住？" class="headerlink" title="requests 加了 timeout 为啥还是会卡住？"></a>requests 加了 timeout 为啥还是会卡住？</h2><p><a href="https://www.v2ex.com/amp/t/365351">https://www.v2ex.com/amp/t/365351</a></p>
<blockquote>
<p>conn = request.urlopen(image_url,timeout=300)</p>
<p>请问有啥优化的办法么？</p>
<p>爬虫爬了 24 小时卡住了。。 重启启动以后又继续爬了</p>
<hr>
<p>requests 文档上有写<br>Note<br>timeout is not a time limit on the entire response download; rather, an exception is raised if the server has not issued a response for timeout seconds (more precisely, if no bytes have been received on the underlying socket for timeout seconds). If no timeout is specified explicitly, requests do not time out. </p>
<p>在最开始加一个<br>import socket<br>socket.setdefaulttimeout(时间)<br>就可以了</p>
</blockquote>
<h2 id="Python脚本生成的exe文件自动升级程序实现方法"><a href="#Python脚本生成的exe文件自动升级程序实现方法" class="headerlink" title="Python脚本生成的exe文件自动升级程序实现方法"></a>Python脚本生成的exe文件自动升级程序实现方法</h2><p><a href="https://blog.csdn.net/u013193899/article/details/78686039">https://blog.csdn.net/u013193899/article/details/78686039</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">import subprocess </span><br><span class="line"></span><br><span class="line">#编写bat脚本，删除旧程序，运行新程序</span><br><span class="line">def WriteRestartCmd(exe_name):</span><br><span class="line">    b &#x3D; open(&quot;upgrade.bat&quot;,&#39;w&#39;)</span><br><span class="line">    TempList &#x3D; &quot;@echo off\n&quot;;   #关闭bat脚本的输出</span><br><span class="line">    TempList +&#x3D; &quot;if not exist &quot;+exe_name+&quot; exit \n&quot;;    #新文件不存在,退出脚本执行</span><br><span class="line">    TempList +&#x3D; &quot;sleep 3\n&quot; #3秒后删除旧程序（3秒后程序已运行结束，不延时的话，会提示被占用，无法删除）</span><br><span class="line">    TempList +&#x3D; &quot;del &quot;+ os.path.realpath(sys.argv[0]) + &quot;\n&quot;    #删除当前文件</span><br><span class="line">    TempList +&#x3D; &quot;start &quot; + exe_name     #启动新程序</span><br><span class="line">    b.write(TempList)</span><br><span class="line">    b.close()</span><br><span class="line">    subprocess.Popen(&quot;upgrade.bat&quot;)</span><br><span class="line">    sys.exit()  #进行升级，退出此程序</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">#新程序启动时，删除旧程序制造的脚本</span><br><span class="line">    if os.path.isfile(&quot;upgrade.bat&quot;):</span><br><span class="line">        os.remove(&quot;upgrade.bat&quot;)</span><br><span class="line">    WriteRestartCmd(&quot;newVersion.exe&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br><span class="line">    sys.exit()1234567891011121314151617181920212223242526</span><br></pre></td></tr></table></figure>

<p>代码中不使用os.system()是因为 这个函数会阻塞，等待bat脚本操作完成后，才会继续执行。不适合此处场景</p>
<h2 id="搭建-Flask-服务系统"><a href="#搭建-Flask-服务系统" class="headerlink" title="搭建 Flask 服务系统"></a>搭建 Flask 服务系统</h2><p>pip3 install 安装如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flask&#x3D;&#x3D;0.12.2</span><br><span class="line">Flask-Migrate&#x3D;&#x3D;2.1.1</span><br><span class="line">Flask-Script&#x3D;&#x3D;2.0.6</span><br><span class="line">Flask-SQLAlchemy&#x3D;&#x3D;2.3.2</span><br><span class="line">Flask-Uploads&#x3D;&#x3D;0.2.1</span><br><span class="line">Flask-WTF&#x3D;&#x3D;0.14.2</span><br></pre></td></tr></table></figure>

<h2 id="stdout-缓冲区问题"><a href="#stdout-缓冲区问题" class="headerlink" title="stdout 缓冲区问题"></a>stdout 缓冲区问题</h2><p>有时候 print 并不能实时打印出来，这时有两种方法：</p>
<ol>
<li><p>在 print 后加 sys.stdout.flush()</p>
</li>
<li><p>加个 python 选项 -u</p>
<p><strong>-u **Force stdin, stdout and stderr to be totally **unbuffered</strong>.  On systems where it matters, also put stdin,  stdout  and  stderr  in</p>
</li>
</ol>
<p><a href="https://blog.csdn.net/joeblackzqq/article/details/7220009">https://blog.csdn.net/joeblackzqq/article/details/7220009</a></p>
<p>使用 Pyinstaller 打包时，可以在 .spec 的 options 内加入 -u 选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">options &#x3D; [ (&#39;u&#39;, None, &#39;OPTION&#39;), ]</span><br></pre></td></tr></table></figure>

<p><a href="http://pyinstaller.readthedocs.io/en/v3.3.1/spec-files.html?highlight=-u">http://pyinstaller.readthedocs.io/en/v3.3.1/spec-files.html?highlight=-u</a></p>
<h2 id="Python-中-SSH-登录以及-SCP-传输文件"><a href="#Python-中-SSH-登录以及-SCP-传输文件" class="headerlink" title="Python 中 SSH 登录以及 SCP 传输文件"></a>Python 中 SSH 登录以及 SCP 传输文件</h2><p><strong>使用 paramiko 库来登录 SSH，使用 scp 来传输文件</strong></p>
<p><a href="http://www.cnblogs.com/haigege/p/5513759.html">http://www.cnblogs.com/haigege/p/5513759.html</a></p>
<p><a href="http://blog.51cto.com/5ydycm/340854">http://blog.51cto.com/5ydycm/340854</a></p>
<p><a href="http://docs.paramiko.org/en/2.4/">http://docs.paramiko.org/en/2.4/</a></p>
<p><a href="https://pypi.org/project/scp">https://pypi.org/project/scp</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import paramiko</span><br><span class="line">from scp import SCPClient</span><br><span class="line"></span><br><span class="line">ssh &#x3D; paramiko.SSHClient()</span><br><span class="line">ssh.set_missing_host_key_policy(paramiko.client.MissingHostKeyPolicy)</span><br><span class="line">ssh.connect(&#39;192.168.3.40&#39;, username&#x3D;&#39;pi&#39;, password&#x3D;&#39;snowyang&#39;, timeout&#x3D;2)</span><br><span class="line"></span><br><span class="line">with SCPClient(ssh.get_transport()) as scp:</span><br><span class="line">    scp.get(&#39;&#x2F;home&#x2F;pi&#x2F;mx1290prog&#x2F;master.log&#39;, &#39;40.log&#39;)</span><br></pre></td></tr></table></figure>

<h2 id="GitPython"><a href="#GitPython" class="headerlink" title="GitPython"></a>GitPython</h2><p><a href="https://www.cnblogs.com/baiyangcao/p/gitpython.html">https://www.cnblogs.com/baiyangcao/p/gitpython.html</a></p>
<p><a href="http://gitpython.readthedocs.io/en/stable/tutorial.html">http://gitpython.readthedocs.io/en/stable/tutorial.html</a></p>
<h2 id="错误-Text-file-busy"><a href="#错误-Text-file-busy" class="headerlink" title="错误:Text file busy"></a>错误:Text file busy</h2><p>在调试 B.A.T 烧录器客户端一拖三时发现有时烧录失败但是模组并没有断开，后来看 log 发现是调用 openocd 时发生了问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Info : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints</span><br><span class="line">Info : gdb server disabled</span><br><span class="line">shutdown command invoked</span><br><span class="line">&#x2F;bin&#x2F;sh: 1: .&#x2F;openocd: Text file busy</span><br><span class="line">Disconnected</span><br><span class="line">&#x2F;bin&#x2F;sh: 1: .&#x2F;openocd: Text file busy</span><br><span class="line">&#x2F;bin&#x2F;sh: 1: .&#x2F;openocd: Text file busy</span><br><span class="line">Disconnected</span><br><span class="line">&#x2F;bin&#x2F;sh: 1: .&#x2F;openocd: Text file busy</span><br><span class="line">&#x2F;bin&#x2F;sh: 1: .&#x2F;openocd: Text file busy</span><br><span class="line">Disconnected</span><br><span class="line">&#x2F;bin&#x2F;sh: 1: .&#x2F;openocd: Text file busy</span><br><span class="line">&#x2F;bin&#x2F;sh: 1: .&#x2F;openocd: Text file busy</span><br><span class="line">&#x2F;bin&#x2F;sh: 1: .&#x2F;openocd: Text file busy</span><br><span class="line">&#x2F;bin&#x2F;sh: 1: .&#x2F;openocd: Text file busy</span><br><span class="line">Open On-Chip Debugger 0.10.0+dev-00364-g1756f393 (2018-05-03-10:58)</span><br><span class="line">Licensed under GNU GPL v2</span><br></pre></td></tr></table></figure>

<p>起初怀疑是 openocd 不能多进程调用，后来才发现，其实是在烧录时我不小心 CTRL + S 对 .py 文件做了保存操作，也就是说在执行脚本时又写了此脚本，那么就会导致此错误。</p>
<p>参考：<a href="https://stackoverflow.com/questions/1384398/usr-bin-perl-bad-interpreter-text-file-busy">https://stackoverflow.com/questions/1384398/usr-bin-perl-bad-interpreter-text-file-busy</a></p>
<h2 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h2><p>没有引用，对象就销毁了</p>
<p>一个引用在函数退出后就没有了</p>
<p>函数内的局部对象在退出后就销毁了</p>
<p><a href="https://www.jianshu.com/p/22a8bedc39fd">https://www.jianshu.com/p/22a8bedc39fd</a></p>
<h2 id="map-函数返回值问题"><a href="#map-函数返回值问题" class="headerlink" title="map 函数返回值问题"></a>map 函数返回值问题</h2><p><a href="https://blog.csdn.net/kairen6645/article/details/80252824">https://blog.csdn.net/kairen6645/article/details/80252824</a></p>
<p>今天在使用python map的过程中，发现了一个奇怪问题，map遍历完成后，再次访问map，发现map为空了。</p>
<p>产生这种差异的原因在于：遍历完最后一个元素后，再次访问时会放回空列表。</p>
<p>所以要把 map 结果转换为 list 再返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m &#x3D; list(map(args))</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="http://python.jobbole.com/82750/">Python奇技淫巧</a></p>
<h2 id="十六进制字符串转为十六进制数组。"><a href="#十六进制字符串转为十六进制数组。" class="headerlink" title="十六进制字符串转为十六进制数组。"></a>十六进制字符串转为十六进制数组。</h2><p>   比如把字符串 “ABCDEF” 转为 0xAB, 0xCD, 0xEF。</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usr&#x2F;bin&#x2F;python</span><br><span class="line"></span><br><span class="line">arr &#x3D; &quot;ABCDEF&quot;.decode(&#39;hex&#39;)</span><br><span class="line">f &#x3D; open(&#39;hex.bin&#39;, &#39;wb&#39;)</span><br><span class="line">f.write(arr)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>LwIP 代码分析</title>
    <url>/2020/12/11/Network/TCPIP/LwIP/LwIP%20%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>LwIP 架构和代码分析。</p>
<p>本文使用的源码版本是 2.0.3</p>
<a id="more"></a>

<h2 id="LwIP"><a href="#LwIP" class="headerlink" title="LwIP"></a>LwIP</h2><p>LwIP 官方网站：</p>
<p><a href="http://savannah.nongnu.org/projects/lwip/">http://savannah.nongnu.org/projects/lwip/</a></p>
<p>Git 仓库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lwIP - A Lightweight TCPIP stack</span><br><span class="line">git clone https:&#x2F;&#x2F;git.savannah.nongnu.org&#x2F;git&#x2F;lwip.git</span><br><span class="line"></span><br><span class="line">Unnamed repository; edit this file &#39;description&#39; to name the repository.</span><br><span class="line">git clone https:&#x2F;&#x2F;git.savannah.nongnu.org&#x2F;git&#x2F;lwip&#x2F;lwip-contrib.git</span><br></pre></td></tr></table></figure>

<p>lwip-contrib 仓库用以一些牛逼的第三方开发者贡献自己的代码。内有各种各样牛逼又实用的代码，比如 ping，shell, httpd 以及在 win32, unix 上的 port。这些代码都是经过官方审查的，就比如 ping 肯定比那些野生的 ping 要好用和稳定。</p>
<h2 id="LwIP-理解"><a href="#LwIP-理解" class="headerlink" title="LwIP 理解"></a>LwIP 理解</h2><p>我觉得协议栈中的 <code>栈</code> 字用的特别精确，协议栈就是一层层协议搭建起来的栈，一层协议负责一种职能，数据在栈中自下而上或者自上而下的传输。比如发送一个 TCP 报文，就自上而下地经过了负责可靠传输的传输层，负责路由和转发的网络层，最终由物理层转换为信号发送出去；而接收到一个原始数据包，就自下而上地经过网络层和传输层的处理，然后递交给用户。</p>
<h2 id="LwIP-移植"><a href="#LwIP-移植" class="headerlink" title="LwIP 移植"></a>LwIP 移植</h2><ol>
<li><p>需要编译哪些 .c，需要包含哪些 .h？</p>
<p>在 src 目录下有 Filelists.mk 文件，里面定义了 LwIP 各种功能所需的 .c。</p>
<p>所有的 .h 都在 include 目录下，并且都是以相对路径的方式引用的，所以只需要把 include 加入头文件搜索路径即可。</p>
<p>当然，最快最保险的方法还是直接用 STM32CubeMX 生成一个 FreeRTOS + LwIP 例程。</p>
</li>
<li><p>需要用户移植哪些文件？</p>
<p>参考《嵌入式网络那些事》，用户只需移植 lwipopts.h, perf.h 和 cc.h 这 3 个头文件即可完成内核（无 OS）的移植，若使用 OS，还需额外移植 sys_arch.c/.h 这 2 个文件。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>lwipopts.h</td>
<td>LwIP configuration</td>
</tr>
<tr>
<td>perf.h</td>
<td>Architecture specific performance measurement.</td>
</tr>
<tr>
<td>cc.h</td>
<td>Architecture environment, some compiler specific, some environment specific.</td>
</tr>
<tr>
<td>sys_arch.c/.h</td>
<td>Abstract operation system  layer.</td>
</tr>
</tbody></table>
<p> <a href="resources/LwIP/doc/sys_arch.txt">doc/sys_arch.txt</a> 可能没有及时更新，其实在 2.0.3 中，cc.h 中的大部分定义在 include/lwip/arch.h 中已经有默认定义了，对于 ARM + GCC 平台可以直接使用。lwip_contrib 的 master 分支最新 commit 上的 ports/unix 可供 ARM + GCC 参考，其 port/include/arch/cc.h 内其实只定义了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define LWIP_TIMEVAL_PRIVATE 0</span><br><span class="line">#include &lt;sys&#x2F;time.h&gt;</span><br><span class="line">#define LWIP_ERRNO_INCLUDE &lt;errno.h&gt;</span><br><span class="line">#define LWIP_RAND() ((u32_t)rand())</span><br></pre></td></tr></table></figure>

<p>如果没有在 lwipopts.h 内定义 LWIP_PERF，则无需 perf.h。</p>
<p>对于 sys_arch.h，<a href="resources/LwIP/doc/sys_arch.txt">doc/sys_arch.txt</a>  内说明如下：</p>
<blockquote>
<p>sys_arch.h - Tied to sys_arch.c</p>
<p>Arch dependent types for the following objects:<br> sys_sem_t, sys_mbox_t, sys_thread_t,<br>And, optionally:<br> sys_prot_t</p>
<p>Defines to set vars of sys_mbox_t and sys_sem_t to NULL.</p>
<p> SYS_MBOX_NULL NULL<br> SYS_SEM_NULL NULL</p>
</blockquote>
<p>其实少了一个 sys_mutex_t ，如果使用的是 FreeRTOS，则可以直接使用 lwip_contrib 的 ports/freertos 的代码。</p>
<p>lwipopts.h 使用了 ESP32 的即可。</p>
</li>
</ol>
<h2 id="LwIP-初始化"><a href="#LwIP-初始化" class="headerlink" title="LwIP 初始化"></a>LwIP 初始化</h2><p>参考 <a href="resources/LwIP/doc/rawapi.txt">doc/rawapi.txt</a> 的 System initalization 章节。 <a href="resources/LwIP/doc/NO_SYS_SampleCode.c">doc/NO_SYS_SampleCode.c</a> 是示例代码。</p>
<p>参考：<a href="http://www.cnblogs.com/byeyear/p/4169834.html">lwip初始化过程</a></p>
<blockquote>
<p>初始化过程的前半部分主要针对lwip的内存管理和各个协议层，在src/core/init.c中有一个lwip_init()函数已经为我们做好了，直接调用即可；</p>
<p>初始化过程的后半部分初始化网络接口，依次调用以下函数：</p>
<p>netif_add（如果有多个接口则需多次调用）</p>
<p>netif_set_default</p>
<p>netif_set_up</p>
<p>dhcp_start</p>
<p>调用netif_add函数时我们需要提供一个init函数指针，这个指针指向我们自己的硬件接口初始化函数，一般来说就是ethernetif.c中的ethernetif_init()。</p>
</blockquote>
<p>其中 lwip_init 函数内主要是做内存和变量初始化。</p>
<p>在 netif_add 函数内会调用 init 函数指针来初始化网卡。LwIP 的逻辑是认为在添加网卡时就应该初始化它。</p>
<p>LwIP 通过 netif_set_link_up 触发的事件来启动 DHCP discovery。</p>
<p>使用 OS 的 LwIP 初始化只是把第一步的 lwip_init 换成了 tcpip_init。其实 tcpip_init 里也是调用了 lwip_init，并创建了 tcpip_thread。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void</span><br><span class="line">tcpip_init(tcpip_init_done_fn initfunc, void *arg)</span><br><span class="line">&#123;</span><br><span class="line">  lwip_init();</span><br><span class="line">  tcpip_init_done &#x3D; initfunc;</span><br><span class="line">  tcpip_init_done_arg &#x3D; arg;</span><br><span class="line">  if (sys_mbox_new(&amp;mbox, TCPIP_MBOX_SIZE) !&#x3D; ERR_OK) &#123;</span><br><span class="line">    LWIP_ASSERT(&quot;failed to create tcpip_thread mbox&quot;, 0);</span><br><span class="line">  &#125;</span><br><span class="line">#if LWIP_TCPIP_CORE_LOCKING</span><br><span class="line">  if (sys_mutex_new(&amp;lock_tcpip_core) !&#x3D; ERR_OK) &#123;</span><br><span class="line">    LWIP_ASSERT(&quot;failed to create lock_tcpip_core&quot;, 0);</span><br><span class="line">  &#125;</span><br><span class="line">#endif &#x2F;* LWIP_TCPIP_CORE_LOCKING *&#x2F;</span><br><span class="line">  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="netif-set-link-up-和-netif-set-up-的区别"><a href="#netif-set-link-up-和-netif-set-up-的区别" class="headerlink" title="netif_set_link_up 和 netif_set_up 的区别"></a>netif_set_link_up 和 netif_set_up 的区别</h2><p>参考：<a href="http://www.cnblogs.com/byeyear/p/3514573.html">LwIP：处理链路状态改变</a></p>
<p>此作者的 LwIP 分类：<a href="http://www.cnblogs.com/byeyear/category/513604.html">http://www.cnblogs.com/byeyear/category/513604.html</a></p>
<p>参考：<a href="http://lwip.wikia.com/wiki/Network_interfaces_management">Network interfaces management</a></p>
<p>还有个 WiKi：<a href="http://lwip.wikia.com/wiki/LwIP_Wiki">lwIP Wiki</a></p>
<p>它们似乎都认为 netif_set_up 代表着网卡拿到了 IP 地址，可以收发数据了。</p>
<p>但是根据作者本人回复：<a href="http://savannah.nongnu.org/bugs/?func=detailitem&item_id=37068"><em>bug #37068</em>: netif up/down handling is unclear</a></p>
<p>再根据 CHANGELOG：</p>
<blockquote>
<p>  2015-03-05: Simon Goldschmidt</p>
<ul>
<li>netif.c, ip4.c, dhcp.c, autoip.c: fixed bug #37068 (netif up/down handling<br>is unclear): correclty separated administrative status of a netif (up/down)<br>from ‘valid address’ status<br>ATTENTION: netif_set_up() now always has to be called, even when dhcp/autoip<br>is used!</li>
</ul>
</blockquote>
<p>官方解释如下：</p>
<blockquote>
<p>This is the administrative (= software) state of the netif, when the netif is fully configured this function must be called.</p>
</blockquote>
<blockquote>
<p>Bring an interface up, available for processing traffic.</p>
</blockquote>
<p>所以：</p>
<p>netif_set_up 是使能网卡，设置 NETIF_FLAG_UP 标志位，必须在网卡被使用前用户来调用<br>netif_set_link_up 是当网卡链路层 active 时由网卡驱动来设置的，如，station 关联上 AP 后就应该调用netif_set_link_up。</p>
<h2 id="注册-DHCP-回调函数-netif-set-status-callback"><a href="#注册-DHCP-回调函数-netif-set-status-callback" class="headerlink" title="注册 DHCP 回调函数 - netif_set_status_callback()"></a>注册 DHCP 回调函数 - netif_set_status_callback()</h2><p>使用<code>netif_set_status_callback</code>函数可以注册回调函数<code>NETIF_STATUS_CALLBACK</code>，那么协议栈中什么时候回调这个函数呢？ </p>
<ul>
<li><h3 id="NETIF-STATUS-CALLBACK"><a href="#NETIF-STATUS-CALLBACK" class="headerlink" title="NETIF_STATUS_CALLBACK"></a>NETIF_STATUS_CALLBACK</h3></li>
</ul>
<p>有 3 个函数内会回调这个函数，这 3 个函数内会判断网卡状态有变化才调用此回调函数(如网卡从 down 到 up，或者设置了新的IP地址)：</p>
<ol>
<li><code>netif_set_up</code><br>由用户调用以使能网卡</li>
<li><code>netif_set_down</code><br>由用户调用以禁止网卡</li>
<li><code>netif_set_ipaddr</code><br>由<code>netif_set_addr</code>调用（<code>netif_set_ipaddr</code>设置 IP 地址，而<code>netif_set_addr</code>还设置了子网掩码和网关地址）</li>
</ol>
<ul>
<li><h3 id="netif-set-addr"><a href="#netif-set-addr" class="headerlink" title="netif_set_addr"></a>netif_set_addr</h3></li>
</ul>
<p><code>netif_set_addr</code>有 4 个地方调用：</p>
<ol>
<li>netif 中的<code>netif_add</code></li>
<li>dhcp </li>
<li>autoip </li>
<li>ppp </li>
</ol>
<p>autoip 和 ppp 没有用到，<code>netif_add</code>是在初始化网卡时调用的，所以只用分析 dhcp。</p>
<p>dhcp 中有 3 个函数会调用<code>netif_set_addr</code>： </p>
<ol>
<li><code>dhcp_handle_nak</code><br>DHCP server收到 client 的 DHCP request 后，如果由于某些原因不能正常的分配IP地址，则会发送 NAK 给 client，这个 NAK 就在<code>dhcp_handle_nak</code>中处理：首先调用<code>netif_set_addr</code>将网卡的地址恢复默认的<code>IP_ADDR_ANY</code>，然后重启 dhcp。</li>
<li><code>dhcp_bind</code><br>在 2 个函数内被调用： <ol>
<li><code>dhcp_recv</code><br>成功收到 DHCP ACK 后，若网卡不支持 ARP，则会直接调用<code>dhcp_bind</code>来绑定 IP 地址，DHCP 完成。</li>
<li><code>dhcp_timeout</code><br>若用网卡支持 ARP，则在<code>dhcp_recv</code>内会向分配的 IP 地址发送一个 ARP 包以检查是否已被其他主机使用，若没有收到 ARP 回复，则 500ms 后的<code>dhcp_timeout</code>会调用<code>dhcp_bind</code>来绑定 IP 地址，DHCP 完成。</li>
</ol>
</li>
<li><code>dhcp_release</code><br>释放已分配的 IP 地址，也会调用<code>netif_set_addr</code>将网卡的地址恢复默认。</li>
</ol>
<p>所以<code>NETIF_STATUS_CALLBACK</code>可以用作是 DHCP 结果的一个回调函数。</p>
<p>DHCP 最后阶段的 ACK 包中含有：</p>
<ul>
<li>Your IP address：分配给本机的 IP 地址。</li>
<li>Subnet Mask：子网掩码。</li>
<li>Router：网关 IP 地址。</li>
<li>Domain Name Server：DNS 服务器 IP 地址。<br><img src="/Users/snowyang/markdown/resources/LwIP/dhcp_options.png" alt="dhcp_options"></li>
</ul>
<h2 id="Redefination-of-timeval"><a href="#Redefination-of-timeval" class="headerlink" title="Redefination of timeval"></a>Redefination of timeval</h2><p>struct timeval 在 LwIP 的 socket.h 和 GCC 的 _timeval.h 内都有定义，这样在编译时就会出错。</p>
<p>有两种解决方法：</p>
<ul>
<li><p>使用 GCC 的 timeval：在 lwipopts.h 定义 LWIP_TIMEVAL_PRIVATE 为 0，并在 cc.h 内包含头文件 &lt;sys/time.h&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** LWIP_TIMEVAL_PRIVATE: if you want to use the struct timeval provided</span><br><span class="line"> * by your system, set this to 0 and include &lt;sys&#x2F;time.h&gt; in cc.h *&#x2F;</span><br><span class="line">#ifndef LWIP_TIMEVAL_PRIVATE</span><br><span class="line">#define LWIP_TIMEVAL_PRIVATE 1</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if LWIP_TIMEVAL_PRIVATE</span><br><span class="line">struct timeval &#123;</span><br><span class="line">  long    tv_sec;         &#x2F;* seconds *&#x2F;</span><br><span class="line">  long    tv_usec;        &#x2F;* and microseconds *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">#endif &#x2F;* LWIP_TIMEVAL_PRIVATE *&#x2F;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 LwIP 的 timeval：加入全局编译选项<code>-D_TIMEVAL_DEFINED</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef _TIMEVAL_DEFINED</span><br><span class="line">#define _TIMEVAL_DEFINED</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Structure returned by gettimeofday(2) system call, and used in other calls.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct timeval &#123;</span><br><span class="line">	time_t		tv_sec;		&#x2F;* seconds *&#x2F;</span><br><span class="line">	suseconds_t	tv_usec;	&#x2F;* and microseconds *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="DNS-缓存问题"><a href="#DNS-缓存问题" class="headerlink" title="DNS 缓存问题"></a>DNS 缓存问题</h2></li>
</ul>
<p>主机在收到 DNS response 后会将 <Domain : IP> 存储到 DNS cache 内，下次可快速提供给应用层。</p>
<p>当路由器没有外网时，对于主机的 DNS query，一般的路由器是不予理会，那么主机自然会超时失败，但有些路由器会回复一个自己 IP 的 DNS response，那么主机就认为 DNS 成功了，用这个 IP 去建立 HTTPS 连接就会失败。</p>
<p>一般在 HTTPS 连接失败后，主机会再次去查询 DNS，即使此时路由器的外网建立了连接，但由于 DNS 缓存的存在（此所以主机不会发 DNS query），导致得到的还是路由器的 IP，所以会 HTTPS 连接失败。只能等到 DNS 缓存过期主机会发出 DNS query，才能得到正确的 IP 地址 。</p>
<p>有三种方法来解决此问题：</p>
<ul>
<li>在 dns_gethostbyname 内屏蔽 dns_lookup，即不要查询 DNS 缓存。</li>
<li>在调用 gethostbyname 前调用 dns_clean 以清除 DNS 缓存。</li>
<li>把 DNS_MAX_TTL 设置为 1（秒），DNS_MAX_TTL 即为 DNS 缓存的最大时间。推荐此方法，改动最小。</li>
</ul>
<h2 id="DNS-返回多个地址"><a href="#DNS-返回多个地址" class="headerlink" title="DNS 返回多个地址"></a>DNS 返回多个地址</h2><p>LwIP 中的 DNS 只返回一个地址，对于一些开启了负载均衡的服务器就有可能连不上。</p>
<h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><h3 id="注册-DHCP-回调函数"><a href="#注册-DHCP-回调函数" class="headerlink" title="注册 DHCP 回调函数"></a>注册 DHCP 回调函数</h3><p>使用<code>netif_set_status_callback</code>函数可以注册回调函数<code>NETIF_STATUS_CALLBACK</code>，那么协议栈中什么时候回调这个函数呢？ </p>
<p><strong>NETIF_STATUS_CALLBACK</strong></p>
<p>有 3 个函数内会回调这个函数，这 3 个函数内会判断网卡状态有变化才调用此回调函数(如网卡从 down 到 up，或者设置了新的IP地址)：</p>
<ol>
<li><p><code>netif_set_up</code><br> 由用户调用以使能网卡</p>
</li>
<li><p><code>netif_set_down</code><br> 由用户调用以禁止网卡</p>
</li>
<li><p><code>netif_set_ipaddr</code><br> 由<code>netif_set_addr</code>调用（<code>netif_set_ipaddr</code>设置 IP 地址，而<code>netif_set_addr</code>还设置了子网掩码和网关地址）</p>
</li>
</ol>
<p><strong>netif_set_addr</strong></p>
<p><code>netif_set_addr</code>有 4 个地方调用：</p>
<ol>
<li>netif 中的<code>netif_add</code></li>
<li>dhcp </li>
<li>autoip </li>
<li>ppp </li>
</ol>
<p>autoip 和 ppp 没有用到，<code>netif_add</code>是在初始化网卡时调用的，所以只用分析 dhcp。</p>
<p>dhcp 中有 3 个函数会调用<code>netif_set_addr</code>： </p>
<ol>
<li><p><code>dhcp_handle_nak</code><br> DHCP server收到 client 的 DHCP request 后，如果由于某些原因不能正常的分配IP地址，则会发送 NAK 给 client，这个 NAK 就在<code>dhcp_handle_nak</code>中处理：首先调用<code>netif_set_addr</code>将网卡的地址恢复默认的<code>IP_ADDR_ANY</code>，然后重启 dhcp。</p>
</li>
<li><p><code>dhcp_bind</code><br> 在 2 个函数内被调用： </p>
</li>
<li><p><code>dhcp_recv</code>  </p>
<p>成功收到 DHCP ACK 后，若网卡不支持 ARP，则会直接调用<code>dhcp_bind</code>来绑定 IP 地址，DHCP 完成。</p>
</li>
<li><p><code>dhcp_timeout</code>  </p>
<p>若用网卡支持 ARP，则在<code>dhcp_recv</code>内会向分配的 IP 地址发送一个 ARP 包以检查是否已被其他主机使用，若没有收到 ARP 回复，则 500ms 后的<code>dhcp_timeout</code>会调用<code>dhcp_bind</code>来绑定 IP 地址，DHCP 完成。</p>
</li>
<li><p><code>dhcp_release</code><br> 释放已分配的 IP 地址，也会调用<code>netif_set_addr</code>将网卡的地址恢复默认。</p>
</li>
</ol>
<p>所以<code>NETIF_STATUS_CALLBACK</code>可以用作是 DHCP 结果的一个回调函数。</p>
<p>DHCP 最后阶段的 ACK 包中含有：</p>
<ul>
<li>Your IP address：分配给本机的 IP 地址。</li>
<li>Subnet Mask：子网掩码。</li>
<li>Router：网关 IP 地址。</li>
<li>Domain Name Server：DNS 服务器 IP 地址。</li>
</ul>
<h3 id="启动-DHCP-dhcp-start"><a href="#启动-DHCP-dhcp-start" class="headerlink" title="启动 DHCP - dhcp_start"></a>启动 DHCP - dhcp_start</h3><p><code>dhcp_start</code>会检查当前网卡的链路是否active，若是，则直接调用<code>dhcp_discovery</code>，否则，设置 dhcp 的 state 为<code>INIT</code>。</p>
<p>网卡驱动中应该在网卡 link up 后（如 Wi-Fi 网络中 station 连接上 AP) 调用<code>netif_set_link_up</code>，<code>netif_set_link_up</code>内会调用<code>dhcp_network_changed</code>，<code>dhcp_network_changed</code>内发现当前 DHCP 状态为<code>INIT</code>时就调用<code>dhcp_discovery</code>，从而发起 discovery。</p>
<p>所以可以在网卡 link up 前就调用<code>dhcp_start</code>。</p>
<h3 id="DHCP-加速"><a href="#DHCP-加速" class="headerlink" title="DHCP 加速"></a>DHCP 加速</h3><p>有时候连网会很慢，抓包来看是 DHCP 花费了很长时间，究其原因主要有两点：</p>
<ol>
<li>丢包，特别是 Wi-Fi 。</li>
<li>一些路由器是出于安全考虑，会拒绝设备的再次请求。</li>
</ol>
<p>以上两种原因的结果都是超时重传，在 LwIP 中 DHCP 的超时重传时间是 2s，4s，8s …，以 2 的指数倍增长，所以一旦发生超时重传，就会很慢。</p>
<p>解决这个问题的方法也很简单，DHCP 由一个 500ms 的 fine timer 来处理超时事件，那么将所有的 DHCP 超时重传间隔设置为 500ms 即可大大加快 DHCP 的速度。</p>
<p>经过测试，在未优化之前，DHCP 平均需要约 4s 的时间，优化后只需 2s 的时间。</p>
<h2 id="操作系统模拟层移植"><a href="#操作系统模拟层移植" class="headerlink" title="操作系统模拟层移植"></a>操作系统模拟层移植</h2><p>移植操作系统模拟层，本质上就是实现几个操作系统接口函数：信号量，邮箱，互斥量和线程。 </p>
<p>信号量，邮箱和互斥量的操作：</p>
<ul>
<li>new</li>
<li>free</li>
<li>write</li>
<li>read</li>
</ul>
<p>信号量和邮箱还有额外的四个操作：</p>
<ul>
<li>try_write</li>
<li>try_read</li>
<li>valid</li>
<li>invalid </li>
</ul>
<p>线程的操作：</p>
<ul>
<li>new</li>
</ul>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="LwIP-中的-ACK"><a href="#LwIP-中的-ACK" class="headerlink" title="LwIP 中的 ACK"></a>LwIP 中的 ACK</h3><p>在<code>tcp_receive</code>内会调用<code>tcp_ack</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define tcp_ack(pcb)                               \</span><br><span class="line">  do &#123;                                             \</span><br><span class="line">    if((pcb)-&gt;flags &amp; TF_ACK_DELAY) &#123;              \</span><br><span class="line">      (pcb)-&gt;flags &amp;&#x3D; ~TF_ACK_DELAY;               \</span><br><span class="line">      (pcb)-&gt;flags |&#x3D; TF_ACK_NOW;                  \</span><br><span class="line">    &#125;                                              \</span><br><span class="line">    else &#123;                                         \</span><br><span class="line">      (pcb)-&gt;flags |&#x3D; TF_ACK_DELAY;                \</span><br><span class="line">    &#125;                                              \</span><br><span class="line">  &#125; while (0)</span><br></pre></td></tr></table></figure>

<p>收到第一个数据后，会置位<code>TF_ACK_DELAY</code>。</p>
<p>在 250 ms 一次的<code>tcp_fasttmr</code>内，若发现<code>TF_ACK_DELAY</code>仍然处于置位状态，就说明没有捎带确认或累计确认，那必须在这里发送 ACK 出去。</p>
<h3 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h3><p>收到第二个数据后，会置位<code>TF_ACK_NOW</code>并清零<code>TF_ACK_DELAY</code>。</p>
<p>在<code>tcp_input</code>的最后会调用<code>tcp_output</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">err_t</span><br><span class="line">tcp_output(struct tcp_pcb *pcb)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  if (pcb-&gt;flags &amp; TF_ACK_NOW &amp;&amp;</span><br><span class="line">     (seg &#x3D;&#x3D; NULL ||</span><br><span class="line">      lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;lastack + seg-&gt;len &gt; wnd)) &#123;</span><br><span class="line">     return tcp_send_empty_ack(pcb);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若<code>TF_ACK_NOW</code>被置位，说明至少收到已经两个数据包了，则立即发送 ACK，这就实现了累计确认的功能。</p>
<h3 id="捎带确认"><a href="#捎带确认" class="headerlink" title="捎带确认"></a>捎带确认</h3><p>在<code>tcp_output</code>发送数据报时，会填充 TCP 头的 ACK 域，并将<code>TF_ACK_DELAY</code>和<code>TF_ACK_NOW</code>清零。</p>
<h2 id="LwIP-尽量减小功能之间的耦合性"><a href="#LwIP-尽量减小功能之间的耦合性" class="headerlink" title="LwIP 尽量减小功能之间的耦合性"></a>LwIP 尽量减小功能之间的耦合性</h2><p>比如，延时确认的 250ms 超时在<code>tcp_fasttmr</code>内处理，它只看<code>TF_ACK_DELAY</code>是否被置位，置位则说明延时确认超时，需要马上发送 ACK。</p>
<p>那么它和其他功能模块之间的唯一耦合就是<code>TF_ACK_DELAY</code>这个 flag。在<code>tcp_receive</code>内只需将<code>TF_ACK_DELAY</code>置位即可，在捎带确认或者累计确认内也只需将<code>TF_ACK_DELAY</code>清零即可。</p>
<p>在 LwIP 中，特别是这种协议超时，普遍使用这种方式。</p>
<h2 id="LwIP-中的日志输出"><a href="#LwIP-中的日志输出" class="headerlink" title="LwIP 中的日志输出"></a>LwIP 中的日志输出</h2><p>LwIP 使用<code>LWIP_DEBUGF</code>宏来输出日志，有 2 个参数：<code>debug</code>和<code>message</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define LWIP_DEBUGF(debug, message) do &#123; \</span><br><span class="line">    if ( \</span><br><span class="line">        ((debug) &amp; LWIP_DBG_ON) &amp;&amp; \</span><br><span class="line">        ((debug) &amp; LWIP_DBG_TYPES_ON) &amp;&amp; \</span><br><span class="line">        ((s16_t)((debug) &amp; LWIP_DBG_MASK_LEVEL) &gt;&#x3D; LWIP_DBG_MIN_LEVEL)) &#123; \</span><br><span class="line">      LWIP_PLATFORM_DIAG(message); \</span><br><span class="line">      if ((debug) &amp; LWIP_DBG_HALT) &#123; \</span><br><span class="line">        while(1); \</span><br><span class="line">      &#125; \</span><br><span class="line">    &#125; \</span><br><span class="line">  &#125; while(0)</span><br></pre></td></tr></table></figure>


<p><code>debug</code>参数的值是模块，类型和等级的组合，这三种是与的关系，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, </span><br><span class="line">(&quot;dhcp_check: could not perform ARP query\n&quot;));</span><br></pre></td></tr></table></figure>

<p>其中，<code>debug</code>的模块是<code>DHCP</code>，类型是<code>trace</code>，等级是<code>warning</code>。  </p>
<p>用户可以在<code>lwipopts.h</code>中配置日志输出：  </p>
<ul>
<li>定义<code>LWIP_DBG_OFF</code>来开启某个模块的日志输出  </li>
<li>定义<code>LWIP_DBG_TYPES_ON</code>来开启某个类型的日志输出  </li>
<li>定义<code>LWIP_DBG_MIN_LEVEL</code>来开启某个等级的日志输出  </li>
</ul>
<h2 id="LwIP-中的协议控制块"><a href="#LwIP-中的协议控制块" class="headerlink" title="LwIP 中的协议控制块"></a>LwIP 中的协议控制块</h2><p><code>PCB</code>全称是<code>Protocol Control Block</code>，即<code>协议控制块</code>，包含着一个连接的属性和方法。</p>
<p>一个控制块代表着着一个协议层的一个实体的属性。</p>
<ul>
<li><p>用户控制块 - netconn，主要属性有：</p>
<ul>
<li>xxx_pcb</li>
<li>同步信号量</li>
<li>数据邮箱，代表着一个用户层次的传输层连接 </li>
</ul>
</li>
<li><p>传输层控制块 - xxx_pcb，代表着一个内核层次的传输层连接,主要属性有：  </p>
<ul>
<li>源/目 IP 地址和端口</li>
<li>回调函数和参数 </li>
</ul>
</li>
<li><p>网卡控制块 - netif，代表着一个网卡，主要属性有：  </p>
<ul>
<li>MAC 地址</li>
<li>IP 地址，子网掩码和网关地址</li>
<li>输入/输出函数</li>
</ul>
</li>
</ul>
<p>网络层的作用是寻址和路由，是个中间层，所以没有对应的控制块。</p>
<p>如下图，多个 UDP 控制块组织成一个链表，协议栈在收到一个 UDP 包后会遍历这个链表查找匹配的控制块，然后调用其接收回调函数（用户也可以注册）。</p>
<p><img src="/../resources/TCP:IP/%5Blwip%5D-udp_pcb.jpg" alt="lwip-udp_pcb"></p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>LwIP 自带两种内存管理机制：内存堆(heap)和内存池(pool)。</p>
<p>堆和池各自的优缺点不再阐述，其实就是效率和利用率之间的权衡。</p>
<h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><p>Pool 是个链表结构，LwIP 中每种类型的数据结构都对应着一种 pool，协议栈用 5 个属性来描述一种 pool：</p>
<ol>
<li>名称字符</li>
<li>单个大小</li>
<li>总共个数</li>
<li>内存空间</li>
<li>首指针</li>
</ol>
<p>用结构体来描述就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct memp_desc</span><br><span class="line">&#123;</span><br><span class="line">  char *desc;</span><br><span class="line">  int size;</span><br><span class="line">  int num;</span><br><span class="line">  int *mem_base;</span><br><span class="line">  memp *tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每类 pool 都对应一个结构体变量，什么时候用什么方法初始化这些结构体变量呢？</p>
<p>普通的做法是为每类 pool 定义一个变量并赋初值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memp_desc memp_RAW_PCB &#x3D; </span><br><span class="line">&#123;</span><br><span class="line">  &quot;RAW_PCB&quot;,</span><br><span class="line">  1024,</span><br><span class="line">  16,</span><br><span class="line">  0x20001234;</span><br><span class="line">  &amp;memp_tab_RAW_PCB;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是协议栈中有那么多的 pool，这样很繁琐且不灵活。</p>
<p>LwIP 使用了一种屌炸天的奇技淫巧：宏定义大法。</p>
<p>协议栈的 memp_std.h 中为每类 pool 定义了一行字符串：LWIP_MEMPOOL(name, num, size, desc)，这行字符串用来描述一类 pool 的属性。</p>
<p>例如：LWIP_MEMPOOL(RAW_PCB,        MEMP_NUM_RAW_PCB,         sizeof(struct raw_pcb),        “RAW_PCB”)</p>
<p>然后在 memp.c 中把 LWIP_MEMPOOL 定义成了一个屌炸天的宏定义（略有修改）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define LWIP_MEMPOOL_DECLARE(name,num,size,desc) \</span><br><span class="line">  u8_t memp_memory_ ## name ## _base[num * size]; \</span><br><span class="line">  static struct memp *memp_tab_ ## name; \</span><br><span class="line">  const struct memp_desc memp_ ## name &#x3D; \</span><br><span class="line">  &#123; \</span><br><span class="line">    desc, \</span><br><span class="line">    size, \</span><br><span class="line">    num, \</span><br><span class="line">    memp_memory_ ## name ## _base, \</span><br><span class="line">    &amp;memp_tab_ ## name \</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>编译展开后是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u8_t memp_memory_RAW_PCB_base[MEMP_NUM_RAW_PCB * sizeof(struct raw_pcb)];</span><br><span class="line">static struct memp *memp_tab_RAW_PCB;</span><br><span class="line">const struct memp_desc memp_RAW_PCB &#x3D;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;RAW_PCB&quot;,</span><br><span class="line">  sizeof(struct raw_pcb),</span><br><span class="line">  MEMP_NUM_RAW_PCB,</span><br><span class="line">  memp_memory_RAW_PCB_base,</span><br><span class="line">  &amp;memp_tab_RAW_PCB</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>就问你屌不屌！😎😎😎😎😎😎😎😎</p>
<p>==<strong>只要代码中有定义多个相同结构体类型的变量的地方，都可以使用这种方式来简化代码。</strong>==</p>
<p>MEMP 类型大全：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RAW_PCB</span><br><span class="line">UDP_PCB</span><br><span class="line">TCP_PCB</span><br><span class="line">TCP_PCB_LISTEN</span><br><span class="line">TCP_SEG</span><br><span class="line">REASSDATA</span><br><span class="line">FRAG_PBUF</span><br><span class="line">NETBUF</span><br><span class="line">NETCONN</span><br><span class="line">TCPIP_MSG_API</span><br><span class="line">API_MSG</span><br><span class="line">DNS_API_MSG</span><br><span class="line">SOCKET_SETGETSOCKOPT_DATA</span><br><span class="line">NETIFAPI_MSG</span><br><span class="line">TCPIP_MSG_INPKT</span><br><span class="line">ARP_QUEUE</span><br><span class="line">IGMP_GROUP</span><br><span class="line">SYS_TIMEOUT</span><br><span class="line">NETDB</span><br><span class="line">LOCALHOSTLIST</span><br><span class="line">ND6_QUEUE</span><br><span class="line">IP6_REASSDATA</span><br><span class="line">MLD6_GROUP</span><br><span class="line">PBUF</span><br><span class="line">PBUF_POOL</span><br></pre></td></tr></table></figure>
<p><strong>PBUF POOL</strong></p>
<p>PBUF POOL是用在网络接口层存储接收到的数据的 pool，一般大小为 pbuf struct + TCP_MSS + IP header + link header。</p>
<h3 id="内存堆"><a href="#内存堆" class="headerlink" title="内存堆"></a>内存堆</h3><p>没什么好讲的了，和一般的堆管理机制大同小异。</p>
<p>mem.c 中的数组变量 ram_heap[MEM_SIZE] 就是分配的堆空间，MEM_SIZE 默认是 1600，用户可在 lwipopts.h 内自定义大小。</p>
<h3 id="使用系统的内存管理"><a href="#使用系统的内存管理" class="headerlink" title="使用系统的内存管理"></a>使用系统的内存管理</h3><p>LwIP 自带的内存池可以提供高效率的分配/回收，自带的内存堆可以避免协议栈内存出现问题时对系统内存的影响。</p>
<p>但在 ARM MCU 平台上，网络性能的瓶颈往往在于内存大小和网络本身，CPU 速度已足够快，内存池和内存堆的效率差别不大，另外，为协议栈单独分配内存堆也会造成内存浪费，所以 LwIP 提供了选项让协议栈全部使用系统的内存管理机制。</p>
<p>定义 MEM_LIBC_MALLOC 为 1 让协议栈使用系统的内存堆，定义 MEMP_MEM_MALLOC 为 1 让协议栈用内存堆来代替内存池[^1]。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * MEM_LIBC_MALLOC&#x3D;&#x3D;1: Use malloc&#x2F;free&#x2F;realloc provided by your C-library</span><br><span class="line"> * instead of the lwip internal allocator. Can save code size if you</span><br><span class="line"> * already use it.</span><br><span class="line"> *&#x2F;</span><br><span class="line">#if !defined MEM_LIBC_MALLOC || defined __DOXYGEN__</span><br><span class="line">#define MEM_LIBC_MALLOC                 0</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * MEMP_MEM_MALLOC&#x3D;&#x3D;1: Use mem_malloc&#x2F;mem_free instead of the lwip pool allocator.</span><br><span class="line"> * Especially useful with MEM_LIBC_MALLOC but handle with care regarding execution</span><br><span class="line"> * speed (heap alloc can be much slower than pool alloc) and usage from interrupts</span><br><span class="line"> * (especially if your netif driver allocates PBUF_POOL pbufs for received frames</span><br><span class="line"> * from interrupt)!</span><br><span class="line"> * ATTENTION: Currently, this uses the heap for ALL pools (also for private pools,</span><br><span class="line"> * not only for internal pools defined in memp_std.h)!</span><br><span class="line"> *&#x2F;</span><br><span class="line">#if !defined MEMP_MEM_MALLOC || defined __DOXYGEN__</span><br><span class="line">#define MEMP_MEM_MALLOC                 0</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>注意：若使用系统的内存管理，那么每类 pool 的个数就用不到了，但是协议栈编译时会做有效性检查，所以还是要定义一个合适的值。</p>
<p>[^1]: ESP32 就是这样做的。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>LwIP 内有大量的全局变量，要保证线程安全地调用协议栈函数，协议栈提供了两种方法：</p>
<ol>
<li>向协议栈守护线程 tcpip_thread 发送 TCPIP_MSG_CALLBACK 消息，让函数在 tcpip_thread 内运行，此时 tcpip_thread 相当于是 worker thread。</li>
<li>用户线程和 tcpip_thread 之间通过一个 core-locking 锁来实现互斥。</li>
<li>通过进/退临界区的方式来实现线程安全。</li>
</ol>
<p>要使用第 2 种方法，要定义 LWIP_TCPIP_CORE_LOCKING 为 1，其实协议栈中默认已经定义为 1 了，LwIP 推荐某些函数使用这种方法来运行，比如 lwip_set/getsockopt，这样的好处是减少资源和时间的消耗。</p>
<p>要使用第 3 种方法，要定义 SYS_ARCH_PROTECT 为 1，并实现 sys_arch_protect 和 sys_arch_unprotect 函数，在 LwIP 中一般是用于 buffer 或 memory 的分配/释放，这样的好处是相对方法 2 速度更快，因为方法 2 内用户函数一定要等待 tcpip_thread 在处理完所有的消息后释放锁后才能运行的，但是缺点是会频繁地开关中断。一个典型的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">  This optional function does a &quot;fast&quot; critical region protection and returns</span><br><span class="line">  the previous protection level. This function is only called during very short</span><br><span class="line">  critical regions. An embedded system which supports ISR-based drivers might</span><br><span class="line">  want to implement this function by disabling interrupts. Task-based systems</span><br><span class="line">  might want to implement this by using a mutex or disabling tasking. This</span><br><span class="line">  function should support recursive calls from the same task or interrupt. In</span><br><span class="line">  other words, sys_arch_protect() could be called while already protected. In</span><br><span class="line">  that case the return value indicates that it is already protected.</span><br><span class="line"></span><br><span class="line">  sys_arch_protect() is only required if your port is supporting an operating</span><br><span class="line">  system.</span><br><span class="line">*&#x2F;</span><br><span class="line">sys_prot_t sys_arch_protect(void)</span><br><span class="line">&#123;</span><br><span class="line">	vPortEnterCritical();</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">  This optional function does a &quot;fast&quot; set of critical region protection to the</span><br><span class="line">  value specified by pval. See the documentation for sys_arch_protect() for</span><br><span class="line">  more information. This function is only required if your port is supporting</span><br><span class="line">  an operating system.</span><br><span class="line">*&#x2F;</span><br><span class="line">void sys_arch_unprotect(sys_prot_t pval)</span><br><span class="line">&#123;</span><br><span class="line">	( void ) pval;</span><br><span class="line">	vPortExitCritical();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>SO_BINDTODEVICE</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>用户调用 gethostbyname 后，发送 callback 消息给 tcpip_thread，先查询缓存内是否已经有了此项，若有则直接返回给用户，若无则发送 dns query 请求。在底层递交一个 UDP 包后，若是 DNS response，则解析并返回给用户。同时维护了一个 timer 以处理超时错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user</span><br><span class="line">⇩</span><br><span class="line">lwip_gethostbyname</span><br><span class="line">⇩</span><br><span class="line">netconn_gethostbyname</span><br><span class="line">⇩</span><br><span class="line">tcpip_callback(lwip_netconn_do_gethostbyname)</span><br><span class="line">⇩                    ⇣</span><br><span class="line">sys_sem_wait          ⇣</span><br><span class="line">⇩                    ⇣</span><br><span class="line">return                ⇣</span><br><span class="line">---------------------------------------- query -------------------------------------------</span><br><span class="line">                      ⇣</span><br><span class="line">tcpip_thread          ⇣</span><br><span class="line">⇩                    ⇣</span><br><span class="line">lwip_netconn_do_gethostbyname</span><br><span class="line">⇩</span><br><span class="line">dns_gethostbyname_addrtype</span><br><span class="line">⇩</span><br><span class="line">dns_lookup ⇨(on found) sys_sem_signal</span><br><span class="line">⇩</span><br><span class="line">dns_enqueue</span><br><span class="line">⇩</span><br><span class="line">dns_check_entry</span><br><span class="line">⇩</span><br><span class="line">dns_send</span><br><span class="line">⇩</span><br><span class="line">udp_sendto</span><br><span class="line">------------------------------------- response -------------------------------------------</span><br><span class="line">udp_input</span><br><span class="line">⇩</span><br><span class="line">dns_recv</span><br><span class="line">⇩</span><br><span class="line">dns_correct_response</span><br><span class="line">⇩</span><br><span class="line">dns_call_found</span><br><span class="line">⇩</span><br><span class="line">lwip_netconn_do_dns_found</span><br><span class="line">⇩</span><br><span class="line">sys_sem_signal</span><br><span class="line">-------------------------------------- timeout -------------------------------------------</span><br><span class="line">tcpip_thread</span><br><span class="line">⇩</span><br><span class="line">(on timer expired)</span><br><span class="line">dns_timer</span><br><span class="line">⇩</span><br><span class="line">dns_tmr</span><br><span class="line">⇩</span><br><span class="line">dns_check_entries</span><br><span class="line">⇩</span><br><span class="line">dns_check_entry</span><br><span class="line">⇩</span><br><span class="line">(on maxium retries)</span><br><span class="line">dns_call_found(NULL)</span><br><span class="line">⇩</span><br><span class="line">lwip_netconn_do_dns_found</span><br><span class="line">⇩</span><br><span class="line">sys_sem_signal</span><br></pre></td></tr></table></figure>

<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>用户线程在调用 gethostbyname 后，就阻塞在一个信号量上。有 3 种情况会 give 信号量：</p>
<ol>
<li>缓冲中已有此项</li>
<li>收到 dns response</li>
<li>超时</li>
</ol>
<h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>其中，dns timer 是 DNS_TMR_INTERVAL，lwip 2.0.2 版本是 1000ms，重试次数是 DNS_MAX_RETRIES，默认是 4，num_dns 默认是 1，所以 dns 超时是 4 秒。</p>
]]></content>
      <categories>
        <category>LwIP</category>
      </categories>
  </entry>
  <entry>
    <title>炸灯记</title>
    <url>/2020/12/12/Analog/%E7%82%B8%E7%81%AF%E8%AE%B0/</url>
    <content><![CDATA[<p>调试 Wi-Fi 智能灯时需要看 Wi-Fi 模组的日志，或者测量 PWM 驱动波形，但是有的灯在接上探头后，一上电就会炸掉😱，真的，几米远那种。</p>
<p>为什么会这样呢？本着生命安全我重新捡回模拟电子知识研究了一下。</p>
<a id="more"></a>

<p>灯的供电是 220V 交流电，而 Wi-Fi 模组是 3.3V 直流电，故而需要一个转换电路，其原理图大致如下：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA80AAAEfCAIAAAD0vbOvAAAAAXNSR0IArs4c6QAAAAlwSFlzAAAOxAAADsQBlSsOGwAAQABJREFUeAHtvX+sFdeV51u31f/0DIwVR56WcfPkN8TQFszr2CbdVgSDf8iNLFvgS/tlsAQ2eRBbHpjYssDigWiHIBgr8CxiQaykzfgHPBlZGTDIEe3Jw4ZAR34K0D2vsWygSbeCAvK421YCM/0n71t3nbvuvruqdq1zquqcqjrf0tW5u/Zee+21P3vXOevss2rXyPXr1yMeJEACJEACJEACJEACJEACpRL4nVK1URkJkAAJkAAJkAAJkAAJkEBMgH425wEJkAAJkAAJkAAJkAAJlE+Afnb5TKmRBEiABEiABEiABEiABOhncw6QAAmQAAmQAAmQAAmQQPkE6GeXz5QaSYAESIAESIAESIAESIB+NucACZAACZAACZAACZAACZRPgH52+UypkQRIgARIgARIgARIgAToZ3MOkAAJkAAJkAAJkAAJkED5BOhnl8+UGkmABEiABEiABEiABEiAfjbnAAmQAAmQAAmQAAmQAAmUT4B+dvlMqZEESIAESIAESIAESIAEQn72yMiIBZBRDKqMkkYxKgyMDhkWh0OGZOgSMM4Hoxg0GyWNYlToDpaXJkMPiHtqhGMUg2ajpFGMCt3B8tJk6AFxT41wjGLQbJRMio1cv37dtYxpEiABEiABEiABEiABEiCB4gRC69nFtVMDCZAACZAACZAACZAACQwnAfrZwznu7DUJkAAJkAAJkAAJkEC1BOhnV8uX2kmABEiABEiABEiABIaTAP3s4Rx39poESIAESIAESIAESKBaAvSzq+VL7SRAAiRAAiRAAiRAAsNJgH72cI47e00CJEACJEACJEACJRC4du3asWPHtm3bdv78+RLUtUvF77arO+wNCZAACZAACZAACQwjAfi7zz777Oeffy6d3717980334zXo0ePSs6KFSsWLVokaQi/8847Bw4cwOmSJUv++I//+Hvf+96WLVtQRQTwKjLwoaFz7ty53/zmN6HqV7/61YYNG0Rm3759P/zhD0+ePCmnCxcu1LpMCAHun82ZQAIkQAIkQAIkQAKNJ4Dl5FmzZmk3Tp06ddddd8GHPnjwoGSuXLny1VdfRRoO9IMPPqj+sVY5dOiQOuLQ9vDDD1+4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" alt="VI  Tl  115 Vrm  60 Hz  00  115:12  08  1B4B42  LM7805KC  •VREG  VOLTAGE .  co,€Mon&#39;  220PF  xscl•  Ext Trig  2000 "></p>
<p>220V 交流电首先通过隔离变压器 T1，然后经过全波整流桥 D8，由电容 C1 二次整形，最后由 LDO U2 输出直流电压。</p>
<p>但是某些品牌的灯（不说了）为了节省成本，省去了这个隔离变压器 T1，这样整流桥的 2 和 4 脚实际上是短路的，那么在交流电的下半周期，整流桥的 4 和 1 脚上直接承载着 220V 的电压，二极管不爆炸才怪。</p>
<p>当然更可怕的是，电容 C1 220uF，这么大容值一般选用电解电容，电解电容有正负极之分，在交流电的下半周期，C1 上还会有反相高电压，于是这颗电容也“嘣”掉了。</p>
]]></content>
      <categories>
        <category>Analog</category>
      </categories>
  </entry>
</search>
