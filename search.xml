<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git 实用技巧</title>
    <url>/2020/12/09/Git/Git%20%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="git-clean-删除未追踪的文件和目录"><a href="#git-clean-删除未追踪的文件和目录" class="headerlink" title="git clean - 删除未追踪的文件和目录"></a>git clean - 删除未追踪的文件和目录</h2><p>删除一些没有git add的文件；</p>
<p>git clean 参数：<br>-n 显示将要删除的文件和目录<br>-f 删除文件，-df删除文件和目录</p>
<h2 id="git-archive-打包"><a href="#git-archive-打包" class="headerlink" title="git archive - 打包"></a>git archive - 打包</h2><p>如果使用压缩工具（tar、7zip、winzip、rar等）将工作区文件归档，一不小心会把版本库（.git目录）包含其中，甚至将工作区中的忽略文件、临时文件也包含其中。  </p>
<p>Git提供了一个归档命令：<code>gitarchive</code>，可以对任意提交对应的目录树建立归档。  </p>
<p>如，基于最新提交建立归档文件 latest.zip。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$git archive -o latest.zip HEAD</span><br></pre></td></tr></table></figure>

<h2 id="git-commit-m-换行"><a href="#git-commit-m-换行" class="headerlink" title="git commit -m 换行"></a>git commit -m 换行</h2><p>在消息前使用单引号，输完一行后换行，这将使Bash提示另一行，直到关闭引号为止。像这样：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;Message</span></span><br><span class="line"><span class="string">goes</span></span><br><span class="line"><span class="string">here&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>AES</title>
    <url>/2020/12/09/Security/AES/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/nurke/article/details/77267081">https://blog.csdn.net/nurke/article/details/77267081</a></p>
<p>基于 Python2 的，Python3 要修改一下，主要是 string 和 bytes 的区别：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding: utf8</span><br><span class="line">import sys</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">from binascii import b2a_hex, a2b_hex</span><br><span class="line"> </span><br><span class="line">class prpcrypt():</span><br><span class="line">    def __init__(self, key):</span><br><span class="line">        self.key &#x3D; key</span><br><span class="line">        self.mode &#x3D; AES.MODE_CBC</span><br><span class="line">     </span><br><span class="line">    #加密函数，如果text不是16的倍数【加密文本text必须为16的倍数！】，那就补足为16的倍数</span><br><span class="line">    def encrypt(self, text):</span><br><span class="line">        cryptor &#x3D; AES.new(self.key, self.mode, self.key)</span><br><span class="line">        #这里密钥key 长度必须为16（AES-128）、24（AES-192）、或32（AES-256）Bytes 长度.目前AES-128足够用</span><br><span class="line">        length &#x3D; 16</span><br><span class="line">        count &#x3D; len(text)</span><br><span class="line">        if(count % length !&#x3D; 0) :</span><br><span class="line">            add &#x3D; length - (count % length)</span><br><span class="line">        else:</span><br><span class="line">            add &#x3D; 0</span><br><span class="line">        text &#x3D; text + (b&#39;\0&#39; * add)</span><br><span class="line">        self.ciphertext &#x3D; cryptor.encrypt(text)</span><br><span class="line">        #因为AES加密时候得到的字符串不一定是ascii字符集的，输出到终端或者保存时候可能存在问题</span><br><span class="line">        #所以这里统一把加密后的字符串转化为16进制字符串</span><br><span class="line">        return b2a_hex(self.ciphertext)</span><br><span class="line">     </span><br><span class="line">    #解密后，去掉补足的空格用strip() 去掉</span><br><span class="line">    def decrypt(self, text):</span><br><span class="line">        cryptor &#x3D; AES.new(self.key, self.mode, self.key)</span><br><span class="line">        plain_text &#x3D; cryptor.decrypt(a2b_hex(text))</span><br><span class="line">        return plain_text.rstrip(b&#39;\0&#39;)</span><br><span class="line"> </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    pc &#x3D; prpcrypt(&#39;keyskeyskeyskeys&#39;)</span><br><span class="line">    e &#x3D; pc.encrypt(b&#39;0123456789ABCDEF&#39;)</span><br><span class="line">    d &#x3D; pc.decrypt(e)</span><br><span class="line">    print(e, d)</span><br><span class="line">    e &#x3D; pc.encrypt(b&#39;00000000000000000000000000&#39;)</span><br><span class="line">    d &#x3D; pc.decrypt(e)</span><br><span class="line">    print(e, d)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Security</category>
      </categories>
  </entry>
  <entry>
    <title>个人博客</title>
    <url>/2020/12/09/Others/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<ul>
<li>创建 Git Pages</li>
<li>申请域名</li>
<li>在域名商后台设置域名解析</li>
<li>在 Git Pages 设置 CNAME</li>
</ul>
<p>注意，因为主机在 Git Pages 上，属于国外，所以不需要备案。</p>
<p>不需要备案，就不需要购买云服务器，我当时不懂，为此还浪费了 99 元大洋，心痛啊！</p>
<p><a href="https://cloud.tencent.com/developer/article/1454059">https://cloud.tencent.com/developer/article/1454059</a></p>
<blockquote>
<p>网上很多人问 <code>github</code> 绑定域名要不要备案，很多人的回答是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">国内主机需要备案，国外主机不用</span><br></pre></td></tr></table></figure>

<p>这个说法是没错的，但是却没有直接回答出 <code>github pages</code> 是否需要备案！</p>
<p>首先声明 <code>github</code> 上面的博客空间属于国外空间，绑定域名可以 <code>不用备案</code> ！完全放心，作者买了域名还没备案也是可以用的 <a href="http://www.tybai.com/">百哥么么哒</a></p>
</blockquote>
<p>比如我在腾讯云上购买的域名，设置解析：</p>
<img src=".Untitled.assets/image-20201209140134614.png" alt="image-20201209140134614"  />

<p>在 Git Pages 上配置 CNAME：</p>
<p><img src="/.Untitled.assets/image-20201209141030165.png" alt="image-20201209141030165"></p>
<p>然后就可以在浏览器中打开 snowyang.com 来访问我的博客了。</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
  </entry>
  <entry>
    <title>ECDSA</title>
    <url>/2020/12/09/Security/ECDSA/</url>
    <content><![CDATA[<p>参考：<a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">Elliptic Curve Digital Signature Algorithm</a></p>
<p>ECDSA，椭圆曲线数字签名算法，也即使用了<code>椭圆曲线密码学</code>的<code>数字签名算法</code>。</p>
<p>wikipeida 的定义如下：</p>
<blockquote>
<p>In <a href="https://en.wikipedia.org/wiki/Cryptography">cryptography</a>, the <strong>Elliptic Curve Digital Signature Algorithm</strong> (<strong>ECDSA</strong>) offers a variant of the <a href="https://en.wikipedia.org/wiki/Digital_Signature_Algorithm">Digital Signature Algorithm</a> (DSA) which uses <a href="https://en.wikipedia.org/wiki/Elliptic_curve_cryptography">elliptic curve cryptography</a>.</p>
</blockquote>
<p>可以把 ECDSA 可以拆解成两部分：ECC 和 DSA。</p>
<h2 id="ECDSA"><a href="#ECDSA" class="headerlink" title="ECDSA"></a>ECDSA</h2><h3 id="Fundamentals"><a href="#Fundamentals" class="headerlink" title="Fundamentals"></a>Fundamentals</h3><p><a href="https://www.maximintegrated.com/en/app-notes/index.mvp/id/5767">The Fundamentals of an ECDSA Authentication System</a> - ==强力推荐！==</p>
<a id="more"></a>

<p>虽然椭圆曲线有无数个，但只有很小一部分适合 ECC，NIST推荐使用这些椭圆曲线并将其写入标准，每个曲线都有一个名称并由一个参数集来定义，参数集由 Prime Modulus p, the Prime Order n, the Coefficient a, the Coefficient b, and the x and y coordinates of the Base Point G(x,y) on the curve 组成。如 <strong>Curve P-192</strong> 的参数如下：</p>
<p><img src="/2020/12/09/Security/ECDSA/image-20201123232221536.png"></p>
<p>私钥是个随机数，公钥由私钥和椭圆曲线产生，公钥由 x 和 y 值组成：</p>
<p><img src="/2020/12/09/Security/ECDSA/image-20201123232239565.png"></p>
<p>数字签名由私钥，椭圆曲线，随机数和消息的摘要产生：</p>
<p><img src="/2020/12/09/Security/ECDSA/image-20201123232258442.png"></p>
<p>验证结果由公钥，椭圆曲线，数字签名和消息的摘要产生：</p>
<p><img src="/2020/12/09/Security/ECDSA/image-20201123232313357.png"></p>
<h3 id="Digital-signature"><a href="#Digital-signature" class="headerlink" title="Digital signature"></a>Digital signature</h3><p>参考：<a href="https://superuser.com/questions/1023167/can-i-extract-r-and-s-from-an-ecdsa-signature-in-bit-form-and-vica-versa">Can I extract R and S from an ECDSA signature in bit form, and vica versa?</a></p>
<p>ECDSA 数字签名由 r 和 s 组成，r 和 s 的长度和私钥 d 长度相同。</p>
<p>实际使用的 ECDSA 一般是 DER 格式的文件，除了 r 和 s 外还有其他信息。</p>
<p>以一个例子来说明 DER 格式 ECDSA 数字签名的格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x30, 0x45, &#x2F;&#x2F; Sequence of length 69 to follow</span><br><span class="line">0x02, 0x21, &#x2F;&#x2F; Integer of length 33 to follow</span><br><span class="line">0x00, &#x2F;&#x2F; If first byte of the 32 byte integer is &gt;0x7F, an extra 0x00 byte is prepended</span><br><span class="line">&#x2F;&#x2F; Here come the 32 bytes (r):</span><br><span class="line">0xC5, 0x79, 0xA7, 0xB6, 0x01, 0xBF, 0x5D, 0x69, 0x93, 0x50, 0x58, 0x02, 0xE5, 0x8C, 0xFA, 0x61, 0x2F, 0x7C, 0x72, 0xA5, 0x47, 0xEC, 0x6E, 0x2B, 0x72, 0x88, 0xDE, 0x5C, 0xC7, 0x10, 0x1D, 0xE8, </span><br><span class="line">0x02, 0x20, &#x2F;&#x2F; Integer of length 32 to follow</span><br><span class="line">&#x2F;&#x2F; Here come the 32 bytes (s):</span><br><span class="line">0x1D, 0xF6, 0x15, 0xA8, 0x9B, 0xC8, 0x41, 0x89, 0x0F, 0x59, 0xEF, 0x3F, 0x04, 0x5D, 0x52, 0x41, 0xAE, 0xB7, 0x95, 0xE2, 0xC6, 0x4B, 0xE3, 0xA5, 0xD1, 0x85, 0xB8, 0x8F, 0x95, 0x4E, 0xB4, 0x01, </span><br></pre></td></tr></table></figure>

<p>0x30 代表着下面是个 Sequence，长度为 0x45，0x02 代表下面是个 Integer，长度是 0x21，然后是另一个 Integer，长度是 0x20。</p>
<p>为什么第一个 integer 的长度是 0x21 呢，因为 integer 是带符号类型的，所以如果第一个字节的 MSB 是 1（ &gt; 0x7F），就要额外在前面补个 0x00。</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>参考：</p>
<p><a href="https://github.com/warner/python-ecdsa">https://github.com/warner/python-ecdsa</a></p>
<p>openssl 提供了 ECDSA 的一些命令。</p>
<h3 id="生成-EC-私钥"><a href="#生成-EC-私钥" class="headerlink" title="生成 EC 私钥"></a>生成 EC 私钥</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl ecparam -name secp224r1 -genkey -out sk.pem</span><br></pre></td></tr></table></figure>

<p><a href="https://www.openssl.org/docs/manmaster/man1/ecparam.html">https://www.openssl.org/docs/manmaster/man1/ecparam.html</a></p>
<p>其中，-name secp2241r1 是椭圆曲线参数，使用 openssl ecparam -list_curves 可以查看所有的椭圆曲线参数。</p>
<h3 id="从-EC-私钥中提取公钥"><a href="#从-EC-私钥中提取公钥" class="headerlink" title="从 EC 私钥中提取公钥"></a>从 EC 私钥中提取公钥</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl ec -in sk.pem -pubout -out vk.pem</span><br></pre></td></tr></table></figure>

<p><a href="https://www.openssl.org/docs/manmaster/man1/ec.html">https://www.openssl.org/docs/manmaster/man1/ec.html</a></p>
<h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl dgst -sha256 -sign sk.pem -out data.sig data</span><br></pre></td></tr></table></figure>

<p><a href="https://www.openssl.org/docs/manmaster/man1/dgst.html">https://www.openssl.org/docs/manmaster/man1/dgst.html</a></p>
<p>其中，-sha256 是消息摘要算法。</p>
<h3 id="验签"><a href="#验签" class="headerlink" title="验签"></a>验签</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl dgst -sha256 -verify vk.pem -signature data.sig data</span><br></pre></td></tr></table></figure>

<h3 id="从证书中提取公钥"><a href="#从证书中提取公钥" class="headerlink" title="从证书中提取公钥"></a>从证书中提取公钥</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl x509 -in cert.pem  -noout -pubkey &gt; vk.pem</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/pixy/p/4722381.html">https://www.cnblogs.com/pixy/p/4722381.html</a></p>
<h3 id="查看私钥"><a href="#查看私钥" class="headerlink" title="查看私钥"></a>查看私钥</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl ec -in sk.pem -text -noout</span><br></pre></td></tr></table></figure>

<h3 id="查看公钥"><a href="#查看公钥" class="headerlink" title="查看公钥"></a>查看公钥</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl ec -in vk.pem -pubin -text -noout</span><br></pre></td></tr></table></figure>

<h3 id="SHA256-计算"><a href="#SHA256-计算" class="headerlink" title="SHA256 计算"></a>SHA256 计算</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl dgst -sha256 file</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/gordon0918/p/5382541.html">https://www.cnblogs.com/gordon0918/p/5382541.html</a></p>
<h3 id="由-R-和-S-生成-DER-文件"><a href="#由-R-和-S-生成-DER-文件" class="headerlink" title="由 R 和 S 生成 .DER 文件"></a>由 R 和 S 生成 .DER 文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># Author : Snow Yang</span><br><span class="line"></span><br><span class="line">import struct, sys</span><br><span class="line"></span><br><span class="line">def print_usage():</span><br><span class="line">    print &quot;&quot;</span><br><span class="line">    print &quot;Usage:&quot;</span><br><span class="line">    print sys.argv[0]</span><br><span class="line">    print &quot; &lt;r&gt; &lt;s&gt;&quot;</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    if len(sys.argv) !&#x3D; 3 or len(sys.argv[1]) !&#x3D; 64 or len(sys.argv[2]) !&#x3D; 64:</span><br><span class="line">        print_usage()</span><br><span class="line">        sys.exit(2)</span><br><span class="line"></span><br><span class="line">    r &#x3D; sys.argv[1]</span><br><span class="line">    s &#x3D; sys.argv[2]</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        r &#x3D; r.decode(&#39;hex&#39;)</span><br><span class="line">        s &#x3D; s.decode(&#39;hex&#39;)</span><br><span class="line">    except:</span><br><span class="line">        print_usage()</span><br><span class="line">        sys.exit(2)</span><br><span class="line"></span><br><span class="line">    int_len_r &#x3D; 0x20</span><br><span class="line">    int_len_s &#x3D; 0x20</span><br><span class="line">    if r[0] &gt; &#39;\x7F&#39;:</span><br><span class="line">        int_len_r +&#x3D; 1</span><br><span class="line">    if s[0] &gt; &#39;\x7F&#39;:</span><br><span class="line">        int_len_s +&#x3D; 1</span><br><span class="line">    seq_len &#x3D; 0x04 + int_len_r + int_len_s</span><br><span class="line"></span><br><span class="line">    with open(&#39;sig.der&#39;, &#39;wb&#39;) as f:</span><br><span class="line">        f.write(&#39;\x30&#39;)</span><br><span class="line">        f.write(struct.pack(&#39;&lt;B&#39;, seq_len))</span><br><span class="line"></span><br><span class="line">        f.write(&#39;\x02&#39;)</span><br><span class="line">        f.write(struct.pack(&#39;&lt;B&#39;, int_len_r))</span><br><span class="line">        if int_len_r &gt; 0x20:</span><br><span class="line">            f.write(&#39;\x00&#39;)</span><br><span class="line">        f.write(r)</span><br><span class="line"></span><br><span class="line">        f.write(&#39;\x02&#39;)</span><br><span class="line">        f.write(struct.pack(&#39;&lt;B&#39;, int_len_s))</span><br><span class="line">        if int_len_s &gt; 0x20:</span><br><span class="line">            f.write(&#39;\x00&#39;)</span><br><span class="line">        f.write(s)        </span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    try:</span><br><span class="line">        main()</span><br><span class="line">    except KeyboardInterrupt:</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Security</category>
      </categories>
  </entry>
  <entry>
    <title>Hash</title>
    <url>/2020/12/09/Security/Hash/</url>
    <content><![CDATA[<p>简单的短数据如 123 等，其 Hash 值很容易被解密</p>
<p>解密网站：<a href="http://www.ttmd5.com/hash.php?type=5">http://www.ttmd5.com/hash.php?type=5</a></p>
<a id="more"></a>

]]></content>
      <categories>
        <category>Security</category>
      </categories>
  </entry>
  <entry>
    <title>新和稳</title>
    <url>/2020/12/09/Thinking/%E6%96%B0%E5%92%8C%E7%A8%B3/</url>
    <content><![CDATA[<h2 id="用新还是用稳"><a href="#用新还是用稳" class="headerlink" title="用新还是用稳"></a>用新还是用稳</h2><p>在做 GATT CLI 时，GATT Client 有两个选择：</p>
<ul>
<li>Bluepy。BlueZ 的 Python 封装，运行在 Linux 上。</li>
<li>Zephyr。运行在 MCU 上。</li>
</ul>
<p>最初选择了 bluepy，因为得益于 Bluepy 的 Python 封装，编写和调试特别方便。并且可以运行在电脑上，无需外接设备。</p>
<p>但在实施过程中发现了一些问题：</p>
<ul>
<li><p>树莓派支持最好，但其它平台有问题。</p>
</li>
<li><p>启动蓝牙慢</p>
</li>
<li><p>连接 peripheral 慢</p>
</li>
<li><p>扫描信息不准确（macOS 的 Linux 虚拟机上）</p>
</li>
</ul>
<a id="more"></a>

<ul>
<li>偶现断开连接。</li>
<li>文档不全</li>
<li>难以调试</li>
</ul>
<p>总结下来就是：<code>不稳定，不熟悉，不放心</code>。</p>
<p>可以做 demo，但不可做产品。</p>
<p>最后还是选择了稳定并且熟悉的 Zephyr + nRF52832 组合。速度快，稳定，好调试。</p>
]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
  </entry>
  <entry>
    <title>OS X 和树莓派共享文件夹</title>
    <url>/2020/12/09/Boards/Raspberry%20Pi/OS%20X%20%E5%92%8C%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    <content><![CDATA[<p><a href="http://www.codeweblog.com/mac%E5%92%8C%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E5%92%8Ctm%E5%A4%87%E4%BB%BD">http://www.codeweblog.com/mac和树莓派实现文件共享和tm备份</a></p>
<p><a href="http://bbs.elecfans.com/forum.php?mod=viewthread&amp;tid=540731">http://bbs.elecfans.com/forum.php?mod=viewthread&amp;tid=540731</a></p>
<p>要用到的是 Netatalk</p>
<p>第一步：安装</p>
<p>sudo apt-get update</p>
<p>sudo apt-get install netatalk</p>
<p>第二步：配置</p>
<p>停止服务：sudo /etc/init.d/netatalk stop</p>
<a id="more"></a>

<p>打开配置文件：sudo nano /etc/netatalk/AppleVolumes.default</p>
<p>编辑安装文件夹或保留默认值：~/ “Home Directory”</p>
<p>打开服务：sudo /etc/init.d/netatalk start</p>
<p>第三步：打开搜索</p>
<p>在MAC打开搜索，几秒后你就能在共享面板中看到树莓派。</p>
]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
  </entry>
  <entry>
    <title>SWD 协议学习</title>
    <url>/2020/12/09/BSP/SWD/SWD%20%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="SWD-协议学习"><a href="#SWD-协议学习" class="headerlink" title="SWD 协议学习"></a>SWD 协议学习</h2><p><a href="https://blog.csdn.net/u010066882/article/details/56030473">https://blog.csdn.net/u010066882/article/details/56030473</a></p>
<p>主要参考 ARM 官方文档：ARM Debug Interface Architecture Specification ADIv5.0 to ADIv5.2 </p>
<p>ADI 是 ARM Debug Interface，目前是 ADIv5，即 version 5。</p>
<p>在 ADIv5 之前都是基于 IEEE 1149.1 JTAG interface 的实现，从 ADIv5 开始有了一个新的接口 SWD - Serial Wire Debug interface，所以 JTAG 是 SWD 是完全不同的两种接口。</p>
<p>ADIv5 分为两大部分：DP - Debug Port 和 AP - Access Port。</p>
<p>Debug Port 有两种： JTAG-DP 和 SW-DP</p>
<p>Access Port 也有两种：</p>
<a id="more"></a>

<p>​    JTAG-AP, for accessing legacy JTAG components.</p>
<p>​    MEM-AP, for accessing memory and components with memory-mapped interfaces.</p>
<p>DAP 是 Debug Access Port，是对 ADI 的具体实现，其实就是 DP + AP。</p>
<p>关于 SWD 接口的文档和翻译（个人理解）：</p>
<p>The SWD protocol uses a synchronous serial interface, which comprises a single bidirectional data signal, and a clock signal. </p>
<p>SWD 协议使用的是同步串行接口，包含一个双向数据信号线和一个时钟线。</p>
<p>When the target samples SWDIO, sampling is performed on the rising edge of SWCLK. When the target drives SWDIO, or stops driving it, signal changes are performed on the rising edge of SWCLK.</p>
<p><strong>当 MCU 在接收时，在时钟的上升沿采集数据，当 MCU 在发送时，在时钟的上升沿改变数据（也就意味着主机在时钟的下降沿采集数据）。</strong></p>
<p>The clock can be sourced from the target and exported, or provided by the host. This clock is then used by the host as a reference for generation and sampling of data so that the target is not required to perform any over-sampling.</p>
<p>Both the target and host can drive the bus HIGH and LOW or tristate it. The ports must be able to tolerate short periods of contention that might occur because of a loss of synchronization.</p>
<p>时钟可以由主机提供，也可以由 MCU 提供（没想到吧），由 MCU 来提供的好处是 MCU 不需要过采样了（此处不解，SWD 不是同步串行接口吗，为什么要过采样？）</p>
<p>由于主机和 MCU 都可以驱动总线，所以接口要能容忍因不同步造成的短暂电平竞争。</p>
<p>To make sure that the line is in a known state when neither host nor target is driving the line, a 100KΩ pull-up is required at the target. This pull-up can only be relied on to maintain the state of the wire. If the wire is driven LOW and released, the pull-up resistor eventually returns the line to the HIGH state, but this process takes many clock periods.</p>
<p>The pull-up is intended to prevent false detection of signals when no host is connected, and must be of a suitably high value to reduce current consumption from the target when the host actively pulls down the line.</p>
<p>为了让 SWD 接口悬空时能有一个确定的状态，MCU 上需要有一个 100K 的上拉电阻（所以说 MCU 芯片内部就已经有 100K 上拉了？）</p>
<p>A debugger must use a line reset sequence to ensure that hot-plugging the serial connection does not result in unintentional transfers. The line reset sequence ensures that the SW-DP is synchronized correctly to the header that signals a connection.</p>
<p>The SWD interface does not include a reset signal. A line reset is achieved by holding the data signal HIGH for at least 50 clock cycles, followed by at least two idle cycles. Figure B4-8 on page B4-123 shows the interface timing for a line reset followed by a DP DPIDR register read.</p>
<p>主机在连接 MCU 后首先要复位 SW-DP（注意，只是 Debug Port），然后才能后续的通信。以防止 SW-DP 处于不确定的状态。</p>
<p>由于 SWD 接口没有定义复位信号线，所以是通过一个特定的序列来实现复位的，具体是就是，保持数据线为高时发送至少 50 个时钟，然后再发送 2 个空闲周期。</p>
<p>Idle cycles，The host clocks the SWD interface with the line LOW to insert idle cycles.</p>
<p>空闲周期就是保持数据线为低时发送时钟。</p>
<p><img src="/2020/12/09/BSP/SWD/SWD%20%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20201123233156760.png"></p>
<p><strong>Basic operation</strong></p>
<p>The ARM SWD interface uses a single bidirectional data connection and a separate clock to transfer data synchronously. An operation on the wire consists of two or three phases:</p>
<p><strong>Packet request</strong></p>
<p>​    The external host debugger issues a request to the DP. The DP is the target of the request.</p>
<p><strong>Acknowledge response</strong></p>
<p>​    The target sends an acknowledge response to the host.</p>
<p><strong>Data transfer phase</strong></p>
<p>​    This phase is only present when either: </p>
<p>​        A data read or data write request is followed by a valid (OK) acknowledge response. </p>
<p>​        The CTRL/STAT.ORUNDETECT flag is 0b1. </p>
<p>​    The data transfer is one of: </p>
<p>​        Target to host, following a read request (RDATA).</p>
<p>​        Host to target, following a write request (WDATA).</p>
<p>每个 SWD <strong>基本操作</strong>由 3 步组成：请求 - 响应 - 数据（可选）</p>
<p>When the SW-DP receives a packet request from the debug host, it must respond immediately by entering the acknowledge phase. There is a turnaround period between these phases, as they are in different directions. If a data phase is required, it follows immediately after the acknowledge phase.</p>
<p>SW-DP 在收到主机的请求后，必须立即发出响应，然后才是可选的数据传输。这点和其他常见协议不同。</p>
<p><img src="/2020/12/09/BSP/SWD/SWD%20%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20201123233221700.png" alt="image-20201123233221700"></p>
<p><strong>Line turnaround</strong></p>
<p>To prevent contention, a turnaround period is required when the device driving the wire changes. For the turnaround period, neither the host nor the target drives the wire, and the state of the wire is undefined. See also Line pull-up on page B4-122.</p>
<p>Note</p>
<p>The line turnaround period can provide for pad delays when using a high sample clock frequency.</p>
<p>The length of the turnaround period is controlled by DLCR.TURNROUND. The default setting is a turnaround period of one clock cycle.</p>
<p>在 2 步之间，若数据线需要改变方向，那么会插入一个 turnaround 周期，用来给双方改变 IO 方向的时间，防止电平竞争。默认的 turnaround 时间是一个时钟。</p>
<p>![屏幕快照 2018-05-30 下午1.47.26](../resources/屏幕快照 2018-05-30 下午1.47.26.png)</p>
<p><strong>SELECT 和 Bandk</strong></p>
<p>主要参考章节：Using the Debug Port to access Access Ports</p>
<p>DPACC 用以访问 Debug Port 寄存器，APACC 用以访问 Access Port 寄存器。他们是一个<strong>基本操作</strong>，这个操作中指定的 RnW 位用以配置读/写操作，A[3:2] 域用以选择寄存器地址，Data[31:0] 是具体写的数据。</p>
<p>DP 只有 4 个寄存器（DPv0），A[3:2]  4 个地址刚好够用，但是 AP 可以有多个，并且每个 AP 也包含了多个寄存器，A[3:2]  地址完全不够用，怎么办呢？</p>
<p>于是每个 AP 中的寄存器被分为了多个 Bank，每个 Bank 内都有 4 个寄存器。使用 DP 中的 SELECT 寄存器的 APSEL 和 APBANKSEL 域分别选择一个 AP 和其中的一个 Bank。然后再用 APACC 的 A[3:2] 来选择 Bank 中 4 个寄存器其中的一个。</p>
<p>同样地，最新版本的 DP 扩展多个寄存器，以 DPv2 为例，其 0x4 地址被 5 个寄存器复用，要通过 SELECT 内的 DPBANKSEL 来选择使用哪一个。</p>
<p>文档中也给出了一个例子：</p>
<p>For example, to access the register at address 0x14 in the AP that is selected when SELECT.APSEL is 0x00, the debugger must: </p>
<p>• Use a DP register write to set: </p>
<p>​    — SELECT.APSEL to 0x00. </p>
<p>​    — SELECT.APBANKSEL to 0x1. </p>
<p>• Use an AP register access with A[3:2] = 0b01.</p>
<p>The DAP combines A[3:2] with SELECT.APBANKSEL to generate the AP register address, 0x14. The debugger can access any of the four registers from 0x10 to 0x1C without changing SELECT.</p>
<p>注意：SELECT，顾名思义，是用来选择的，若已经通过配置此寄存器选择好了 AP 和 Bank，那么接下来访问相同 AP 内相同 Bank 内的任意寄存器前就不用再次写 SELECT 寄存器了。可以把 SELECT 寄存器看作是总线复用器/多路选择器，只有在需要访问其他 AP 或 Bank 时才需要更新对应的域值。</p>
<p><img src="/2020/12/09/BSP/SWD/SWD%20%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20201123233240741.png"></p>
<p><strong>具体到 SWD 上的 APACC 和 DPACC</strong></p>
<p>举个写 CFG 寄存器的例子：</p>
<p>CFG 是属于 AP 的一个寄存器，地址为 0xF4。</p>
<p>第一步：通过 Packet Request 内 APnDP 置 0 来选择 DPACC，Rnw 置 1 来选择写操作，A[3:2] 置 0x8 来选择写 DP 内的 SELECT 寄存器，然后在 Data transfer phase 时把 CFG 寄存器所属于的 AP（0x0） 和 Bank（0xF）分别写入 SELECT 的 APSEL 和 APBANKSEL 域内。</p>
<p>第二步：通过 Packet Request 内 APnDP 置 1 来选择 DPACC，Rnw 置 1 来选择写操作，A[3:2] 置 0x4 来选择写 AP （0x）内 Bank（0xF）内的第一个寄存器。然后在 Data transfer phase 时把数据写入 CFG 寄存器。</p>
<p>逻辑分析仪抓包（注意：SWD 协议是 LSB）：</p>
<p>整个流程：</p>
<p><img src="/2020/12/09/BSP/SWD/SWD%20%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20201123233312354.png" alt="image-20201123233312354"></p>
<p>写 SELECT：</p>
<p><img src="/2020/12/09/BSP/SWD/SWD%20%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20201123233339963.png" alt="image-20201123233339963"></p>
<p><strong>DP 和 AP 的功能和关系</strong></p>
<p>Access Port (AP)</p>
<p>An AP uses a resource-specific transport mechanism to access debug information in the system to be debugged, and passes the information to the DP using the AP Access mechanism that is specified in this document.</p>
<p>A DAP must contain at least one AP, but if needed an ADI can implement multiple APs.</p>
<p>Debug Port (DP)</p>
<p>The DP provides a debugger with a common interface to access the information that is held in the APs.</p>
<p>可以类比分层协议，DP 实现了标准通用的 JTAG/SWD 协议收发功能，AP 实现了具体的资源读写功能，然后 DP 和 AP 之间再交互。</p>
<p><img src="/2020/12/09/BSP/SWD/SWD%20%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20201123233413784.png"></p>
<p><img src="/2020/12/09/BSP/SWD/SWD%20%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20201123233441709.png"></p>
<h2 id="SWD-中的数据校验"><a href="#SWD-中的数据校验" class="headerlink" title="SWD 中的数据校验"></a>SWD 中的数据校验</h2><p>A simple parity check is applied to all packet request and data transfer phases. Even parity is used.</p>
<p>SWD 使用简单的奇偶校验位来对传输的数据进行校验（除 ACK 外），具体来说，是计算 packet request 或者 data transfer 中为 1 的 bit 个数，若是奇数则奇偶校验位为1，否则为 0。</p>
<p>同时虽然双位同时发生错误的概率相当低，但奇偶校验却无法检测出双位错误。SWD 自带的校验不能完全保证数据传输无误，必须用户层加 CRC 才能保证数据无误。</p>
<p>2018-06-03 更新</p>
<p>根据资料，奇偶校验位失败的概率（把错误的当成正确的）是：</p>
<p><img src="/2020/12/09/BSP/SWD/SWD%20%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20201123233502195.png" alt="image-20201123233502195"></p>
<p>根据文档 <a href="https://faraday.physics.utoronto.ca/PVB/Drummond/Micro/ln_comm1.pdf%EF%BC%8C%E6%A6%82%E7%8E%87%E6%98%AF%EF%BC%9A">https://faraday.physics.utoronto.ca/PVB/Drummond/Micro/ln_comm1.pdf，概率是：</a></p>
<p>The length of pattern which each parity bit “guards” should be as long as possible so that the parity bit takes up the least amount of extra storage, but not so long that a double error becomes likely. Thus if the probability of a single bit being is error is 10-6, then the probability of an error in an 8-bit pattern (7 + parity) is about 8 x 10-6 and the probability of a double error is about 3 x 10-11 which is quite small. </p>
<p>有个矛盾之处：data bits 少，会造成 parity bit 占用多，data bits 多，又会导致误差概率变大，比如 32 bits 的情况下，误差概率就变大到 5 x 10^-10^了。</p>
<p>但是文档中也指出，有些特殊的情况下，bit 错误是成堆出现的，相临的 2 个 bit 会同时发生错误，此时未检测到的概率就是接近于每个 bit 的错误概率了。</p>
<p>An additional issue is that in some circumstances when an error does occur, it occurs in a clump - ie groups of bits may get corrupted together. Thus if the probability of one bit being currupted is P (small) then the probability of two successive bits being corrupted is not P2, but something much larger, maybe even approaching P.</p>
<h2 id="线序干扰问题"><a href="#线序干扰问题" class="headerlink" title="线序干扰问题"></a>线序干扰问题</h2><p>SWDIO 和 SWCLK 两条线是不能挨在一起的，否则会互相干扰导致错误。</p>
<p>JTAG 排线中这两根线之间是间隔了一根地线的，事实上 JTAG 的定义中所有的信号线之间有间隔有一根地线。</p>
]]></content>
      <categories>
        <category>SWD</category>
      </categories>
  </entry>
  <entry>
    <title>Raspbian 镜像使用帮助</title>
    <url>/2020/12/09/Boards/Raspberry%20Pi/Raspbian%20%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9/</url>
    <content><![CDATA[<h2 id="清华大学开源软件镜像站"><a href="#清华大学开源软件镜像站" class="headerlink" title="清华大学开源软件镜像站"></a>清华大学开源软件镜像站</h2><p>选择你的 Raspbian 对应的 Debian 版本:      Debian 7 (wheezy)  Debian 8 (jessie)  Debian 9 (stretch)  Debian 10 (buster) </p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 编辑 &#96;&#x2F;etc&#x2F;apt&#x2F;sources.list&#96; 文件，删除原文件所有内容，用以下内容取代：</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspbian&#x2F;raspbian&#x2F; buster main non-free contrib rpi</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspbian&#x2F;raspbian&#x2F; buster main non-free contrib rpi</span><br><span class="line"></span><br><span class="line"># 编辑 &#96;&#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;raspi.list&#96; 文件，删除原文件所有内容，用以下内容取代：</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspberrypi&#x2F; buster main ui</span><br></pre></td></tr></table></figure>

<p>注意：网址末尾的<code>raspbian</code>重复两次是必须的。因为 Raspbian 的仓库中除了APT软件源还包含其他代码。APT软件源不在仓库的根目录，而在<code>raspbian/</code>子目录下。</p>
<p>编辑镜像站后，请使用<code>sudo apt-get update</code>命令，更新软件源列表，同时检查您的编辑是否正确。</p>
<p>参考：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/raspbian/">https://mirrors.tuna.tsinghua.edu.cn/help/raspbian/</a></p>
]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
  </entry>
  <entry>
    <title>SSH 登陆树莓派</title>
    <url>/2020/12/09/Boards/Raspberry%20Pi/SSH%20%E7%99%BB%E9%99%86%E6%A0%91%E8%8E%93%E6%B4%BE/</url>
    <content><![CDATA[<p><a href="http://shumeipai.nxez.com/2017/09/13/raspberry-pi-network-configuration-before-boot.html">http://shumeipai.nxez.com/2017/09/13/raspberry-pi-network-configuration-before-boot.html</a></p>
<p>自 2016-11 官方发布的 Raspbian 系统镜像，系统默认禁用了 SSH 服务。在 SD 卡的 boot 磁盘根目录新建一个 ssh 空白文件即可。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd &#x2F;Volumes&#x2F;boot&#x2F;</span><br><span class="line">$ touch ssh</span><br></pre></td></tr></table></figure>

<p>然后用 arp 查找树莓派的 IP 地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ arp -a</span><br><span class="line">? (192.168.3.1) at 4:4f:4c:37:74:28 on en0 ifscope [ethernet]</span><br><span class="line">? (192.168.3.2) at 74:8d:8:c2:cd:84 on en0 ifscope [ethernet]</span><br><span class="line">? (192.168.3.33) at b8:27:eb:7e:b3:9e on en0 ifscope [ethernet]</span><br><span class="line">? (224.0.0.251) at 1:0:5e:0:0:fb on en0 ifscope permanent [ethernet]</span><br></pre></td></tr></table></figure>

<p>192.168.3.33 就是树莓派的地址，用 ssh 登陆之，用户名是 pi，密码是 raspberry：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh pi@192.168.3.33</span><br></pre></td></tr></table></figure>

<h3 id="免密码登陆"><a href="#免密码登陆" class="headerlink" title="免密码登陆"></a>免密码登陆</h3><p><a href="https://www.imooc.com/article/18859?block_id=tuijian_wz">https://www.imooc.com/article/18859?block_id=tuijian_wz</a></p>
<p>生成公钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>上传公钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i ~&#x2F;.ssh&#x2F;id_rsa.pub  pi@192.168.199.200</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
  </entry>
  <entry>
    <title>备份树莓派镜像并批量克隆</title>
    <url>/2020/12/09/Boards/Raspberry%20Pi/%E5%A4%87%E4%BB%BD%E6%A0%91%E8%8E%93%E6%B4%BE%E9%95%9C%E5%83%8F%E5%B9%B6%E6%89%B9%E9%87%8F%E5%85%8B%E9%9A%86/</url>
    <content><![CDATA[<p>在一个树莓派上开发好功能后，若要批量的生产，最方便的方法是直接将镜像备份下来，并批量复制到 SD 卡中。</p>
<p>插入待备份的 SD 卡并执行命令：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dd bs&#x3D;1m of&#x3D;raspbian-backup.img if&#x3D;&#x2F;dev&#x2F;rdisk2</span><br></pre></td></tr></table></figure>

<p>raspbian-backup.img 就是备份的树莓派镜像，可用以批量克隆生产树莓派系统。建议都使用相同的 SD 卡型号。</p>
]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
  </entry>
  <entry>
    <title>树莓派外设开发</title>
    <url>/2020/12/09/Boards/Raspberry%20Pi/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%A4%96%E8%AE%BE%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="WiringPi"><a href="#WiringPi" class="headerlink" title="WiringPi"></a>WiringPi</h2><p><a href="https://github.com/WiringPi">https://github.com/WiringPi</a></p>
<p><a href="https://blog.csdn.net/messidona11/article/details/71514329?fps=1&amp;locationNum=11">https://blog.csdn.net/messidona11/article/details/71514329?fps=1&amp;locationNum=11</a></p>
<p><a href="http://www.waveshare.net/study/article-742-1.html">http://www.waveshare.net/study/article-742-1.html</a></p>
<p>RPi.GPIO目前还不支持I2C、SPI等接口，且缺乏高精度定时功能。wiringpi除了提供C语言接口之外，目前已经支持Python等语言的扩展。对于GPIO的操作非常强大</p>
<p>安装 WiringPi Library：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install wiringpi</span><br></pre></td></tr></table></figure>

<p>安装 WiringPi Python：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install wiringpi</span><br></pre></td></tr></table></figure>

<p>读取树莓派引脚表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gpio readall</span><br><span class="line"> +-----+-----+---------+------+---+---Pi 3---+---+------+---------+-----+-----+</span><br><span class="line"> | BCM | wPi |   Name  | Mode | V | Physical | V | Mode | Name    | wPi | BCM |</span><br><span class="line"> +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+</span><br><span class="line"> |     |     |    3.3v |      |   |  1 || 2  |   |      | 5v      |     |     |</span><br><span class="line"> |   2 |   8 |   SDA.1 |   IN | 1 |  3 || 4  |   |      | 5v      |     |     |</span><br><span class="line"> |   3 |   9 |   SCL.1 |   IN | 1 |  5 || 6  |   |      | 0v      |     |     |</span><br><span class="line"> |   4 |   7 | GPIO. 7 |   IN | 1 |  7 || 8  | 0 | IN   | TxD     | 15  | 14  |</span><br><span class="line"> |     |     |      0v |      |   |  9 || 10 | 1 | IN   | RxD     | 16  | 15  |</span><br><span class="line"> |  17 |   0 | GPIO. 0 |   IN | 0 | 11 || 12 | 0 | IN   | GPIO. 1 | 1   | 18  |</span><br><span class="line"> |  27 |   2 | GPIO. 2 |   IN | 0 | 13 || 14 |   |      | 0v      |     |     |</span><br><span class="line"> |  22 |   3 | GPIO. 3 |   IN | 0 | 15 || 16 | 0 | IN   | GPIO. 4 | 4   | 23  |</span><br><span class="line"> |     |     |    3.3v |      |   | 17 || 18 | 0 | IN   | GPIO. 5 | 5   | 24  |</span><br><span class="line"> |  10 |  12 |    MOSI |   IN | 0 | 19 || 20 |   |      | 0v      |     |     |</span><br><span class="line"> |   9 |  13 |    MISO |   IN | 0 | 21 || 22 | 0 | IN   | GPIO. 6 | 6   | 25  |</span><br><span class="line"> |  11 |  14 |    SCLK |   IN | 0 | 23 || 24 | 1 | IN   | CE0     | 10  | 8   |</span><br><span class="line"> |     |     |      0v |      |   | 25 || 26 | 1 | IN   | CE1     | 11  | 7   |</span><br><span class="line"> |   0 |  30 |   SDA.0 |   IN | 1 | 27 || 28 | 1 | IN   | SCL.0   | 31  | 1   |</span><br><span class="line"> |   5 |  21 | GPIO.21 |   IN | 1 | 29 || 30 |   |      | 0v      |     |     |</span><br><span class="line"> |   6 |  22 | GPIO.22 |   IN | 1 | 31 || 32 | 0 | IN   | GPIO.26 | 26  | 12  |</span><br><span class="line"> |  13 |  23 | GPIO.23 |   IN | 0 | 33 || 34 |   |      | 0v      |     |     |</span><br><span class="line"> |  19 |  24 | GPIO.24 |   IN | 0 | 35 || 36 | 0 | IN   | GPIO.27 | 27  | 16  |</span><br><span class="line"> |  26 |  25 | GPIO.25 |   IN | 0 | 37 || 38 | 0 | IN   | GPIO.28 | 28  | 20  |</span><br><span class="line"> |     |     |      0v |      |   | 39 || 40 | 0 | IN   | GPIO.29 | 29  | 21  |</span><br><span class="line"> +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+</span><br><span class="line"> | BCM | wPi |   Name  | Mode | V | Physical | V | Mode | Name    | wPi | BCM |</span><br><span class="line"> +-----+-----+---------+------+---+---Pi 3---+---+------+---------+-----+-----+</span><br></pre></td></tr></table></figure>

<h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><p><a href="http://wiringpi.com/examples/blink/">http://wiringpi.com/examples/blink/</a></p>
<p>配置上下拉：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wiringPiSetup();</span><br><span class="line">pullUpDnControl(13, PUD_UP);</span><br></pre></td></tr></table></figure>

<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><p><a href="https://blog.csdn.net/messidona11/article/details/73957275?utm_source=gold_browser_extension">https://blog.csdn.net/messidona11/article/details/73957275?utm_source=gold_browser_extension</a></p>
<p>官方似乎没有提供详细的 API 文档，但是可以直接看源码：<a href="https://github.com/WiringPi/WiringPi/blob/master/wiringPi/wiringPiSPI.c">https://github.com/WiringPi/WiringPi/blob/master/wiringPi/wiringPiSPI.c</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int wiringPiSPIGetFd     (int channel) ;</span><br><span class="line">int wiringPiSPIDataRW    (int channel, unsigned char *data, int len) ;</span><br><span class="line">int wiringPiSPISetupMode (int channel, int speed, int mode) ;</span><br><span class="line">int wiringPiSPISetup     (int channel, int speed) ;</span><br></pre></td></tr></table></figure>

<p>Raspian 默认不使能 SPI，需要在 raspi-config 内 enable SPI interface。</p>
<p>在 /dev 内会出现两个 SPI 设备 spidev0.0 和 spidev0.1，这两个设备共用 MOSI，MISO 和 SCLK，NSS 分别是 CE0 和 CE1，引脚序号如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----+-----+---------+------+---+---Pi 3---+---+------+---------+-----+-----+</span><br><span class="line">| BCM | wPi |   Name  | Mode | V | Physical | V | Mode | Name    | wPi | BCM |</span><br><span class="line">+-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+</span><br><span class="line">|  10 |  12 |    MOSI |   IN | 0 | 19 || 20 |   |      | 0v      |     |     |</span><br><span class="line">|   9 |  13 |    MISO |   IN | 0 | 21 || 22 | 0 | IN   | GPIO. 6 | 6   | 25  |</span><br><span class="line">|  11 |  14 |    SCLK |   IN | 0 | 23 || 24 | 1 | IN   | CE0     | 10  | 8   |</span><br><span class="line">|     |     |      0v |      |   | 25 || 26 | 1 | IN   | CE1     | 11  | 7   |</span><br></pre></td></tr></table></figure>

<p>注意，wiringpi 的作者 Gordon 只提供了 C/C++ 版本实现，其他语言的 wrappers 由其他开发者提供，如 Python 是 <a href="http://pi.gadgetoid.co.uk/">Gadgetoid</a> 实现的。</p>
<blockquote>
<p><strong>Other wiringPi resources:</strong></p>
<ul>
<li>Thanks to <a href="http://pi.gadgetoid.co.uk/">Gadgetoid</a> there are now wrappers for Ruby, Python and Perl and these can all be <a href="https://github.com/WiringPi">found here</a>.</li>
<li>Thanks to <a href="http://jkransen.wordpress.com/2012/07/16/raspberry-pi/">Jeroen Kransen</a> there are wrappers for Java which can be <a href="https://github.com/jkransen/framboos">found here</a>.</li>
<li>Thanks to Dave Boulton for creating a TCL wrapper  which can be <a href="https://github.com/davidb24v/WiringPi-Tcl">found here</a>.</li>
<li><a href="http://pi4j.com/">Pi4J</a> is another Java project that uses WiringPi. It has a <a href="https://github.com/Pi4J/pi4j/">Github repository here</a>.</li>
</ul>
</blockquote>
<p>Python 的 wiringpi 代码仓库：<a href="https://github.com/WiringPi/WiringPi-Python">https://github.com/WiringPi/WiringPi-Python</a></p>
<p>使用 Python wiringpi 的 SPI 要特别注意，wiringPiSPIDataRW( channel ,data ) 的 data 参数是会被修改的，由于没有仔细看文档，我被这个坑了很久。</p>
<blockquote>
<p><strong>SPI:</strong></p>
<p>The <code>wiringPiSPIDataRW()</code> function needs to be passed a <code>bytes</code> object in Python 3. In Python 2, it takes a string. The following should work in either Python 2 or 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wiringpi.wiringPiSPISetup(channel, speed)</span><br><span class="line">buf &#x3D; bytes([your data here])</span><br><span class="line">retlen, retdata &#x3D; wiringpi.wiringPiSPIDataRW(0, buf)</span><br></pre></td></tr></table></figure>

<p>Now, <code>retlen</code> will contain the number of bytes received/read by the call.  <code>retdata</code> will contain the data itself, and <strong>==in Python 3, <code>buf</code> will have been modified to contain it as well==</strong> (that won’t happen in Python 2, because then <code>buf</code> is a string, and strings are immutable).</p>
</blockquote>
<p>令人蛋痛的是不管用 bytes() 还是 copy()，最后 data 的值还是被修改了，只能用 buf =bytes.fromhex(data.hex())  或者 buf = bytes(bytearray(data)) 这样的方法来避免问题了。</p>
<p>更蛋痛的是作者自己也说了，这个不是官方移植版本的，那就意味着可能会有很多碧游鸡，在使用过程中果然遇到了一些坑爹的地方，比如 wiringPiSPIDataRW 的 data 参数超过了 0x1000 就会 segment fault 等。</p>
<blockquote>
<p><strong>Note</strong></p>
<p>This is an unofficial port of Gordon’s WiringPi library. Please do not email Gordon if you have issues, he will not be able to help.</p>
<p>For support, comments, questions, etc please join the WiringPi Discord channel: <a href="https://discord.gg/SM4WUVG">https://discord.gg/SM4WUVG</a></p>
</blockquote>
<p>所以，在官方移植 Python之前，还是不要用这个坑爹的仓库了。</p>
<hr>
<p>2018-04-06 更新</p>
<p>看来我是冤枉 Gadgetoid 这位大神了，wiringpi 中 SPI 一次发送的数据本来就最大只有 4K。</p>
<p>不过实际测试下来，读取 2M 的 SPI Flash，python 用 2.9s, C 用了 1.5s，几乎是 C 的 2 倍多时间，所以还是 C 的效率快。</p>
<h2 id="SPI-Flash"><a href="#SPI-Flash" class="headerlink" title="SPI Flash"></a>SPI Flash</h2><p><a href="https://github.com/nopnop2002/Raspberry-W25Q64/blob/master/W25Q64.c">https://github.com/nopnop2002/Raspberry-W25Q64/blob/master/W25Q64.c</a></p>
<p>一个日本人用 wiringpi 实现的 SPI Flash 驱动。</p>
<h2 id="树莓派安装-RTC-时钟"><a href="#树莓派安装-RTC-时钟" class="headerlink" title="树莓派安装 RTC 时钟"></a>树莓派安装 RTC 时钟</h2><p>安装 RTC 时钟后，树莓派就不用网络时间来同步了（可以不接外网）。</p>
<p><a href="https://www.raspberrypi-spy.co.uk/2015/05/adding-a-ds3231-real-time-clock-to-the-raspberry-pi/">https://www.raspberrypi-spy.co.uk/2015/05/adding-a-ds3231-real-time-clock-to-the-raspberry-pi/</a></p>
<h3 id="DS1307-or-DS3231"><a href="#DS1307-or-DS3231" class="headerlink" title="DS1307 or DS3231?"></a>DS1307 or DS3231?</h3><p>Modules based on the DS1307 and DS3231 chips are popular devices and you’ll see them for sale from various retailers. I purchased both types and quickly realised my DS1307 modules were useless. My advice would be to go for a DS3231 based module. They are more accurate and run happily from 3.3V. My two “Tiny RTC” DS1307 modules went straight in the bin.</p>
<h3 id="I2C-Setup"><a href="#I2C-Setup" class="headerlink" title="I2C Setup"></a>I2C Setup</h3><p>As with all I2C devices you must configure the I2C interface. This is quite easy to do and explained in my <a href="https://www.raspberrypi-spy.co.uk/2014/11/enabling-the-i2c-interface-on-the-raspberry-pi/">Enabling The I2C Interface On The Raspberry Pi</a> tutorial.</p>
<h3 id="DS3231-Module-Setup"><a href="#DS3231-Module-Setup" class="headerlink" title="DS3231 Module Setup"></a>DS3231 Module Setup</h3><p>Now we need to modify a system file using :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nano &#x2F;etc&#x2F;modules</span><br></pre></td></tr></table></figure>

<p>If it isn’t already there add “rtc-ds1307” to the bottom so it looks something like :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">snd-bcm2835</span><br><span class="line">i2c-bcm2835</span><br><span class="line">i2c-dev</span><br><span class="line">rtc-ds1307</span><br></pre></td></tr></table></figure>

<p>Shutdown the Pi using “sudo halt” and remove the power when it has completed the process.</p>
<h3 id="Interface-Test"><a href="#Interface-Test" class="headerlink" title="Interface Test"></a>Interface Test</h3><p>Power up the Pi and run the following command :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo i2cdetect -y 1</span><br></pre></td></tr></table></figure>

<p>You should see something similar to this :</p>
<p><img src="/2020/12/09/Boards/Raspberry%20Pi/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%A4%96%E8%AE%BE%E5%BC%80%E5%8F%91/ds3231_rtc_module_01.png" alt="DS3231 RTC Module Config"></p>
<p>In this example “68” is the hex address of the RTC module on the I2C interface.</p>
<h3 id="I2C-Device-Setup"><a href="#I2C-Device-Setup" class="headerlink" title="I2C Device Setup"></a>I2C Device Setup</h3><p>To ensure the DS1307 device is setup and the time synchronised when the Pi boots we need to edit another system file :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nano &#x2F;etc&#x2F;rc.local</span><br></pre></td></tr></table></figure>

<p>Add the following two lines before the exit 0 line :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo ds1307 0x68 &gt; &#x2F;sys&#x2F;class&#x2F;i2c-adapter&#x2F;i2c-1&#x2F;new_device</span><br><span class="line">hwclock -s</span><br></pre></td></tr></table></figure>

<p>so it looks something like :</p>
<p><a href="https://www.raspberrypi-spy.co.uk/2015/05/adding-a-ds3231-real-time-clock-to-the-raspberry-pi/ds1308_rtc_module_06/"><img src="/2020/12/09/Boards/Raspberry%20Pi/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%A4%96%E8%AE%BE%E5%BC%80%E5%8F%91/ds1308_rtc_module_06.png" alt="DS1307 RTC Module Config"></a></p>
<p>Now reboot the Pi using :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>

<p>Now when you repeat the i2cdetect command (see above) the 68 will turn into UU :</p>
<p><img src="/2020/12/09/Boards/Raspberry%20Pi/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%A4%96%E8%AE%BE%E5%BC%80%E5%8F%91/ds3231_rtc_module_02.png" alt="DS3231 RTC Module Config"></p>
<h3 id="Reading-The-Date-And-Time"><a href="#Reading-The-Date-And-Time" class="headerlink" title="Reading The Date And Time"></a>Reading The Date And Time</h3><p>You can read the Pi’s system time using :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure>

<p>Once correct you can write the system date and time to the RTC module using :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo hwclock -w</span><br></pre></td></tr></table></figure>

<p>You should be able to read the date and time back from the RTC using :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo hwclock -r</span><br></pre></td></tr></table></figure>

<p>By separating the commands with a semi-colon you can read back the system time and the RTC time at the same time. Hopefully they should match and look something like this :</p>
<p><img src="/2020/12/09/Boards/Raspberry%20Pi/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%A4%96%E8%AE%BE%E5%BC%80%E5%8F%91/ds3231_rtc_module_03.png" alt="DS3231 RTC Module Config"></p>
<p>The “hwclock -s” we added to “rc.local” sets the system time from the RTC module.</p>
<h3 id="The-Final-Test"><a href="#The-Final-Test" class="headerlink" title="The Final Test"></a>The Final Test</h3><p>The final test is to determine if the RTC module is keeping time and that the Pi will use that time when it boots. The best way to do that is to :</p>
<ul>
<li>Power down the Pi</li>
<li>Remove the power cable</li>
<li>Remove the network connection</li>
<li>Attach the Pi to a monitor and keyboard</li>
<li>Leave it overnight</li>
<li>Power it up and use “date” to see what time the Pi thinks it is</li>
</ul>
<h2 id="mmap-操作-IO-的同步问题"><a href="#mmap-操作-IO-的同步问题" class="headerlink" title="mmap 操作 IO 的同步问题"></a>mmap 操作 IO 的同步问题</h2><p>在用树莓派 IO 模拟 SPI，频率高于 1MHz 就经常读取错误，逻辑分析仪抓波发现是时钟有异常：</p>
<p><img src="/2020/12/09/Boards/Raspberry%20Pi/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%A4%96%E8%AE%BE%E5%BC%80%E5%8F%91/image-20201208213936798.png" alt="image-20201208213936798"></p>
<p>如红框内，SCK 应该在箭头处拉低，正确的波形如红色线标出，但是实际上却延迟了一段时间才拉低，导致了波形异常。</p>
<p>可以用 msync 函数来把共享内容的改变直接写回到磁盘文件，但是此函数效率太低，所以用了个折中的办法，在拉低/高 IO 后，循环读取 IO 电平直到生效为止。</p>
<h2 id="IO-反转速度问题"><a href="#IO-反转速度问题" class="headerlink" title="IO 反转速度问题"></a>IO 反转速度问题</h2><p>写了一个 SPI bitbang 驱动，发现 IO 翻转速度达不到理想，测试看是代码运行花费时间较长，默认的编译是 -O0，也就是不优化，看了 OpenOCD 是 -O2，于是也设置为 -O2，速度就提高了 2 倍。</p>
]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
  </entry>
  <entry>
    <title>树莓派 Qt 开发</title>
    <url>/2020/12/09/Boards/Raspberry%20Pi/%E6%A0%91%E8%8E%93%E6%B4%BE%20Qt%20%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="安装-PyQt5"><a href="#安装-PyQt5" class="headerlink" title="安装 PyQt5"></a>安装 PyQt5</h2><p><a href="https://blog.csdn.net/xqf1528399071/article/details/52248023">https://blog.csdn.net/xqf1528399071/article/details/52248023</a></p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python3-pyqt5   </span><br></pre></td></tr></table></figure>

<p>注意：树莓派不能使用 pip3 安装 pyqt5</p>
]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
  </entry>
  <entry>
    <title>树莓派开发杂记</title>
    <url>/2020/12/09/Boards/Raspberry%20Pi/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E5%8F%91%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="隐藏任务栏"><a href="#隐藏任务栏" class="headerlink" title="隐藏任务栏"></a>隐藏任务栏</h2><p>有时候需要把自己的程序布满整个屏幕，用户只能操作这个界面，就需要把任务栏隐藏起来</p>
<p>可以右键任务栏，选择 Panel Preference，把 Geometry 中 Size 的 Width 设置为 0，这样任务栏的长度就是 0 了，就看不见了，保险起见，把 Advanced 中 Automatic hiding 的 Minimise panel when not in use 勾选上，并把 Size when minimised 设为 0。</p>
<a id="more"></a>

<h2 id="问题：sudo-unable-to-resolve-host-raspberrypisnowyang"><a href="#问题：sudo-unable-to-resolve-host-raspberrypisnowyang" class="headerlink" title="问题：sudo: unable to resolve host raspberrypisnowyang"></a>问题：sudo: unable to resolve host raspberrypisnowyang</h2><p>在执行 sudo 命令时出现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo: unable to resolve host raspberrypisnowyang</span><br></pre></td></tr></table></figure>

<p>虽然命令最终成功了，但是卡住了一段时间，估计是在试图解析 host 超时了。</p>
<p>我的 host 是 raspberrypi@snowyang，但是错误信息里是 raspberrypisnowyang，估计就是这个 @ 符号让 sudo 以为是个域名进而解析导致了问题。</p>
<p>sudo raspi-config 吧 host name 中的 @ 去掉就好了</p>
<h2 id="OpenOCD-不启动服务器"><a href="#OpenOCD-不启动服务器" class="headerlink" title="OpenOCD 不启动服务器"></a>OpenOCD 不启动服务器</h2><p>OpenOCD 默认会启动 TCP, Telnet 和 TCL 服务器，在频繁开关 OpenOCD 时会可能会造成问题，所以可使用 <code>-c &quot;gdb_port disabled&quot; -c &quot;tcl_port disabled&quot; -c &quot;telnet_port disabled&quot;</code> 选项来不启动这些服务器。</p>
<h2 id="SCP-传输文件"><a href="#SCP-传输文件" class="headerlink" title="SCP 传输文件"></a>SCP 传输文件</h2><p><a href="http://www.runoob.com/linux/linux-comm-scp.html">http://www.runoob.com/linux/linux-comm-scp.html</a></p>
<p>netatalk 可以很方便的共享文件夹，可是 Raspberry 默认是没有安装此服务的，在上不了外网的情况下，还可以用自带的 scp 来传输文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp local_file remote_username@remote_ip:remote_file </span><br><span class="line">scp -r local_folder remote_username@remote_ip:remote_folder </span><br></pre></td></tr></table></figure>

<h2 id="虚拟键盘"><a href="#虚拟键盘" class="headerlink" title="虚拟键盘"></a>虚拟键盘</h2><p><a href="https://blog.csdn.net/xuelanlingying/article/details/78408617?locationNum=6&amp;fps=1">https://blog.csdn.net/xuelanlingying/article/details/78408617?locationNum=6&amp;fps=1</a></p>
<h2 id="设置静态-IP-地址"><a href="#设置静态-IP-地址" class="headerlink" title="设置静态 IP 地址"></a>设置静态 IP 地址</h2><p><a href="https://www.cnblogs.com/taojintianxia/p/6026225.html">https://www.cnblogs.com/taojintianxia/p/6026225.html</a></p>
<p>修改*/etc/dhcpcd.conf* 文件</p>
<p>sudo vim <em>/etc/dhcpcd.conf</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface eth0</span><br><span class="line"></span><br><span class="line">static ip_address&#x3D;10.0.0.2&#x2F;24</span><br><span class="line">static routers&#x3D;10.0.0.1</span><br><span class="line">static domain_name_servers&#x3D;10.0.0.1</span><br><span class="line"></span><br><span class="line">interface wlan0</span><br><span class="line"></span><br><span class="line">static ip_address&#x3D;10.0.0.3&#x2F;24</span><br><span class="line">static routers&#x3D;10.0.0.1</span><br><span class="line">static domain_name_servers&#x3D;10.0.0.1</span><br></pre></td></tr></table></figure>

<p>上面的配置文件中 , eth0是有线的配置  , wlan0是无线配置</p>
<p>ip_address就是静态IP , 后面要接/24</p>
<p>routers是网关sudo </p>
<p>static domain_name_servers是DNS</p>
<h2 id="禁止休眠，屏幕常亮"><a href="#禁止休眠，屏幕常亮" class="headerlink" title="禁止休眠，屏幕常亮"></a>禁止休眠，屏幕常亮</h2><p><a href="https://blog.csdn.net/u011720560/article/details/78288128">https://blog.csdn.net/u011720560/article/details/78288128</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">该设置应用于2017-06-21-raspbian-jessie版本</span><br></pre></td></tr></table></figure>

<p>我想让连接树莓派的HDMI屏幕一直显示，然后从网上找了许多关于禁止休眠的设置，最终找到了方法，那些方法估计是用在老版本系统上的。<br>其中Raspbian使用了轻量桌面显示管理器即lightdm,通过该管理器可对xserver桌面会话交互、显示等进行设置.</p>
<p>步骤</p>
<p>1.打开lightdm.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;lightdm&#x2F;lightdm.conf</span><br></pre></td></tr></table></figure>

<p>2.修改lightdm.conf</p>
<p>找到[SeatDefaults]段下的’xserver-command’,取消注释,修改为如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#xserver-command&#x3D;X</span><br></pre></td></tr></table></figure>

<p>修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xserver-command&#x3D;X -s 0 -dpms</span><br></pre></td></tr></table></figure>

<ul>
<li>-s # –设置屏幕保护不启用</li>
<li>dpms 关闭电源节能管理</li>
</ul>
<p>3.重启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>

<p>参考连接</p>
<p><a href="https://raspberrypi.stackexchange.com/questions/4773/raspberry-pi-sleep-mode-how-to-avoid">raspberry-pi-sleep-mode-how-to-avoid</a></p>
<h2 id="VNC-连接树莓派"><a href="#VNC-连接树莓派" class="headerlink" title="VNC 连接树莓派"></a>VNC 连接树莓派</h2><p><a href="https://blog.csdn.net/u012952807/article/details/70225700">https://blog.csdn.net/u012952807/article/details/70225700</a></p>
<p>树莓派的Raspbian集成了VNC Server，默认却是不开启的，需要 raspi-config 的 interface 内开启，然后 reboot 后生效。</p>
<p>VNC client 推荐使用 VNC viewer：<a href="http://mac.softpedia.com/get/Network-Admin/VNC-Viewer.shtml">http://mac.softpedia.com/get/Network-Admin/VNC-Viewer.shtml</a></p>
<h2 id="使用-waveshare-的-5-寸屏幕"><a href="#使用-waveshare-的-5-寸屏幕" class="headerlink" title="使用 waveshare 的 5 寸屏幕"></a>使用 waveshare 的 5 寸屏幕</h2><p><a href="http://www.waveshare.net/wiki/5inch_HDMI_LCD_(B)">http://www.waveshare.net/wiki/5inch_HDMI_LCD_(B)</a></p>
<p>在 /boot 目录下的 config.txt 文件尾部追加：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">max_usb_current&#x3D;1</span><br><span class="line">hdmi_group&#x3D;2</span><br><span class="line">hdmi_mode&#x3D;1</span><br><span class="line">hdmi_mode&#x3D;87</span><br><span class="line">hdmi_cvt 800 480 60 6 0 0 0</span><br><span class="line">hdmi_drive&#x3D;1</span><br></pre></td></tr></table></figure>

<h2 id="图形界面开发快捷方法"><a href="#图形界面开发快捷方法" class="headerlink" title="图形界面开发快捷方法"></a>图形界面开发快捷方法</h2><p>使用 VNC 连接树莓派作显示，使用 Netatalk 来直接访问并编辑树莓派上的代码，比树莓派直接连个显示器来开发要方便多了。</p>
<h2 id="PyInstaller"><a href="#PyInstaller" class="headerlink" title="PyInstaller"></a>PyInstaller</h2><p>在树莓派上 pip3 installer pyinstaller 后，在 shell 中却找不到 pyinstaller 可执行文件，用 pip3 show -f pyinstaller 查看发现其路径在 /home/pi/.local/bin/ 目录下，而此目录不在 PATH 内，所以 shell 内找不到 pyinstaller，很简单，把其在 .bashrc 加入 PATH 就好了: PATH=$PATH:/home/pi/.local/bin/</p>
<h2 id="raspi-config-的命令行用法"><a href="#raspi-config-的命令行用法" class="headerlink" title="raspi-config 的命令行用法"></a>raspi-config 的命令行用法</h2><p>在把树莓派用作产品批量生产时，用图形化的 raspi-config 是低效且易错的，所以命令行模式的 raspi-config 就很有用了</p>
<p><a href="http://www.52pi.net/archives/623">http://www.52pi.net/archives/623</a></p>
<p><a href="https://github.com/raspberrypi-ui/rc_gui/blob/master/src/rc_gui.c#L23-L70">https://github.com/raspberrypi-ui/rc_gui/blob/master/src/rc_gui.c#L23-L70</a></p>
<p>比如说要 expand filesystem，那么使用命令：<code>sudo raspi-config nonint do_expand_rootfs</code> 就可以了。</p>
<p>这样的好处是可以把配置命令集合到 shell 脚本内，生产时只需执行这个脚本就可以配置好树莓派了。</p>
<h2 id="树莓派-Wi-Fi-抓包"><a href="#树莓派-Wi-Fi-抓包" class="headerlink" title="树莓派 Wi-Fi 抓包"></a>树莓派 Wi-Fi 抓包</h2><p><a href="https://www.jianshu.com/p/8a27249997c0">https://www.jianshu.com/p/8a27249997c0</a></p>
<p><a href="http://www.360zhijia.com/360anquanke/309676.html">http://www.360zhijia.com/360anquanke/309676.html</a></p>
<p><a href="https://blog.csdn.net/QS_0928/article/details/77387335">https://blog.csdn.net/QS_0928/article/details/77387335</a></p>
<p><a href="https://www.cnblogs.com/sjqlwy/p/zero_otg.html">https://www.cnblogs.com/sjqlwy/p/zero_otg.html</a></p>
<p>应该可以用在 windows 上抓包</p>
<h2 id="USB-供电和-HUB"><a href="#USB-供电和-HUB" class="headerlink" title="USB 供电和 HUB"></a>USB 供电和 HUB</h2><p>若屏幕使用 USB 供电，那么接入的 HUB 就必须自带电源供电，否则 USB 插入设备不被识别。</p>
<h2 id="性能模式和-CPU-主频"><a href="#性能模式和-CPU-主频" class="headerlink" title="性能模式和 CPU 主频"></a>性能模式和 CPU 主频</h2><p><a href="http://bbs.elecfans.com/jishu_804044_1_1.html">http://bbs.elecfans.com/jishu_804044_1_1.html</a></p>
<p>树莓派默认的性能模式是 ondemand，即按需快速动态调整CPU频率，此模式下会根据供电，CPU 温度和计算量自动的调整频率。</p>
<p><a href="https://blog.csdn.net/zhenwenxian/article/details/6196943">https://blog.csdn.net/zhenwenxian/article/details/6196943</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cpufreq是一个动态调整cpu频率的模块，系统启动时生成一个文件夹&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cpufreq&#x2F;，里面有几个文件，其中scaling_min_freq代表最低频率，scaling_max_freq代表最高频率，scalin_governor代表cpu频率调整模式，用它来控制CPU频率。</span><br><span class="line"></span><br><span class="line">1，performance ：顾名思义只注重效率，将CPU频率固定工作在其支持的最高运行频率上，而不动态调节。</span><br><span class="line">2，powersave：将CPU频率设置为最低的所谓“省电”模式，CPU会固定工作在其支持的最低运行频率上。</span><br><span class="line"></span><br><span class="line">因此这两种governors 都属于静态governor，即在使用它们时CPU 的运行频率不会根据系统运行时负载的变化动态作出调整。这两种governors 对应的是两种极端的应用场景，使用performance governor 是对系统高性能的最大追求，而使用powersave governor 则是对系统低功耗的最大追求。</span><br><span class="line"></span><br><span class="line">3，Userspace：最早的cpufreq 子系统通过userspace governor为用户提供了这种灵活性。系统将变频策略的决策权交给了用户态应用程序，并提供了相应的接口供用户态应用程序调节CPU 运行频率使用。也就是长期以来都在用的那个模式。可以通过手动编辑配置文件进行配置。</span><br><span class="line">4，ondemand 按需快速动态调整CPU频率，一有cpu计算量的任务，就会立即达到最大频率运行，等执行完毕就立即回到最低频率。</span><br><span class="line">5，conservative 与ondemand不同，平滑地调整CPU频率，频率的升降是渐变式的,会自动在频率上下限调整，和ondemand的区别   在于它会按需分配频率，而不是一味追求最高频率。</span><br></pre></td></tr></table></figure>

<p>要修改性能模式，有以下三种方法：</p>
<ul>
<li><p>命令行内修改：</p>
<p><a href="https://www.guokr.com/post/687371/">https://www.guokr.com/post/687371/</a></p>
<p><code>sudo -i</code> 切换到root用户，然后再<code>echo powersave &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</code></p>
<p>或者：</p>
<p><a href="https://raspberrypi.stackexchange.com/questions/9034/how-to-change-the-default-governor?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa">https://raspberrypi.stackexchange.com/questions/9034/how-to-change-the-default-governor?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa</a></p>
<p><code>sudo sh -c &quot;echo powersave &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor&quot;</code></p>
</li>
<li><p>启动时修改：</p>
<p><a href="https://www.raspberrypi.org/forums/viewtopic.php?t=114536">https://www.raspberrypi.org/forums/viewtopic.php?t=114536</a></p>
<p>Have a look at /etc/init.d/raspi-config that controls the on-demand governor during boot up.</p>
<p>把 /etc/init.d/raspi-config 内的 ondemand 修改为 powersave</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">  start)</span><br><span class="line">    log_daemon_msg &quot;Checking if shift key is held down&quot;</span><br><span class="line">    if [ -x &#x2F;usr&#x2F;sbin&#x2F;thd ] &amp;&amp; timeout 1 thd --dump &#x2F;dev&#x2F;input&#x2F;event* | grep -q &quot;LEFTSHIFT\|RIGHTSHIFT&quot;; then</span><br><span class="line">      printf &quot; Yes. Not enabling powersave scaling governor&quot;</span><br><span class="line">      log_end_msg 0</span><br><span class="line">    else</span><br><span class="line">      printf &quot; No. Switching to powersave scaling governor&quot;</span><br><span class="line">      SYS_CPUFREQ_GOVERNOR&#x3D;&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cpufreq&#x2F;scaling_governor</span><br><span class="line">      if [ -e $SYS_CPUFREQ_GOVERNOR ]; then</span><br><span class="line">        echo &quot;powersave&quot; &gt; $SYS_CPUFREQ_GOVERNOR</span><br><span class="line">        echo 50 &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;ondemand&#x2F;up_threshold</span><br><span class="line">        echo 100000 &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;ondemand&#x2F;sampling_rate</span><br><span class="line">        echo 50 &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpufreq&#x2F;ondemand&#x2F;sampling_down_factor</span><br><span class="line">      fi</span><br><span class="line">      log_end_msg 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
  </entry>
  <entry>
    <title>树莓派开机自动启动GUI程序</title>
    <url>/2020/12/09/Boards/Raspberry%20Pi/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8GUI%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>有多种开机自启用户脚本命令的方法，可以参考：<a href="https://www.jianshu.com/p/86adb6d5347b">https://www.jianshu.com/p/86adb6d5347b</a></p>
<p>但是那都是在登录用户前的阶段启动的，而 GUI 程序，比如 Qt 需要依赖于桌面和各种服务，所以不能使用那些方法。</p>
<p>开机自启 Qt 程序的方法，可以参考：</p>
<p><a href="https://blog.csdn.net/dubuzherui/article/details/52846166">https://blog.csdn.net/dubuzherui/article/details/52846166</a></p>
<blockquote>
<p>用树莓派上用Qt进行图形界面开发，发现无法自动启动程序，找了好多方法都是不行。网上都是讲怎么启动脚本的，但是脚本的启动与图形程序是不同的。</p>
<p>树莓派开机启动流程：自动登录–&gt;自动启动窗口–&gt;自动运行用户程序</p>
<p>脚本程序可以在自动启动窗口这一步之前运行，但是用户程序是不行。下面来看一下怎么启动用户程序：</p>
<p>进入当前用户HOME目录下的.config目录(这是一个隐藏目录，需用ls -a显示出来)<br>cd ~/.config </p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>当前用户是pi, 其HOME目录是/home/pi, 上述命令相当于<br>cd /home/pi/.config<br>建立一个名为autostart的子目录,并进入该目录<br>mkdir autostart<br>cd autostart<br>生成一个*.desktop文件（比如：my.desktop），命令如下:<br>sudo nano my.desktop<br>输入以下文件内容:<br>[Desktop Entry]<br>Type=Application<br>Exec=Path<br>最后一句Exec的值就是要启动的程序名(最好是全路径的可执行文件名)，然后重启即可。<br>原理：startx后，LXDE窗口管理器会找到~/.config/autostart目录下的所有 .desktop文件，一一执行<br>把上述全部串起来，就是一上电：自动登录－自动启动窗口-自动运行程序</p>
</blockquote>
<p>再隐藏下任务栏和更换壁纸，开机后基本不会让使用者看到多余的内容。</p>
<p>注意：Exec 的值必须是个应用程序或者脚本，如果是多条命令的话，必须用放在一个脚本内，然后 Exec 来运行这个脚本。</p>
<p>注意：从 2017 年后，Raspbian 不再使用 PIXEL 替换 LXDE 作为桌面环境。</p>
<p><a href="http://shumeipai.nxez.com/2016/10/24/raspbian-pixel-desktop-coming.html">http://shumeipai.nxez.com/2016/10/24/raspbian-pixel-desktop-coming.html</a></p>
<p>注意：如果有多条命令，应该放在一个 shell 脚本内，然后 *.desktop 的 Exec 设置为这个脚本去执行</p>
<p>注意：如果没有 expand filesystem，可能会比较卡顿。</p>
]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
  </entry>
  <entry>
    <title>烧录树莓派镜像</title>
    <url>/2020/12/09/Boards/Raspberry%20Pi/%E7%83%A7%E5%BD%95%E6%A0%91%E8%8E%93%E6%B4%BE%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/freewebsys/article/details/48980993">https://blog.csdn.net/freewebsys/article/details/48980993</a></p>
<ol>
<li><p>下载镜像</p>
<p>去官网 <a href="https://www.raspberrypi.org/downloads/raspbian/">https://www.raspberrypi.org/downloads/raspbian/</a> 下载镜像，我下载的是 RASPBIAN STRETCH LITE，也就是没有桌面的，会小很多。</p>
</li>
<li><p>在 OS X 下安装镜像</p>
<ol>
<li><p>格式化 SD 卡</p>
<p>官方推荐使用 <a href="https://www.sdcard.org/downloads/formatter_4/">sdcard formatter</a>，操作简单点击下就行。</p>
</li>
<li><p>查看并卸载 SD 卡</p>
<p>查看 SD 卡磁盘</p>
</li>
</ol>
</li>
</ol>
<a id="more"></a>

<pre><code>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ df -lh</span><br><span class="line">Filesystem     Size   Used  Avail Capacity  iused   ifree %iused  Mounted on</span><br><span class="line">&#x2F;dev&#x2F;disk1    233Gi  215Gi   18Gi    93% 56386271 4592543   92%   &#x2F;</span><br><span class="line">&#x2F;dev&#x2F;disk2s1   30Gi  1.6Mi   30Gi     1%        0       0  100%   &#x2F;Volumes&#x2F;21 1</span><br></pre></td></tr></table></figure>

  记住磁盘叫/dev/disk2s1

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo diskutil umount &#x2F;dev&#x2F;disk2s1                                </span><br><span class="line">Volume 21 on disk2s1 unmounted</span><br></pre></td></tr></table></figure></code></pre>
<ol start="3">
<li><p>写入镜像</p>
<p><strong>特别注意写入文件没有s1且前面多了个r，/dev/disk2s1对应的输出文件是/dev/rdisk2）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo dd bs&#x3D;1m if&#x3D;2018-03-13-raspbian-stretch.img of&#x3D;&#x2F;dev&#x2F;rdisk2  </span><br><span class="line">4125+0 records in</span><br><span class="line">4125+0 records out</span><br><span class="line">4325376000 bytes transferred in 401.205151 secs (10780958 bytes&#x2F;sec)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>rdisk 和 disk 的区别：</p>
<p><a href="https://superuser.com/questions/631592/why-is-dev-rdisk-about-20-times-faster-than-dev-disk-in-mac-os-x">Why is “/dev/rdisk” about 20 times faster than “/dev/disk” in Mac OS X</a></p>
<p>According to the <a href="http://elinux.org/RPi_Easy_SD_Card_Setup">rasbery pi documentation</a>, You can load your OS to a flash card with either /dev/disk or /dev/rdisk. </p>
<p>rdisk stands for raw disk.</p>
<p>/dev/disk is a block level device, <strong>why would rdisk be 20 times faster?</strong></p>
<blockquote>
<p>Using Mac OSX</p>
<p>Note: In OS X each disk may have two path references in /dev: /dev/disk# is a buffered device, which means any data being sent undergoes extra processing. /dev/rdisk# is a raw path, which is much faster, and perfectly OK when using the dd program. On a Class 4 SD card the difference was around 20 times faster using the rdisk path.</p>
</blockquote>
<p>From <code>man hdiutil</code>:</p>
<blockquote>
<p>/dev/rdisk nodes are character-special devices, but are “raw” in the BSD sense and force block-aligned I/O. They are closer to the physical disk than the buffer cache. /dev/disk nodes, on the other hand, are buffered block-special devices and are used primarily by the kernel’s filesystem code.</p>
</blockquote>
<p>In layman’s terms <code>/dev/rdisk</code> goes almost directly to disk and <code>/dev/disk</code> goes via a longer more expensive route</p>
]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
  </entry>
  <entry>
    <title>Cotex-M0 and plus</title>
    <url>/2020/12/09/CPU/ARM/Cotex-M0%20and%20plus/</url>
    <content><![CDATA[<h2 id="M0-和-M0-的区别"><a href="#M0-和-M0-的区别" class="headerlink" title="M0 和 M0+ 的区别"></a>M0 和 M0+ 的区别</h2><p>参考：<a href="https://community.cypress.com/docs/DOC-10652">Cortex® -M0 Versus Cortex-M0+ - KBA211306</a></p>
<p>The Cortex-M0+ processor builds on the Cortex-M0 processor, retaining the full instruction set and tool compatibility, while reducing energy consumption and increasing performance. </p>
<p>The following table lists the difference in the features of the two processors.                                                                                                                                         </p>
<table>
<thead>
<tr>
<th><strong>Features</strong></th>
<th><strong>M0</strong></th>
<th><strong>M0+</strong></th>
<th><strong>Advantages of M0+ over M0</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Pipeline</td>
<td>Three-stage</td>
<td>Two-stage</td>
<td>Improved response time,improved efficiency</td>
</tr>
<tr>
<td>Performance Efficiency</td>
<td>2.33 CoreMark/MHz</td>
<td>2.46 CoreMark/MHz</td>
<td>Lower power and higher performance</td>
</tr>
<tr>
<td>Memory Protection</td>
<td>Not available</td>
<td>Has optional Memory protection Unit</td>
<td>Makes system more secure by: Separating processes – Preventing tasks from corrupting stack or data memory used by other tasks Preventing unprivileged tasks from accessing peripherals that can be critical to the system security</td>
</tr>
<tr>
<td>Relocatable vectortable</td>
<td>Does not support</td>
<td>Supports</td>
<td>Allows relocating the interrupt vector table anywhere in the memory - enables different applications to use their own vector table.</td>
</tr>
<tr>
<td>Unprivileged/privileged mode execution</td>
<td>Does not support</td>
<td>Supports</td>
<td>Allows a task, such as the system calling in an operating system, to execute with more privileges than the user task or an application.</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h2><p>Cortex-M0 使用了 ARMv6-M 指令集，该指令集由 2 部分组成：</p>
<ul>
<li>除 CBZ, CBNZ 和 IT 外的所有 ARMv7-M 指令。</li>
<li>32-bit Thumb-2 指令：BL, DMB, DSB, ISB, MRS and MSR。</li>
</ul>
<p><em>Reference &lt; Cotex-M0 Technical Reference Manual &gt; 3.3 Instruction set summary</em></p>
<p>所以在移植 Cortex-M3 的汇编代码到 Cortex-M0 时要注意两点：</p>
<ul>
<li>CBZ 指令要用 CMP + BEQ 来代替。</li>
<li>STM 等多寄存器操作最大只能到 R7。</li>
</ul>
<h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>Cortex-M0 有两种工作模式：</p>
<ul>
<li>Thread mode - Normal code</li>
<li>Handler mode - Interrupt </li>
</ul>
<p>两种模式的唯一区别是 thread mode 可以额外选择使用 PSP 作为栈指针寄存器。</p>
<p><em>Reference &lt;The Definitive Guide to ARM Cortex-M0 and Cortex-M0+ Processors 2nd Edition&gt; Chapter 3 - Programmer’s Modle - Operation Modes and States - page 26</em></p>
<h2 id="用户等级"><a href="#用户等级" class="headerlink" title="用户等级"></a>用户等级</h2><p>Cortex-M0+ 有两种用户等级：</p>
<ul>
<li>Privileged</li>
<li>Nonprivileged</li>
</ul>
<p>Privileged 等级可以访问所有的内存，相对的，Nonprivileged 等级不能访问部分系统控制寄存器。</p>
<p>但 Cortex-M0 没有用户等级的区别，换句话说，Cortex-M0 始终工作在 Privileged  等级。</p>
<p>Reference &lt;Joseph Yiu - The Definitive Guide to ARM Cortex-M0 and Cortex-M0+ Processors 2nd Edition&gt; Chapter 7.8 - Memory Attributes and Memory Access Permission - page 179</p>
<h2 id="中断进-出操作和序列"><a href="#中断进-出操作和序列" class="headerlink" title="中断进/出操作和序列"></a>中断进/出操作和序列</h2><p>中断进入：</p>
<ul>
<li>把 R0 to R3, R12, LR, PC 和 xPSR 压入中断前使用的栈</li>
<li>取向量</li>
<li>更新 LR, IPSR 和 NVIC</li>
</ul>
<p>中断退出：</p>
<ul>
<li>把 R0 to R3, R12, LR, PC 和 xPSR 推出栈（根据 LR 的 EXC_RETURN bit 决定 MSP 还是 PSP）</li>
<li>返回断点处执行</li>
</ul>
<p><em>Reference &lt; Joseph Yiu - The Definitive Guide to ARM Cortex-M0 and Cortex-M0+ Processors 2nd Edition &gt; page 150</em></p>
<h2 id="内核中断控制"><a href="#内核中断控制" class="headerlink" title="内核中断控制"></a>内核中断控制</h2><p>Cortex-M0 的内核中断是在 SCB 寄存器组内控制的。</p>
<p><img src="/2020/12/09/CPU/ARM/Cotex-M0%20and%20plus/image-20201208214549837.png" alt="image-20201208214549837"></p>
<p><em>Reference &lt;The Definitive Guide to ARM Cortex-M0 and Cortex-M0+ Processors 2nd Edition&gt; - Chapter 9.2.1</em></p>
<p>其中，SHPR2 和 SHPR3 是控制内核中断的优先级的寄存器，ICSR 是悬起/解悬中断的寄存器。</p>
<p><img src="/2020/12/09/CPU/ARM/Cotex-M0%20and%20plus/image-20201208214558944.png" alt="image-20201208214558944"></p>
<p><em>Reference &lt;[The Definitive Guide to ARM Cortex-M0 and Cortex-M0+ Processors 2nd Edition](../../resources/ARM/The Definitive Guide to ARM Cortex-M0 and Cortex-M0+ Processors 2nd Edition.pdf)&gt; - Chapter 9.2.3</em></p>
<p>内核中断中，除 NMI, hardfault 外优先级都是可编程的，除 SYSTICK 外都是无法 disable 的。</p>
<p><img src="/2020/12/09/CPU/ARM/Cotex-M0%20and%20plus/image-20201208214649538.png" alt="image-20201208214649538"></p>
<p><em>Reference &lt;The Definitive Guide to ARM Cortex-M0 and Cortex-M0+ Processors 2nd Edition&gt; - Chapter 10.3.1</em></p>
<h2 id="ARMv6-M-和-ARMv7-M-的一些具体区别"><a href="#ARMv6-M-和-ARMv7-M-的一些具体区别" class="headerlink" title="ARMv6-M 和 ARMv7-M 的一些具体区别"></a>ARMv6-M 和 ARMv7-M 的一些具体区别</h2><h3 id="LDMIA-指令"><a href="#LDMIA-指令" class="headerlink" title="LDMIA 指令"></a>LDMIA 指令</h3><p><code>LDMIA &lt;Rn&gt;!, &lt;registers&gt;</code></p>
<p>Cortex-M0 的 LDMIA 指令只能操作 R0 ~ R7，是因为其只支持 16 bit 的指令。机器码格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 15 14 13 12 | 11 | 10 9 8 | 7 6 5 4 3 2 1 0 |</span><br><span class="line">|  1  1  0  0 | 1  |   Rn   |  register_list  |</span><br></pre></td></tr></table></figure>

<p>其中<code>register_list</code>的每个 bit 分别代表 R0 ~ R7 之间的一个寄存器。所以 LDMIA 只能操作到寄存器 R7。</p>
<p><strong>如果出现<code>Error: cannot honor width suffix</code>这样的编译错误，多半是操作的寄存器超出了范围，比如 LDMIA R0!, {R4 ~ R8}。</strong></p>
<p><em>Reference &lt; ARMv6-M Architecture Reference Manual &gt; A6.7.25 LDM, LDMIA, LDMFD</em></p>
<p>Cortex-M3 的 LDMIA 指令还支持 32 bit 格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 | 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 |</span><br><span class="line">|  1  1  1  0  1| 0 0|0 1 0|W 1|  Rn    | P | M|(0)|      register_list         |</span><br></pre></td></tr></table></figure>

<p>所以 Cortex-M3 最大可以操作到寄存器 R11。</p>
<p><em>Reference &lt; ARMv7-M Architecture Reference Manual &gt; A7.7.40 LDM, LDMIA, LDMFD</em></p>
<h3 id="通用寄存器出入栈的汇编代码"><a href="#通用寄存器出入栈的汇编代码" class="headerlink" title="通用寄存器出入栈的汇编代码"></a>通用寄存器出入栈的汇编代码</h3><p>由于 Cortex-M0 的 LDMIA 指令最大只能操作到 R7，所以只对于 R8 ~ R11 的入栈，要通过先拷贝 R8 ~ R11 到 R4 ~ R7 后再入栈 R4 - R7 的方法来实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void xPortPendSVHandler( void )</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;* This is a naked function. *&#x2F;</span><br><span class="line"></span><br><span class="line">	__asm volatile</span><br><span class="line">	(</span><br><span class="line">	&quot;	mrs r0, psp							\n&quot;</span><br><span class="line">	&quot;										\n&quot;</span><br><span class="line">	&quot;	ldr	r3, pxCurrentTCBConst			\n&quot; &#x2F;* Get the location of the current TCB. *&#x2F;</span><br><span class="line">	&quot;	ldr	r2, [r3]						\n&quot;</span><br><span class="line">	&quot;										\n&quot;</span><br><span class="line">	&quot;	sub r0, r0, #32						\n&quot; &#x2F;* Make space for the remaining low registers. *&#x2F;</span><br><span class="line">	&quot;	str r0, [r2]						\n&quot; &#x2F;* Save the new top of stack. *&#x2F;</span><br><span class="line">	&quot;	stmia r0!, &#123;r4-r7&#125;					\n&quot; &#x2F;* Store the low registers that are not saved automatically. *&#x2F;</span><br><span class="line">	&quot; 	mov r4, r8							\n&quot; &#x2F;* Store the high registers. *&#x2F;</span><br><span class="line">	&quot; 	mov r5, r9							\n&quot;</span><br><span class="line">	&quot; 	mov r6, r10							\n&quot;</span><br><span class="line">	&quot; 	mov r7, r11							\n&quot;</span><br><span class="line">	&quot; 	stmia r0!, &#123;r4-r7&#125;              	\n&quot;</span><br><span class="line">	&quot;										\n&quot;</span><br><span class="line">	&quot;	push &#123;r3, r14&#125;						\n&quot;</span><br><span class="line">	&quot;	cpsid i								\n&quot;</span><br><span class="line">	&quot;	bl vTaskSwitchContext				\n&quot;</span><br><span class="line">	&quot;	cpsie i								\n&quot;</span><br><span class="line">	&quot;	pop &#123;r2, r3&#125;						\n&quot; &#x2F;* lr goes in r3. r2 now holds tcb pointer. *&#x2F;</span><br><span class="line">	&quot;										\n&quot;</span><br><span class="line">	&quot;	ldr r1, [r2]						\n&quot;</span><br><span class="line">	&quot;	ldr r0, [r1]						\n&quot; &#x2F;* The first item in pxCurrentTCB is the task top of stack. *&#x2F;</span><br><span class="line">	&quot;	add r0, r0, #16						\n&quot; &#x2F;* Move to the high registers. *&#x2F;</span><br><span class="line">	&quot;	ldmia r0!, &#123;r4-r7&#125;					\n&quot; &#x2F;* Pop the high registers. *&#x2F;</span><br><span class="line">	&quot; 	mov r8, r4							\n&quot;</span><br><span class="line">	&quot; 	mov r9, r5							\n&quot;</span><br><span class="line">	&quot; 	mov r10, r6							\n&quot;</span><br><span class="line">	&quot; 	mov r11, r7							\n&quot;</span><br><span class="line">	&quot;										\n&quot;</span><br><span class="line">	&quot;	msr psp, r0							\n&quot; &#x2F;* Remember the new top of stack for the task. *&#x2F;</span><br><span class="line">	&quot;										\n&quot;</span><br><span class="line">	&quot;	sub r0, r0, #32						\n&quot; &#x2F;* Go back for the low registers that are not automatically restored. *&#x2F;</span><br><span class="line">	&quot; 	ldmia r0!, &#123;r4-r7&#125;              	\n&quot; &#x2F;* Pop low registers.  *&#x2F;</span><br><span class="line">	&quot;										\n&quot;</span><br><span class="line">	&quot;	bx r3								\n&quot;</span><br><span class="line">	&quot;										\n&quot;</span><br><span class="line">	&quot;	.align 4							\n&quot;</span><br><span class="line">	&quot;pxCurrentTCBConst: .word pxCurrentTCB	  &quot;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 Cortex-M3 则可以直接入栈 R4 ~ R11：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void xPortPendSVHandler( void )</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;* This is a naked function. *&#x2F;</span><br><span class="line"></span><br><span class="line">	__asm volatile</span><br><span class="line">	(</span><br><span class="line">	&quot;	mrs r0, psp							\n&quot;</span><br><span class="line">	&quot;	isb									\n&quot;</span><br><span class="line">	&quot;										\n&quot;</span><br><span class="line">	&quot;	ldr	r3, pxCurrentTCBConst			\n&quot; &#x2F;* Get the location of the current TCB. *&#x2F;</span><br><span class="line">	&quot;	ldr	r2, [r3]						\n&quot;</span><br><span class="line">	&quot;										\n&quot;</span><br><span class="line">	&quot;	stmdb r0!, &#123;r4-r11&#125;					\n&quot; &#x2F;* Save the remaining registers. *&#x2F;</span><br><span class="line">	&quot;	str r0, [r2]						\n&quot; &#x2F;* Save the new top of stack into the first member of the TCB. *&#x2F;</span><br><span class="line">	&quot;										\n&quot;</span><br><span class="line">	&quot;	stmdb sp!, &#123;r3, r14&#125;				\n&quot;</span><br><span class="line">	&quot;	mov r0, %0							\n&quot;</span><br><span class="line">	&quot;	msr basepri, r0						\n&quot;</span><br><span class="line">	&quot;	bl vTaskSwitchContext				\n&quot;</span><br><span class="line">	&quot;	mov r0, #0							\n&quot;</span><br><span class="line">	&quot;	msr basepri, r0						\n&quot;</span><br><span class="line">	&quot;	ldmia sp!, &#123;r3, r14&#125;				\n&quot;</span><br><span class="line">	&quot;										\n&quot;	&#x2F;* Restore the context, including the critical nesting count. *&#x2F;</span><br><span class="line">	&quot;	ldr r1, [r3]						\n&quot;</span><br><span class="line">	&quot;	ldr r0, [r1]						\n&quot; &#x2F;* The first item in pxCurrentTCB is the task top of stack. *&#x2F;</span><br><span class="line">	&quot;	ldmia r0!, &#123;r4-r11&#125;					\n&quot; &#x2F;* Pop the registers. *&#x2F;</span><br><span class="line">	&quot;	msr psp, r0							\n&quot;</span><br><span class="line">	&quot;	isb									\n&quot;</span><br><span class="line">	&quot;	bx r14								\n&quot;</span><br><span class="line">	&quot;										\n&quot;</span><br><span class="line">	&quot;	.align 4							\n&quot;</span><br><span class="line">	&quot;pxCurrentTCBConst: .word pxCurrentTCB	\n&quot;</span><br><span class="line">	::&quot;i&quot;(configMAX_SYSCALL_INTERRUPT_PRIORITY)</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ARM</category>
      </categories>
  </entry>
  <entry>
    <title>配置树莓派成为一个 JTAG adapter</title>
    <url>/2020/12/09/Boards/Raspberry%20Pi/%E9%85%8D%E7%BD%AE%E6%A0%91%E8%8E%93%E6%B4%BE%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%20JTAG%20adapter/</url>
    <content><![CDATA[<h2 id="配置树莓派成为一个-JTAG-adapter"><a href="#配置树莓派成为一个-JTAG-adapter" class="headerlink" title="配置树莓派成为一个 JTAG adapter"></a>配置树莓派成为一个 JTAG adapter</h2><p><a href="http://blog.sina.com.cn/s/blog_7cedb56d0102v141.html">http://blog.sina.com.cn/s/blog_7cedb56d0102v141.html</a></p>
<p>OpenOCD 支持通过树莓派的 GPIO 作为一个 JTAG 调试器。</p>
<p>在树莓派上编译 openocd：</p>
<ol>
<li><p>下载 openocd 源码</p>
<p>基于提交： 1756f393e45c2a23dd29ff8bc85d188b547624f9</p>
</li>
</ol>
<a id="more"></a>

   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone git:&#x2F;&#x2F;repo.or.cz&#x2F;openocd.git</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>按照 README 安装依赖库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install libtool pkg-config autoconf automake texinfo</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd openocd</span><br><span class="line">$ git checkout 1756f393e45c2a23dd29ff8bc85d188b547624f9</span><br><span class="line">$ .&#x2F;bootstrap</span><br><span class="line">$ .&#x2F;configure --enable-bcm2835gpio</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<p>按 BCM 编码，SWCLK 是 11 脚（排针23），SWDIO 是 25 脚（排针22），连接到 STM32F410 的 SWD 脚上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd tcl</span><br><span class="line">$ sudo openocd -f interface&#x2F;raspberrypi2-native.cfg -c &quot;transport select swd&quot; -f target&#x2F;stm32f4x.cfg -c init -c &quot;dump_image ram.bin 0x8000000 0x10000&quot;</span><br><span class="line">Open On-Chip Debugger 0.10.0+dev-00364-g1756f393 (2018-03-28-14:26)</span><br><span class="line">Licensed under GNU GPL v2</span><br><span class="line">For bug reports, read</span><br><span class="line">	http:&#x2F;&#x2F;openocd.org&#x2F;doc&#x2F;doxygen&#x2F;bugs.html</span><br><span class="line">BCM2835 GPIO config: tck &#x3D; 11, tms &#x3D; 25, tdi &#x3D; 10, tdo &#x3D; 9</span><br><span class="line">BCM2835 GPIO nums: swclk &#x3D; 11, swdio &#x3D; 25</span><br><span class="line">swd</span><br><span class="line">adapter speed: 20000 kHz</span><br><span class="line">adapter_nsrst_delay: 100</span><br><span class="line">none separate</span><br><span class="line">cortex_m reset_config sysresetreq</span><br><span class="line">Info : BCM2835 GPIO JTAG&#x2F;SWD bitbang driver</span><br><span class="line">Info : JTAG and SWD modes enabled</span><br><span class="line">Info : clock speed 4061 kHz</span><br><span class="line">Info : SWD DPIDR 0x2ba01477</span><br><span class="line">Info : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints</span><br><span class="line">Info : Listening on port 3333 for gdb connections</span><br><span class="line">dumped 65536 bytes in 0.123247s (519.282 KiB&#x2F;s)</span><br><span class="line">Info : Listening on port 6666 for tcl connections</span><br><span class="line">Info : Listening on port 4444 for telnet connections</span><br></pre></td></tr></table></figure>

<p>速度达到可怕的 519 KiB/s，J-Link 是 103KiB/s，是 J-Link 的 5 倍多！！！</p>
<p><img src="/2020/12/09/Boards/Raspberry%20Pi/%E9%85%8D%E7%BD%AE%E6%A0%91%E8%8E%93%E6%B4%BE%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%20JTAG%20adapter/image-20201208213734757.png" alt="image-20201208213734757"></p>
<p><strong>为什么会比 J-Link 要快？</strong></p>
<p>JTAG 通信速度由 GPIO 和 CPU 速度共同决定，J-Link v9 使用的是 STM32F205，GPIO 速度 60MHz，树莓派3B 的 BCM2837 的 GPIO 速度应该也是这个量级，并且从 log 可以看出，事实上树莓派的 JTAG clock speed 最大是 4MHz，而 J-Link 是 10MHz，这说明了影响 JTAG 速度的主要是 CPU 速度。STM32F205 最大 150 DMIPS，而树莓派是 11040 DMIPS，完全不是一个量级的，这就导致了树莓派虽然 JTAG 频率低，但是超快的协议处理速度还是让其通信速度碾压了 J-Link</p>
<p><strong>修改 JTAG 引脚</strong></p>
<p>在 raspberrypi2-native.cfg 内用 bcm2835gpio_swd_nums 来设置 SWD 使用的 GPIO，注意是 BCM 编码</p>
<p><strong>bit-bang</strong></p>
<blockquote>
<p>什么是SPI的bitbang / bit bang / bit-bang / bitbanging</p>
<p>在了解了基本的SPI之后，在Linux内核源码里面，发现关于SPI来说，有个叫做bitbang的东西，所以有点迷惑，想搞清楚bitbang是啥意思。</p>
<p>找了点资料，大概看明白了：</p>
<p>首先，对于多数情况来说，我们所用的SPI，都是有对应的SPI的控制器的，其负责和外部SPI设备进行通信，负责两者通信时候的信号之间的同步，保证信号的timing都符合SPI协议，保证可以正常进行SPI通信。</p>
<p>但是有些时候，没有此对应的硬件上的SPI控制器，而还想要和SPI设备通信，那么就只能用GPIO端口去模拟对应的SPI接口的对应的pin：片选CS，数据输入Data In，数据输出Data Out，始终Clock，去模拟SPI协议，和对应spi设备进行通信。所以，此时你对每个端口的操作，作为编程者，你自己要去负责信号的同步，保证timing符合协议规定，才能正常进行SPI通信。</p>
<p>这样的SPI的bit-bang，优点是不需要SPI的控制器了，但是缺点很明显，除了要用户自己负责同步，timing等事情之外，相对来说，即使本身SPI设备支持以很高的频率运行，可以实现很好的性能，但是以bit-bang的方式去使用的话，实际性能往往很差。</p>
<p>最后，可以用一句话来解释，什么是SPI的bitbang/bit-bang：</p>
<p>Use software to control serial communication at general-purpose I/O pins</p>
<p>通过GPIO引脚，用软件来模拟串行通信（SPI/I2C 。。。）。</p>
</blockquote>
</li>
</ol>
<h2 id="树莓派作-JTAG-的-OpenOCD-权限问题"><a href="#树莓派作-JTAG-的-OpenOCD-权限问题" class="headerlink" title="树莓派作 JTAG 的 OpenOCD 权限问题"></a>树莓派作 JTAG 的 OpenOCD 权限问题</h2><p>pi 用户提示<code>open: Permission denied</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ openocd -s rtl8710_openocd&#x2F; -f rtl8710_openocd&#x2F;interface&#x2F;raspberrypi2-native.cfg -f rtl8710_openocd&#x2F;rtl8710&#x2F;rtl8710.cfg</span><br><span class="line">Open On-Chip Debugger 0.10.0+dev-00364-g1756f393 (2018-03-30-05:45)</span><br><span class="line">Licensed under GNU GPL v2</span><br><span class="line">For bug reports, read</span><br><span class="line">	http:&#x2F;&#x2F;openocd.org&#x2F;doc&#x2F;doxygen&#x2F;bugs.html</span><br><span class="line">BCM2835 GPIO config: tck &#x3D; 11, tms &#x3D; 25, tdi &#x3D; 10, tdo &#x3D; 9</span><br><span class="line">BCM2835 GPIO nums: swclk &#x3D; 11, swdio &#x3D; 25</span><br><span class="line">swd</span><br><span class="line">Warn : Transport &quot;swd&quot; was already selected</span><br><span class="line">adapter speed: 10000 kHz</span><br><span class="line">adapter_nsrst_delay: 100</span><br><span class="line">none separate</span><br><span class="line">cortex_m reset_config vectreset</span><br><span class="line">Info : Listening on port 6666 for tcl connections</span><br><span class="line">Info : Listening on port 4444 for telnet connections</span><br><span class="line">Info : BCM2835 GPIO JTAG&#x2F;SWD bitbang driver</span><br><span class="line">Info : JTAG and SWD modes enabled</span><br><span class="line">open: Permission denied</span><br></pre></td></tr></table></figure>

<p>打开 -d 查看 debug log：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Info : 261 78 bcm2835gpio.c:438 bcm2835gpio_init(): JTAG and SWD modes enabled</span><br><span class="line">open: Permission denied</span><br><span class="line">Debug: 262 79 command.c:642 run_command(): Command failed with error code -100</span><br></pre></td></tr></table></figure>

<p>到源代码内查看，原来是写 /dev/mem 的权限问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (bcm2835gpio_jtag_mode_possible()) &#123;</span><br><span class="line">	if (bcm2835gpio_swd_mode_possible())</span><br><span class="line">		LOG_INFO(&quot;JTAG and SWD modes enabled&quot;);</span><br><span class="line">	else</span><br><span class="line">		LOG_INFO(&quot;JTAG only mode enabled (specify swclk and swdio gpio to add SWD mode)&quot;);</span><br><span class="line">&#125; else if (bcm2835gpio_swd_mode_possible()) &#123;</span><br><span class="line">	LOG_INFO(&quot;SWD only mode enabled (specify tck, tms, tdi and tdo gpios to add JTAG mode)&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	LOG_ERROR(&quot;Require tck, tms, tdi and tdo gpios for JTAG mode and&#x2F;or swclk and swdio gpio for SWD mode&quot;);</span><br><span class="line">	return ERROR_JTAG_INIT_FAILED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dev_mem_fd &#x3D; open(&quot;&#x2F;dev&#x2F;mem&quot;, O_RDWR | O_SYNC);</span><br><span class="line">if (dev_mem_fd &lt; 0) &#123;</span><br><span class="line">	perror(&quot;open&quot;);</span><br><span class="line">	return ERROR_JTAG_INIT_FAILED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>/dev/mem 是 CPU 的内存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -l &#x2F;dev&#x2F;mem</span><br><span class="line">crw-r----- 1 root kmem 1, 1 Apr  3 03:39 &#x2F;dev&#x2F;mem</span><br></pre></td></tr></table></figure>

<p>把 /dev/mem 换成 /dev/gpiomem，更安全，并且不需要 root 权限</p>
<h2 id="树莓派上多个-openocd（不同-io）并行运行时的问题"><a href="#树莓派上多个-openocd（不同-io）并行运行时的问题" class="headerlink" title="树莓派上多个 openocd（不同 io）并行运行时的问题"></a>树莓派上多个 openocd（不同 io）并行运行时的问题</h2><p>比如，使用 2,3 脚作为一组 SWD，使用 4,5 脚作为另一组 SWD，那么两组 SWD 同时跑起来时就会互相影响，导致同时只有一组能用，但是，2,3 脚的 SWD 和 10,11 脚的 SWD 就不会冲突。</p>
<p>原因是：SWDIO 是双向通信口，所以 openocd 要在通信时频繁地切换其方向（输入/输出），配置方向的寄存器是 10 个 io 共用一个寄存器（参考 BCM2835-ARM-Peripherals.pdf），总共有 0 -9 或者 10- 19 或者 20-27 三个寄存器。openocd 内配置某个 io 方向是对寄存器内位或/与来实现的，也就是（读出 - 与/或 - 写回），所以在不同进程内会有临界区风险发生。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define INP_GPIO(g) do &#123; *(pio_base+((g)&#x2F;10)) &amp;&#x3D; ~(7&lt;&lt;(((g)%10)*3)); &#125; while (0)</span><br></pre></td></tr></table></figure>

<p>即使是不属于同一个 io 方向配置寄存器，如 2,3 和 11,12，在频繁的启动 - 退出 openocd 时也会互相影响，原因是 bcm2835gpio.c 内有个 bug：bcm2835gpio.c 内使用 -1 来表示无效/不用的 io，但是它只对 trst 和 srst 作有效性判断，若使用 SWD 模式，那么 tdo, tdi 和 tck 也是不用的，此时代码内仍会去操作这些 io，就可能会写到其他 io，因为 -1%10 是 -1, -1 &lt;&lt; m 是不确定的。</p>
<h2 id="ondemand-模式下-CPU-频率变化导致的-SWCLK-变化问题"><a href="#ondemand-模式下-CPU-频率变化导致的-SWCLK-变化问题" class="headerlink" title="ondemand 模式下 CPU 频率变化导致的 SWCLK 变化问题"></a>ondemand 模式下 CPU 频率变化导致的 SWCLK 变化问题</h2><p>树莓派默认是 ondemand 模式，此模式下 CPU 会动态调整频率。由于 openocd 内是 bitbang 模拟协议，靠 while 循环来延时，所以 SWCLK 频率随之变化，导致了 SWD 连接不稳定。</p>
<p>修改为 powersave 模式，锁定 CPU 使用最低的 600MHz 频率就好了。</p>
]]></content>
      <categories>
        <category>Raspberry Pi</category>
      </categories>
  </entry>
  <entry>
    <title>Hardfault 调试实例</title>
    <url>/2020/12/09/CPU/ARM/Hardfault%20%E8%B0%83%E8%AF%95%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="非对齐的访问"><a href="#非对齐的访问" class="headerlink" title="非对齐的访问"></a>非对齐的访问</h2><p>rf_pin_sleep 函数，在按键长按回调中调用没有异常，但是在 TIM_SLP 定时器回调中就会挂掉，调试发现是触发了 Hardfault。</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rf_pin_sleep</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">  EXTI_InitStructure.EXTI_Line = EXTI_Line5;</span><br><span class="line">  EXTI_InitStructure.EXTI_LineCmd = DISABLE;</span><br><span class="line">  EXTI_Init(&amp;EXTI_InitStructure);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实按键长按回调也是定时器的回调，有什么区别呢。</p>
<p>用 Ozone 跟进看可能的异常是 UNALIGN_TRA，也就是非对齐的访问。</p>
<p><img src="/2020/12/09/CPU/ARM/Hardfault%20%E8%B0%83%E8%AF%95%E5%AE%9E%E4%BE%8B/image-20201122230410929.png" alt="image-20201122230410929"></p>
<p>EXTI_Init 对于 DISABLE 的处理如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_Init</span><span class="params">(EXTI_InitTypeDef *EXTI_InitStruct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> tmp = (<span class="keyword">uint32_t</span>)EXTI_BASE;</span><br><span class="line">    ...</span><br><span class="line">    tmp = (<span class="keyword">uint32_t</span>)EXTI_BASE;</span><br><span class="line">    tmp += EXTI_InitStruct-&gt;EXTI_Mode;</span><br><span class="line">    <span class="comment">/* Disable the selected external lines */</span></span><br><span class="line">    *(__IO <span class="keyword">uint32_t</span> *)tmp &amp;= ~EXTI_InitStruct-&gt;EXTI_Line;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里有个 EXTI_Mode 并没有在 EXTI_InitStructure 变量中赋值，EXTI_InitStructure 是个局部变量，位于栈上，那么 EXTI_Mode 也就是个不确定的值。</p>
<p>故而在不同的函数中调用此函数表现不一，若 EXTI_Mode 的值刚好不对齐 word，那么就会导致 Hardfault。</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
  </entry>
  <entry>
    <title>GCC 实用技巧</title>
    <url>/2020/12/09/Complie%20&amp;%20Debug/GCC/GCC%20%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="到底使用了哪个头文件？"><a href="#到底使用了哪个头文件？" class="headerlink" title="到底使用了哪个头文件？"></a>到底使用了哪个头文件？</h2><p>一个 SDK 中可能存在多个同名的 .h 文件，如何确定 .c 中到底使用的是哪个 .h 呢？</p>
<p>GCC 有一个选项 -M 可以输出 .c 所包含的所有 .h，使用此方法能确定 .c 使用的 .h 文件。</p>
<p>开发 5062 时遇到了编译错误：<code>error: &#39;errno&#39; undeclared</code>，可能是 .c 使用了一个错误的非系统的 errno.h，于是到 build 目录下去查找对应的 .d 文件，发现果然用的是一个原厂自己写的 errno.h，其中没有声明 errno。</p>
<h2 id="屏蔽编译-warning-输出"><a href="#屏蔽编译-warning-输出" class="headerlink" title="屏蔽编译 warning 输出"></a>屏蔽编译 warning 输出</h2><p>有时候 warning 太多，淹没了 error，可以用 -w 选项屏蔽 warning 输出。</p>
<h2 id="使用-strip-精简静态库的大小"><a href="#使用-strip-精简静态库的大小" class="headerlink" title="使用 strip 精简静态库的大小"></a>使用 strip 精简静态库的大小</h2><p><code>arm-none-eabi-strip -o lib.strip.a lib.a --strip-debug</code></p>
<a id="more"></a>

<p>静态库只能使用<code>--strip-debug</code>选项，去除库中的 debug 信息，可以把一个 16M 的静态库精简到 280K。</p>
<p>注意：使用<code>ar -M &lt; script</code>方式将多个 .a 打包成的静态库不能使用 strip 命令。</p>
<h2 id="在-map-表内查找静态变量和函数地址"><a href="#在-map-表内查找静态变量和函数地址" class="headerlink" title="在 map 表内查找静态变量和函数地址"></a>在 map 表内查找静态变量和函数地址</h2><p>静态变量和函数其实在 map 表内也能查到的，首先要使能 GCC 的编译选项<code>-fdata-sections -ffunction-sections</code>，为变量和函数生成一个专有的段名称。</p>
<p>以静态变量来举例说明：</p>
<p>ota.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static uint8_t flash_data_buf;</span><br><span class="line"></span><br><span class="line">void ota(void)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>main.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void hal_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	static uint8_t flash_data_buf;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">	static uint8_t flash_data_buf;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于在函数外的静态变量，在 map 表中形式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.bss.flash_data_buf</span><br><span class="line">                0x0000000000400234     0x1000 build&#x2F;src&#x2F;system&#x2F;ota.o</span><br></pre></td></tr></table></figure>

<p>对于函数内的静态变量，在 map 表中形式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.bss.flash_data_buf.5993</span><br><span class="line">               0x00000000004001fd        0x1 build&#x2F;src&#x2F;system&#x2F;main.o</span><br><span class="line">.bss.flash_data_buf.5989</span><br><span class="line">               0x00000000004001fe        0x1 build&#x2F;src&#x2F;system&#x2F;main.o</span><br></pre></td></tr></table></figure>
<p>这种情况就要结合反汇编来确定了。</p>
<h2 id="builtin-return-address-获取调用者的地址"><a href="#builtin-return-address-获取调用者的地址" class="headerlink" title="__builtin_return_address() 获取调用者的地址"></a>__builtin_return_address() 获取调用者的地址</h2><p><code>void * __builtin_return_address (unsigned int level)</code>是 GCC 的一个内建函数，<code>__builtin_return_address(0)</code>的含义是，得到当前函数返回地址，即此函数被别的函数调用，然后此函数执行完毕返回后的下一条地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printf(&quot;%s(0) &#x3D; %p\r\n&quot;, __FUNCTION__, __builtin_return_address(0));</span><br></pre></td></tr></table></figure>

<p>反汇编如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">8088088:	4674      	mov	r4, lr</span><br><span class="line">...</span><br><span class="line">80880b8:	4622      	mov	r2, r4</span><br><span class="line">80880ba:	490f      	ldr	r1, [pc, #60]	; (80880f8 &lt;application_start+0x78&gt;)</span><br><span class="line">80880bc:	480f      	ldr	r0, [pc, #60]	; (80880fc &lt;application_start+0x7c&gt;)</span><br><span class="line">80880be:	f00b fd67 	bl	8093b90 &lt;iprintf&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>所以这个函数其实就是返回 LR 的值。</p>
<h2 id="AR"><a href="#AR" class="headerlink" title="AR"></a>AR</h2><p><a href="http://sourceware.org/binutils/docs-2.31/binutils/ar-cmdline.html#ar-cmdline">http://sourceware.org/binutils/docs-2.31/binutils/ar-cmdline.html#ar-cmdline</a></p>
<p><code>ar -rcs archive objects</code>将 objects 文件打包成库</p>
<p><code>c</code> - create，创建新库</p>
<p><code>r</code> - replace，替换已有库中的目标文件</p>
<p><code>s</code> - 更新库中的索引</p>
<p><code>d</code> - delete，删除库中的目标文件</p>
<p><code>x</code> - extract，解压出库中的目标文件</p>
<p><code>t</code> - 列出库中所有的目标文件</p>
]]></content>
      <categories>
        <category>GCC</category>
      </categories>
  </entry>
  <entry>
    <title>GCC 常见错误</title>
    <url>/2020/12/09/Complie%20&amp;%20Debug/GCC/GCC%20%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h2 id="undefined-reference-to-fini"><a href="#undefined-reference-to-fini" class="headerlink" title="undefined reference to _fini"></a>undefined reference to <code>_fini</code></h2><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lib_a-fini.o): In function &#96;__libc_fini_array&#39;:</span><br><span class="line">fini.c:(.text.__libc_fini_array+0x1c): undefined reference to &#96;_fini&#39;</span><br></pre></td></tr></table></figure>
<p>__libc_fini_array 和 _fini 是负责 C++ 的析构，如果没有用到 C++ 而又出现上述错误，一般是因为 .ld 中把相关的段 KEEP 了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KEEP ((.init_array))</span><br></pre></td></tr></table></figure>
<h2 id="undefined-reference-to-locale-ctype-ptr-or-ctype-ptr"><a href="#undefined-reference-to-locale-ctype-ptr-or-ctype-ptr" class="headerlink" title="undefined reference to __locale_ctype_ptr or __ctype_ptr__"></a>undefined reference to <code>__locale_ctype_ptr</code> or <code>__ctype_ptr__</code></h2><p>在 OSX 上编译的库，在 windows 上链接时报错：undefined reference to <code>__locale_ctype_ptr</code>。</p>
<p>在 windows 上编译的苦，在 OSX 上链接时报错：undefined reference to <code>__ctype_ptr__</code>。</p>
<p>原因是代码中有用到<code>islower</code>,<code>isxdigit</code>等函数，这些函数在 GCC 的 windows 和 unix-like 上的实现有差异的，它们其实都是宏定义，但在 windows 上，是一个数组指针<code>__ctype_ptr__</code>的索引来实现，而在 OSX 上，是一个函数<code>__locale_ctype_ptr</code>的返回值的索引来实现。</p>
<p>LwIP 开发者可能也遇到了这个问题，于是他们的做法是自己重新定义了这些函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define in_range(c, lo, up)  ((u8_t)c &gt;&#x3D; lo &amp;&amp; (u8_t)c &lt;&#x3D; up)</span><br><span class="line">#define isprint(c)           in_range(c, 0x20, 0x7f)</span><br><span class="line">#define isdigit(c)           in_range(c, &#39;0&#39;, &#39;9&#39;)</span><br><span class="line">#define isxdigit(c)          (isdigit(c) || in_range(c, &#39;a&#39;, &#39;f&#39;) || in_range(c, &#39;A&#39;, &#39;F&#39;))</span><br><span class="line">#define islower(c)           in_range(c, &#39;a&#39;, &#39;z&#39;)</span><br><span class="line">#define isspace(c)           (c &#x3D;&#x3D; &#39; &#39; || c &#x3D;&#x3D; &#39;\f&#39; || c &#x3D;&#x3D; &#39;\n&#39; || c &#x3D;&#x3D; &#39;\r&#39; || c &#x3D;&#x3D; &#39;\t&#39; || c &#x3D;&#x3D; &#39;\v&#39;)</span><br></pre></td></tr></table></figure>

<p>这样就不会遇到编译的库在另外一个操作系统上链接不过的问题了。</p>
<h2 id="Multiple-definitions-of-xxx"><a href="#Multiple-definitions-of-xxx" class="headerlink" title="Multiple definitions of xxx"></a>Multiple definitions of xxx</h2><p>一般是因为重复的函数或者变量的定义，有三种情况：</p>
<ul>
<li>源代码中有多处重复的定义。</li>
<li>源代码中有一处定义，库中也有一处重复的定义。</li>
<li>库中两个目标文件包含重复的定义，但仅在开启<code>--whole-archive</code>链接选项后才会触发此错误。</li>
</ul>
<h3 id="whole-archive的作用"><a href="#whole-archive的作用" class="headerlink" title="--whole-archive的作用"></a><code>--whole-archive</code>的作用</h3><p>在两个文件中分别定义了一个 weak 函数和一个 strong 函数，然后编译打包在一个库，链接此库后生成的可执行程序内却调用了 weak 函数，这是因为 LD 会默认使用 object 文件中找到的第一个函数的地址。若 weak 函数所在 object 文件排在 strong 函数前面，则会产生此问题。</p>
<p>解决此问题的方法是实用<code>--whole-archive</code>选项，使 LD 遍历所有的 object 文件。</p>
]]></content>
      <categories>
        <category>GCC</category>
      </categories>
  </entry>
  <entry>
    <title>GDB 实用技巧</title>
    <url>/2020/12/09/Complie%20&amp;%20Debug/GDB/GDB%20%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="线程调试"><a href="#线程调试" class="headerlink" title="线程调试"></a>线程调试</h2><p>Reference <a href="https://www.sourceware.org/gdb/onlinedocs/gdb/Threads.html#Threads">4.10 Debugging Programs with Multiple Threads</a></p>
<p>显示当前所有的线程：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">info threads</span><br></pre></td></tr></table></figure>

<p>切换到指定线程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread thread-id</span><br></pre></td></tr></table></figure>

<p>向指定线程执行指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread apply [thread-id-list] [all] args</span><br></pre></td></tr></table></figure>

<h3 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h3><p>Reference <a href="https://www.sourceware.org/gdb/onlinedocs/gdb/Backtrace.html">8.2 Backtraces</a></p>
<p>显示当前线程的 backtrace：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bt</span><br></pre></td></tr></table></figure>

<p>显示指定线程的 backtrace：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread apply thread-id backtrace</span><br></pre></td></tr></table></figure>

<p>显示所有线程的 backtrace：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread apply all backtrace</span><br></pre></td></tr></table></figure>

<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>2.1.3 What gdb Does During Startup</p>
<p>Here’s the description of what gdb does during session startup: </p>
<ol>
<li><p>Sets up the command interpreter as specified by the command line (see Section 2.1.2 [Mode Options], page 13). </p>
</li>
<li><p>Reads the system-wide init file (if ‘–with-system-gdbinit’ was used when building gdb; see Section C.6 [System-wide configuration and settings], page 612) and executes all the commands in that file. </p>
</li>
<li><p>Reads the init file (if any) in your home directory 1 and executes all the commands in that file. </p>
</li>
<li><p>Executes commands and command files specified by the ‘-iex’ and ‘-ix’ options in their specified order. Usually you should use the ‘-ex’ and ‘-x’ options instead, but this way you can apply settings before gdb init files get executed and before inferior gets loaded. </p>
</li>
<li><p>Processes command line options and operands. </p>
</li>
<li><p>Reads and executes the commands from init file (if any) in the current working directory as long as ‘set auto-load local-gdbinit’ is set to ‘on’ (see Section 22.7.1 [Init File in the Current Directory], page 314). This is only done if the current directory is different from your home directory. Thus, you can have more than one init file, one generic in your home directory, and another, specific to the program you are debugging, in the directory where you invoke gdb. </p>
</li>
<li><p>If the command line specified a program to debug, or a process to attach to, or a core file, gdb loads any auto-loaded scripts provided for the program or for its loaded shared libraries. See Section 22.7 [Auto-loading], page 312. If you wish to disable the auto-loading during startup, you must do something like the following:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb -iex &quot;set auto-load python-scripts off&quot; myprogram</span><br></pre></td></tr></table></figure>

<p>Option ‘-ex’ does not work because the auto-loading is then turned off too late. </p>
</li>
<li><p>Executes commands and command files specified by the ‘-ex’ and ‘-x’ options in their specified order. See Section 23.1.3 [Command Files], page 328, for more details about gdb command files. </p>
</li>
<li><p>Reads the command history recorded in the history file. See Section 22.3 [Command History], page 308, for more details about the command history and the files where gdb records it.</p>
</li>
</ol>
<p>gdb 启动时会默认执行 home 目录下的 .gdbinit，然后执行当前目录下的 .gdbinit</p>
<h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><h3 id="启动-gdb-时执行命令"><a href="#启动-gdb-时执行命令" class="headerlink" title="启动 gdb 时执行命令"></a>启动 gdb 时执行命令</h3><ol>
<li><p>单个命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-eval-command command </span><br><span class="line">-ex command </span><br><span class="line">Execute a single gdb command. This option may be used multiple times to call multiple commands. It may also be interleaved with ‘-command’ as required.</span><br><span class="line">gdb -ex &#39;target sim&#39; -ex &#39;load&#39; -x setbreakpoints -ex &#39;run&#39; a.out</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-command file</span><br><span class="line">-x file </span><br><span class="line">Execute commands from file file. The contents of this file is evaluated exactly as the source command would. See Section 23.1.3 [Command files], page 328.</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="启动-gdb-后执行脚本"><a href="#启动-gdb-后执行脚本" class="headerlink" title="启动 gdb 后执行脚本"></a>启动 gdb 后执行脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source [-s] [-v] filename </span><br><span class="line">Execute the command file filename.</span><br></pre></td></tr></table></figure>

<h3 id="执行-shell-命令"><a href="#执行-shell-命令" class="headerlink" title="执行 shell 命令"></a>执行 shell 命令</h3><p>上面说的方法都只能执行 gdb 内建的命令，若要执行 shell 命令，需要用 gdb shell 命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell command-string !command-string </span><br><span class="line">Invoke a standard shell to execute command-string. Note that no space is needed between ! and command-string. If it exists, the environment variable SHELL determines which shell to run. Otherwise gdb uses the default shell (‘&#x2F;bin&#x2F;sh’ on Unix systems, ‘COMMAND.COM’ on MS-DOS, etc.).</span><br></pre></td></tr></table></figure>

<p> 在 windows 上，shell 的命令要放到后台执行，则需使用<code>start /B</code></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>有时候需要在命令行启动 gdb 同时执行一些指令，这样就不用每次重复敲一遍了，特别是在脚本内很有用。</p>
<p>比如要在启动 gdb 时启动 openocd 并连接 openocd server，然后让程序在 main 函数停下来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arm-none-eabi-gdb -x .gdbinit -ex &#39;target remote localhost:3333&#39; -ex &#39;break main&#39; -ex &#39;continue&#39; test.elf --tui</span><br></pre></td></tr></table></figure>

<p>在 windows 上 .gdbinit 为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell start &#x2F;B .&#x2F;mico-os&#x2F;makefiles&#x2F;OpenOCD&#x2F;binary&#x2F;Win32&#x2F;openocd_mico </span><br><span class="line">-f .&#x2F;mico-os&#x2F;makefiles&#x2F;OpenOCD&#x2F;interface&#x2F;jlink_swd.cfg </span><br><span class="line">-f .&#x2F;mico-os&#x2F;makefiles&#x2F;OpenOCD&#x2F;MX1290&#x2F;MX1290.cfg</span><br></pre></td></tr></table></figure>

<p> 在 unix/like 上:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell .&#x2F;mico-os&#x2F;makefiles&#x2F;OpenOCD&#x2F;binary&#x2F;OSX&#x2F;openocd_mico </span><br><span class="line">-f .&#x2F;mico-os&#x2F;makefiles&#x2F;OpenOCD&#x2F;interface&#x2F;jlink_swd.cfg </span><br><span class="line">-f .&#x2F;mico-os&#x2F;makefiles&#x2F;OpenOCD&#x2F;MX1290&#x2F;MX1290.cfg &amp;</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li><p>寄存器的读取要使用小写，如 p $basepri</p>
</li>
<li><p>使用 display /x $basepri，可以在每次操作，如单步后自动显示此寄存器值。</p>
</li>
<li><p>开启 watch 断点会让速度变慢，不晓得为啥，可能是因为每步都要对比吧。</p>
</li>
<li><p>remote timeout，在调试 MX1101 时遇到了一个问题，先启动 OpenOCD server，再起 gdb 去连接，再等待了一会之后显示失败：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ignoring packet error, continuing...</span><br><span class="line">warning: unrecognized item &quot;timeout&quot; in &quot;qSupported&quot; response</span><br><span class="line">Remote replied unexpectedly to &#39;vMustReplyEmpty&#39;: PacketSize&#x3D;3fff;qXfer:memory-map:read-;qXfer:features:read+;QStartNoAckMode+</span><br></pre></td></tr></table></figure>

<p>OpenOCD 端显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Warn : negative reply, retrying</span><br><span class="line">Warn : negative reply, retrying</span><br><span class="line">Warn : negative reply, retrying</span><br><span class="line">Error: GDB missing ack(2) - assumed good</span><br><span class="line">Error: GDB missing ack(2) - assumed good</span><br><span class="line">Error: GDB missing ack(2) - assumed good</span><br></pre></td></tr></table></figure>

<p>只要在 gdb 命令里加上 set remotetimeout 20 就好了。</p>
<p>那么为什么连接时间这么久呢，原来是因为我设置的 jtag 速度太慢了 100KHz，所以连接的很慢。并且读写 RAM 的速度也很慢。</p>
</li>
<li><p>watch *address 可以监视某个地址是否被写。</p>
</li>
<li><p>bkpt</p>
</li>
</ol>
]]></content>
      <categories>
        <category>GDB</category>
      </categories>
  </entry>
  <entry>
    <title>链接器的“两步链接”</title>
    <url>/2020/12/09/Complie%20&amp;%20Debug/GCC/%E9%93%BE%E6%8E%A5%E5%99%A8%E7%9A%84%E2%80%9C%E4%B8%A4%E6%AD%A5%E9%93%BE%E6%8E%A5%E2%80%9D/</url>
    <content><![CDATA[<p>“两部链接”（Two-pass linking），是指链接的过程分为两步：<strong>地址分配 **和 **重定位</strong>。</p>
<h4 id="地址分配"><a href="#地址分配" class="headerlink" title="地址分配"></a>地址分配</h4><p>扫描输入的目标文件，分配各目标文件内各段的地址，并收集全局符号定义和引用，放入一个全局符号表。完成这一步后，所有的符号地址都被确定了。</p>
<h4 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h4><p>重定位各输入文件中引用的全局符号到其实际的地址。<br>在地址分配的过程中，链接器合并各输入的目标文件内相同的段，并为其分配空间和地址。</p>
<p> 在输入目标文件内有个<strong>重定位表</strong>来保存重定位的相关信息。它由符号信息和偏移组成。重定位时就是根据符号信息去找到其他输入目标文件内定义的符号的地址，再根据符号在本段内的偏移来替换为其实际的地址。</p>
<p> [1]：目标文件内符号的地址是相对于其所属段段相对地址，所以段的地址被分配后，符号的地址也确定了。</p>
<p>参考：<em>《程序员的自我修养》，第 4 章 1 ~ 2 节</em>。</p>
<a id="more"></a>

]]></content>
      <categories>
        <category>GCC</category>
      </categories>
  </entry>
  <entry>
    <title>Jim-Tcl</title>
    <url>/2020/12/09/Complie%20&amp;%20Debug/OpenOCD/Jim-Tcl/</url>
    <content><![CDATA[<h2 id="Jim-Tcl"><a href="#Jim-Tcl" class="headerlink" title="Jim-Tcl"></a>Jim-Tcl</h2><p>OpenOCD 内置了个超级精简版 TCL 解释器: Jim-Tcl，实现了最基本的功能，另外还扩展了一些功能。</p>
<p>OpenOCD uses a small “Tcl Interpreter” known as Jim-Tcl. This programming language provides a simple and extensible command interpreter.</p>
<p><a href="http://jim.tcl.tk/">http://jim.tcl.tk</a>.</p>
<ul>
<li><strong>Jim vs. Tcl</strong><br>Jim-Tcl is a stripped down version of the well known Tcl language, which can be found here: <a href="http://www.tcl.tk/">http://www.tcl.tk</a>. Jim-Tcl has far fewer features. Jim-Tcl is several dozens of .C files and .H files and implements the basic Tcl command set. In contrast: Tcl 8.6 is a 4.2 MB .zip file containing 1540 files.</li>
</ul>
<p>global 是个命令，可以在 command 内使用，global 的变量时所有文件都能访问的。</p>
<a id="more"></a>

]]></content>
      <categories>
        <category>OpenOCD</category>
      </categories>
  </entry>
  <entry>
    <title>OpenOCD 实用技巧</title>
    <url>/2020/12/09/Complie%20&amp;%20Debug/OpenOCD/OpenOCD%20%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="Flash-Commands"><a href="#Flash-Commands" class="headerlink" title="Flash Commands"></a>Flash Commands</h2><p><em>Referencd openocd.pdf</em></p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flash write_image [erase] [unlock] filename [offset] [type]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Write the image filename to the current target’s flash bank(s). Only loadable sections from the image are written. A relocation offset may be specified, in which case it is added to the base address for each section in the image. The file [type] can be specified explicitly as bin (binary), ihex (Intel hex), elf (ELF file), s19 (Motorola s19). mem, or builder. The relevant flash sectors will be erased prior to programming if the erase parameter is given. If unlock is provided, then the flash banks are unlocked before erase and program. The flash bank to use is inferred from the address of each image section.</p>
<p><strong>Warning:</strong> Be careful using the erase flag when the flash is holding data you want to preserve. Portions of the flash outside those described in the image’s sections might be erased with no notice.</p>
<ul>
<li>When a section of the image being written does not fill out all the sectors it uses, the unwritten parts of those sectors are necessarily also erased, because sectors can’t be partially erased.</li>
<li>Data stored in sector “holes” between image sections are also af- fected. For example, “flash write_image erase …” of an image with one byte at the beginning of a flash bank and one byte at the end erases the entire bank – not just the two sectors being written.</li>
</ul>
<p>Also, when flash protection is important, you must re-apply it after it has been removed by the unlock flag.</p>
</blockquote>
<h2 id="Image-loading-commands"><a href="#Image-loading-commands" class="headerlink" title="Image loading commands"></a>Image loading commands</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dump_image filename address size</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Dump size bytes of target memory starting at address to the binary file named filename.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load_image filename address [[bin|ihex|elf|s19] min_addr max_length]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Load image from file filename to target memory offset by address from its load address. The file format may optionally be specified (bin, ihex, elf, or s19). In addition the following arguments may be specifed: min addr - ignore data below min addr (this is w.r.t. to the target’s load address + address) max length - maximum number of bytes to load. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proc load_image_bin &#123;fname foffset address length &#125; &#123; </span><br><span class="line">  # Load data from fname filename at foffset offset to </span><br><span class="line">  # target at address. Load at most length bytes. </span><br><span class="line">  load_image $fname [expr $address - $foffset] bin $address $length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Breakpoint-and-Watchpoint-commands"><a href="#Breakpoint-and-Watchpoint-commands" class="headerlink" title="Breakpoint and Watchpoint commands"></a>Breakpoint and Watchpoint commands</h2><p>CPUs often make debug modules accessible through JTAG, with hardware support for a handful of code breakpoints and data watchpoints. In addition, CPUs almost always support software breakpoints.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bp [address len [hw]]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>With no parameters, lists all active breakpoints. Else sets a breakpoint on code execution starting at address for length bytes. This is a software breakpoint, unless hw is specified in which case it will be a hardware breakpoint. (See [arm9 vector catch], page 117, or see [xscale vector catch], page 120, for similar mechanisms that do not consume hardware breakpoints.)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rbp address</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Remove the breakpoint at address. </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rwp address </span><br></pre></td></tr></table></figure>

<blockquote>
<p>Remove data watchpoint on address</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wp [address len [(r|w|a) [value [mask]]]]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>With no parameters, lists all active watchpoints. Else sets a data watchpoint on data from address for length bytes. The watch point is an “access” watchpoint unless the r or w parameter is provided, defining it as respectively a read or write watchpoint. If a value is provided, that value is used when determining if the watchpoint should trigger. The value may be first be masked using mask to mark “don’t care” fields.</p>
</blockquote>
<h2 id="TCP-IP-Ports"><a href="#TCP-IP-Ports" class="headerlink" title="TCP/IP Ports"></a>TCP/IP Ports</h2><blockquote>
<p>The OpenOCD server accepts remote commands in several syntaxes. Each syntax uses a different TCP/IP port, which you may specify only during configuration (before those ports are opened).</p>
<p>For reasons including security, you may wish to prevent remote access using one or more of these ports. In such cases, just specify the relevant port number as “disabled”. If you disable all access through TCP/IP, you will need to use the command line -pipe option.</p>
</blockquote>
<p>OpenOCD 默认会起三个 tcp server：gdb_port，tcl_port 和 telnet_port，默认端口分别为：3333，4444，6666。若不想开启某个 tcp server，指定其端口号为 disabled 即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb_port [number]</span><br><span class="line">tcl_port [number]</span><br><span class="line">telnet_port [number]</span><br></pre></td></tr></table></figure>

<h2 id="Get-serial-number-of-J-Link"><a href="#Get-serial-number-of-J-Link" class="headerlink" title="Get serial number of J-Link"></a>Get serial number of J-Link</h2><p>对于连接了多个 J-Link 的情况，OpenOCD 提供了一个命令 jlink serial [number] 来指定其中一个。</p>
<p>但是 OpenOCD 没有提供查询 J-Link SN 的指令，这就需要我们自己来实现了。</p>
<p>参考源码中 jlink_init 函数中对 J-Link serial 查询的那部分代码，对 jlink_serial_command 函数进行改造：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMMAND_HANDLER(jlink_serial_command)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	struct jaylink_device **devs;</span><br><span class="line">	unsigned int i;</span><br><span class="line">	uint32_t tmp;</span><br><span class="line">	enum jaylink_usb_address address;</span><br><span class="line">	size_t num_devices;</span><br><span class="line">	uint32_t host_interfaces;</span><br><span class="line">    struct jaylink_context *_jayctx;</span><br><span class="line">	</span><br><span class="line">	if (CMD_ARGC &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		LOG_DEBUG(&quot;Using libjaylink %s (compiled with %s).&quot;,</span><br><span class="line">			jaylink_version_package_get_string(), JAYLINK_VERSION_PACKAGE_STRING);</span><br><span class="line"></span><br><span class="line">		if (!jaylink_library_has_cap(JAYLINK_CAP_HIF_USB) &amp;&amp; use_usb_address) &#123;</span><br><span class="line">			LOG_ERROR(&quot;J-Link driver does not support USB devices.&quot;);</span><br><span class="line">			return ERROR_JTAG_INIT_FAILED;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ret &#x3D; jaylink_init(&amp;_jayctx);</span><br><span class="line"></span><br><span class="line">		if (ret !&#x3D; JAYLINK_OK) &#123;</span><br><span class="line">			LOG_ERROR(&quot;jaylink_init() failed: %s.&quot;, jaylink_strerror(ret));</span><br><span class="line">			return ERROR_JTAG_INIT_FAILED;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		host_interfaces &#x3D; JAYLINK_HIF_USB;</span><br><span class="line"></span><br><span class="line">		if (use_serial_number)</span><br><span class="line">			host_interfaces |&#x3D; JAYLINK_HIF_TCP;</span><br><span class="line"></span><br><span class="line">		ret &#x3D; jaylink_discovery_scan(_jayctx, host_interfaces);</span><br><span class="line"></span><br><span class="line">		if (ret !&#x3D; JAYLINK_OK) &#123;</span><br><span class="line">			LOG_ERROR(&quot;jaylink_discovery_scan() failed: %s.&quot;,</span><br><span class="line">				jaylink_strerror(ret));</span><br><span class="line">			jaylink_exit(_jayctx);</span><br><span class="line">			return ERROR_JTAG_INIT_FAILED;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ret &#x3D; jaylink_get_devices(_jayctx, &amp;devs, &amp;num_devices);</span><br><span class="line"></span><br><span class="line">		if (ret !&#x3D; JAYLINK_OK) &#123;</span><br><span class="line">			LOG_ERROR(&quot;jaylink_get_devices() failed: %s.&quot;, jaylink_strerror(ret));</span><br><span class="line">			jaylink_exit(_jayctx);</span><br><span class="line">			return ERROR_JTAG_INIT_FAILED;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for (i &#x3D; 0; devs[i]; i++) &#123;</span><br><span class="line">				ret &#x3D; jaylink_device_get_serial_number(devs[i], &amp;tmp);</span><br><span class="line"></span><br><span class="line">				if (ret &#x3D;&#x3D; JAYLINK_ERR_NOT_AVAILABLE) &#123;</span><br><span class="line">					continue;</span><br><span class="line">				&#125; else if (ret !&#x3D; JAYLINK_OK) &#123;</span><br><span class="line">					LOG_WARNING(&quot;jaylink_device_get_serial_number() failed: %s.&quot;,</span><br><span class="line">						jaylink_strerror(ret));</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				ret &#x3D; jaylink_device_get_usb_address(devs[i], &amp;address);</span><br><span class="line"></span><br><span class="line">				if (ret &#x3D;&#x3D; JAYLINK_ERR_NOT_SUPPORTED) &#123;</span><br><span class="line">					continue;</span><br><span class="line">				&#125; else if (ret !&#x3D; JAYLINK_OK) &#123;</span><br><span class="line">					LOG_WARNING(&quot;jaylink_device_get_usb_address() failed: %s.&quot;,</span><br><span class="line">						jaylink_strerror(ret));</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				command_print(CMD_CTX, &quot;Found device %d, SN: %08x, USB address: %d&quot;, i, tmp, address);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		jaylink_exit(_jayctx);</span><br><span class="line"></span><br><span class="line">		return ERROR_OK;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret &#x3D; jaylink_parse_serial_number(CMD_ARGV[0], &amp;serial_number);</span><br><span class="line"></span><br><span class="line">	if (ret &#x3D;&#x3D; JAYLINK_ERR) &#123;</span><br><span class="line">		command_print(CMD_CTX, &quot;Invalid serial number: %s.&quot;, CMD_ARGV[0]);</span><br><span class="line">		return ERROR_FAIL;</span><br><span class="line">	&#125; else if (ret !&#x3D; JAYLINK_OK) &#123;</span><br><span class="line">		command_print(CMD_CTX, &quot;jaylink_parse_serial_number() failed: %s.&quot;,</span><br><span class="line">			jaylink_strerror(ret));</span><br><span class="line">		return ERROR_FAIL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	use_serial_number &#x3D; true;</span><br><span class="line">	use_usb_address &#x3D; false;</span><br><span class="line"></span><br><span class="line">	return ERROR_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Make-Raspberry-Pi-as-a-OpenOCD-debugger-🐂"><a href="#Make-Raspberry-Pi-as-a-OpenOCD-debugger-🐂" class="headerlink" title="Make Raspberry Pi as a OpenOCD debugger !!! 🐂"></a>Make Raspberry Pi as a OpenOCD debugger !!! 🐂</h2><p><a href="https://blog.csdn.net/wanshiyingg/article/details/52705913">https://blog.csdn.net/wanshiyingg/article/details/52705913</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_7cedb56d0102v141.html">http://blog.sina.com.cn/s/blog_7cedb56d0102v141.html</a></p>
<h2 id="OpenOCD-在-linux-上的权限问题"><a href="#OpenOCD-在-linux-上的权限问题" class="headerlink" title="OpenOCD 在 linux 上的权限问题"></a>OpenOCD 在 linux 上的权限问题</h2><p><a href="https://www.cnblogs.com/jxhd1/p/6528574.html">https://www.cnblogs.com/jxhd1/p/6528574.html</a></p>
<blockquote>
<h2 id="Permissions-delegation"><a href="#Permissions-delegation" class="headerlink" title="Permissions delegation"></a>Permissions delegation</h2><p>Running OpenOCD with root/administrative permissions is strongly<br>discouraged for security reasons.</p>
<p>For USB devices on GNU/Linux you should use the contrib/60-openocd.rules<br>file. It probably belongs somewhere in /etc/udev/rules.d, but<br>consult your operating system documentation to be sure. Do not forget<br>to add yourself to the “plugdev” group.</p>
<p>For parallel port adapters on GNU/Linux and FreeBSD please change your<br>“ppdev” (parport* or ppi*) device node permissions accordingly.</p>
<p>For parport adapters on Windows you need to run install_giveio.bat<br>(it’s also possible to use “ioperm” with Cygwin instead) to give<br>ordinary users permissions for accessing the “LPT” registers directly.</p>
</blockquote>
<h2 id="重定向-stdout-到-log-file"><a href="#重定向-stdout-到-log-file" class="headerlink" title="重定向 stdout 到 log file"></a>重定向 stdout 到 log file</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--log_output | -l redirect log output to file &lt;name&gt;</span><br><span class="line">log_output [filename]</span><br><span class="line">	Redirect logging to filename; the initial log output channel is stderr.</span><br></pre></td></tr></table></figure>

<p>openocd 提供 -l 来定向 log file，但是 openocd 的输出默认是 stderr，所以 stdout 是没有定向到 log file 内的。</p>
<p>所以还是用 &gt;&gt; 重定向符来把 stdout/err 都定向到 log file 内。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt; openocd.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<h2 id="hla"><a href="#hla" class="headerlink" title="hla"></a>hla</h2><p>hla 是什么？hla_swd 和 swd 有什么区别？</p>
<p>有些调试适配器（STLink, TI ICDI），不开放底层功能，只能使用高层的 API，OpenOCD 为这些适配器定义了一个专有的接口 -  High Level Adapters，缩写为 hla。OpenOCD 内这些调试器不能使用诸如 cortex_m 等底层指令。</p>
<p><a href="https://sourceforge.net/p/openocd/mailman/message/33133520/">https://sourceforge.net/p/openocd/mailman/message/33133520/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">On Fri, Nov 21, 2014 at 12:41:30PM -0800, Myles Watson wrote:</span><br><span class="line">&gt; I&#39;d like to disable the debugging mode as part of programming the chip.  In</span><br><span class="line">&gt; order to do that, the RESET register in the POWER module needs to be</span><br><span class="line">&gt; written, and then swdioclk and swdio need to be held low for a minimum of</span><br><span class="line">&gt; 100us.</span><br><span class="line">&gt; </span><br><span class="line">&gt; Since the nRF51822 has a shared swdio&#x2F;nreset line, the reset doesn&#39;t work</span><br><span class="line">&gt; if the chip is not returned to normal mode.</span><br><span class="line">&gt; </span><br><span class="line">&gt; Where should I add a &quot;hard-reset&quot; function which is specific to the</span><br><span class="line">&gt; nRF51822 and SWD?</span><br><span class="line"></span><br><span class="line">Hi Myles,</span><br><span class="line"></span><br><span class="line">Did you have any luck with this? I saw the post when you originally</span><br><span class="line">made it, but I didn&#39;t reply as I didn&#39;t really have any good ideas -</span><br><span class="line">as far as I know you can&#39;t directly control the SWDIO and SWCLK pins</span><br><span class="line">on the STLinkv2 adapter, as it&#39;s a &quot;high level adapter&quot; (hla) type and</span><br><span class="line">its protocol doesn&#39;t give you that low level of control. :(</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Angus</span><br></pre></td></tr></table></figure>

<h2 id="reset-halt"><a href="#reset-halt" class="headerlink" title="reset halt"></a>reset halt</h2><p>reset halt 的效果是是在复位并停在第一条指令，它是原理是什么呢？</p>
<p>arm core从reset state马上转为debug halt state的条件, spec中的说明是：</p>
<ol>
<li><pre><code> 寄存器DHCSR.C_DEBUGEN=1, 使能debug</code></pre>
</li>
<li><pre><code> 寄存器DEMCR.VC_CORERESET=1, 可以让触发local reset的时候停在执行第一条指令前</code></pre>
</li>
<li><pre><code> Trigger reset</code></pre>
</li>
</ol>
<p>注意，拉reset pin进行hw reset对于cm4来说是power-on reset类型, 而armv7m spec是不支持power-on reset halt debug的， power-on reset类型也会将arm debug module也reset了；</p>
<p>所以触发这种reset后， reset前下的halt request就失效了，无法在上电后要执行的第一条halt住，因此就会出现目前你们所遇到的halt timeout问题。</p>
<p>对于armv7m来说，区分两种等级的reset:power-on reset(total reset)和local reset(partial reset) （local reset还可以细分有SYSRSTREQ和VECTRESET）</p>
<p>openocd中触发hw reset也是走这个流程, 但是reset后，debug相关的寄存器(DHCSR, DEMCR)被复位了，</p>
<p>我在openocd中加入一些log抓取了reset前后相关寄存器的变化</p>
<p>Reset前: DHCSR.C_DEBUGEN=1,系统有使能debug；DEMCR.VC_CORERESET=1允许reset后马上进入halt debug状态(这两个值在local reset均不会变化，power-on reset会复位)</p>
<p>Reset后: DHCSR.C_RESET_ST=1，表明系统刚刚有触发了reest，DHCSR.C_DEBUGEN=0,系统没有使能debug；DEMCR.VC_CORERESET=0，这样离开系统后系统无法立即halt住，DHCSR.S_HALT=0，表示系统是处于running状态而不是halt状态。</p>
<p>debug相关寄存器发生了复位，所以是发生了power-on reset，这样我们就没有办法在拉reset pin后马上halt住。</p>
<h2 id="RAM-Code"><a href="#RAM-Code" class="headerlink" title="RAM Code"></a>RAM Code</h2><ol>
<li><p>RAM code 不需要加载 .text 和 .data 段，但是必须清零 .bss 段即可。</p>
</li>
<li><p>使用 load app.elf 命令把 .text 和 .data 段 load 进 RAM 内，并自动设置 PC 的值为 .ld 的 ENTRY 值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arm-none-eabi-gdb build&#x2F;mx1101.elf -ex &quot;target remote localhost:3333&quot; -ex &quot;monitor reset halt&quot; -ex &quot;load build&#x2F;mx1101.elf&quot; -ex &quot;b main&quot; -ex &quot;layout split&quot; -ex &quot;focus cmd&quot; --tui</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>OpenOCD</category>
      </categories>
  </entry>
  <entry>
    <title>OpenOCD 探测目标所运行 OS 的原理</title>
    <url>/2020/12/09/Complie%20&amp;%20Debug/OpenOCD/OpenOCD%20%E6%8E%A2%E6%B5%8B%E7%9B%AE%E6%A0%87%E6%89%80%E8%BF%90%E8%A1%8C%20OS%20%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>OpenOCD 支持 OS 调试，需要在目标配置中加上选项<code>-rtos auto</code>来使能此功能，OpenOCD 文档中关于 OS 调试的说明如下：</p>
<blockquote>
<p>OpenOCD includes RTOS support, this will however need enabling as it defaults to disabled. It can be enabled by passing -rtos arg to the target. See [RTOS Type], page 63.<br>See Section “Debugging Programs with Multiple Threads” in GDB manual, for details about relevant GDB commands.<br>An example setup is below:<br>$_TARGETNAME configure -rtos auto<br>This will attempt to auto detect the RTOS within your application. Currently supported rtos’s include:<br>• eCos<br>• ThreadX<br>• FreeRTOS • linux<br>• ChibiOS<br>• embKernel • mqx<br>• uCOS-III<br>Note: Before an RTOS can be detected, it must export certain symbols; other- wise, it cannot be used by OpenOCD.</p>
</blockquote>
<p>OpenOCD 探测目标所运行 OS 的原理是，它查询目标所运行的程序中有无 OS 所含有的变量符号，例如 FreeRTOS 有如下符号：</p>
<a id="more"></a>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pxCurrentTCB, pxReadyTasksLists, xDelayedTaskList1, xDelayedTaskList2, pxDelayedTaskList, pxOverowDelayedTaskList, xPendingReadyList, uxCurrentNumberOfTasks, uxTopUsedPriority.</span><br></pre></td></tr></table></figure>

<p>如果这些符号都有，那就说明目标所运行的 OS 是 FreeRTOS。</p>
<p>但是 OpenOCD 是在硬件层的调试，它只是根据 gdb 的命令来读写内存和寄存器，如何能查询目标程序内的符号的呢？</p>
<p>下面是一个 OpenOCD 的启动日志，此时 gdb 还没有 attach 上来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Open On-Chip Debugger 0.9.0 (2016-10-26-15:30)</span><br><span class="line">Licensed under GNU GPL v2</span><br><span class="line">For bug reports, read</span><br><span class="line">	http:&#x2F;&#x2F;openocd.org&#x2F;doc&#x2F;doxygen&#x2F;bugs.html</span><br><span class="line">Info : JLink SWD mode enabled</span><br><span class="line">swd</span><br><span class="line">adapter speed: 10000 kHz</span><br><span class="line">adapter_nsrst_delay: 100</span><br><span class="line">adapter_nsrst_delay: 100</span><br><span class="line">none separate</span><br><span class="line">cortex_m reset_config sysresetreq</span><br><span class="line">jtag_init</span><br><span class="line">Info : J-Link V9 compiled Sep  1 2016 18:29:50</span><br><span class="line">Info : J-Link caps 0xb9ff7bbf</span><br><span class="line">Info : J-Link hw version 94000</span><br><span class="line">Info : J-Link hw type J-Link</span><br><span class="line">Info : J-Link max mem block 69920</span><br><span class="line">Info : J-Link configuration</span><br><span class="line">Info : USB-Address: 0x0</span><br><span class="line">Info : Kickstart power on JTAG-pin 19: 0xffffffff</span><br><span class="line">Info : Vref &#x3D; 3.312 TCK &#x3D; 0 TDI &#x3D; 0 TDO &#x3D; 0 TMS &#x3D; 1 SRST &#x3D; 1 TRST &#x3D; 0</span><br><span class="line">Info : J-Link JTAG Interface ready</span><br><span class="line">Info : clock speed 10000 kHz</span><br><span class="line">Info : SWD IDCODE 0x2ba01477</span><br><span class="line">Info : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints</span><br><span class="line">Info : accepting &#39;gdb&#39; connection on tcp&#x2F;3333</span><br><span class="line">target state: halted</span><br><span class="line">target halted due to debug-request, current mode: Thread </span><br><span class="line">xPSR: 0x01000000 pc: 0x08000034 msp: 0x2000dd1c</span><br></pre></td></tr></table></figure>

<p>可以看出，此时 OpenOCD 还探测不到目标所运行的 OS。</p>
<p>在 gdb attach 上以后，OpenOCD 日志如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Info : device id &#x3D; 0x10006431</span><br><span class="line">Info : flash size &#x3D; 512kbytes</span><br><span class="line">Info : Auto-detected RTOS: FreeRTOS</span><br></pre></td></tr></table></figure>

<p>可以看出，在 gdb attach 上以后，OpenOCD 才探测出目标所使用的 OS 是 FreeRTOS。</p>
<p>不难猜测，OpenOCD 应该是查询 gdb 所加载的 ELF 文件中的符号表来探测 OS 的。</p>
<p>那么 OpenOCD 如何能查询到 ELF 文件内的符号表呢？</p>
<p>原来 OpenOCD 可以向 gdb 发送查询符号命令 - <code>qSymbol:sym_name</code>，来查询 ELF 文件内的符号地址。</p>
<p>gdb 文档中关于此部分的说明如下：</p>
<blockquote>
<p>‘qSymbol:sym_name’<br>The target requests the value of symbol sym name (hex encoded). gdb may provide the value by using the ‘qSymbol:sym_value:sym_name’ message, described below.<br>‘qSymbol:sym_value:sym_name’<br>Set the value of sym name to sym value.<br>sym name (hex encoded) is the name of a symbol whose value the target has previously requested.<br>sym value (hex) is the value for symbol sym name. If gdb cannot supply a value for sym name, then this  eld will be empty.</p>
</blockquote>
<p>用 wireshark 抓取 gdb attach 时的 gdb 和 OpenOCD 的通信包，其中有一段即是查询符号的部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$qSymbol:5f74785f7468726561645f63757272656e745f707472</span><br><span class="line">$qSymbol::5f74785f7468726561645f63757272656e745f707472</span><br><span class="line">$qSymbol:757843757272656e744e756d6265724f665461736b73</span><br><span class="line">$qSymbol:20000b6c:757843757272656e744e756d6265724f665461736b73</span><br></pre></td></tr></table></figure>

<p>OpenOCD 首先发出 <code>qSymbol</code> 命令，数据是 <code>5f74785f7468726561645f63757272656e745f707472</code>，转化成 ASCII 码是 <code>_tx_thread_current_ptr</code>，这是 ThreadX 的 symbol，因为我们的目标运行的是 FreeRTOS，所以 gdb 回复的 sym_value 是空的，代表没有这个符号。</p>
<p>然后 OpenOCD 查询 <code>uxCurrentNumberOfTasks</code>，gdb 回复中的 sym_value 的值是 20000b6c，即 <code>uxCurrentNumberOfTasks</code> 的地址。</p>
]]></content>
      <categories>
        <category>OpenOCD</category>
      </categories>
  </entry>
  <entry>
    <title>Qt 学习</title>
    <url>/2020/12/09/GUI/Qt/Qt%20%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><h3 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h3><p> <a href="http://doc.qt.io/">http://doc.qt.io</a></p>
<h3 id="PyQt"><a href="#PyQt" class="headerlink" title="PyQt"></a>PyQt</h3><p> <a href="http://pyqt.sourceforge.net/Docs/PyQt5">http://pyqt.sourceforge.net/Docs/PyQt5</a></p>
<h2 id="MainThread-QTimer-QThread-Signal-和-Slot"><a href="#MainThread-QTimer-QThread-Signal-和-Slot" class="headerlink" title="MainThread , QTimer, QThread, Signal 和 Slot"></a>MainThread , QTimer, QThread, Signal 和 Slot</h2><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtCore import Qt, QTimer, QThread, pyqtSignal</span><br><span class="line">from PyQt5.QtWidgets import QApplication, QWidget</span><br><span class="line">from PyQt5.uic import loadUi</span><br><span class="line">from threading import current_thread, get_ident</span><br><span class="line"></span><br><span class="line">class MainForm(QWidget):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(MainForm, self).__init__()</span><br><span class="line">        loadUi(&#39;form.ui&#39;, self)</span><br><span class="line">        self.pushButton.clicked.connect(self.onButtonClicked)</span><br><span class="line">        self.timer &#x3D; QTimer(self)</span><br><span class="line">        self.timer.setInterval(1000)</span><br><span class="line">        self.timer.timeout.connect(self.onTimerExpire)</span><br><span class="line">        self.timer.start()</span><br><span class="line"></span><br><span class="line">    def onButtonClicked(self):</span><br><span class="line">        print(&#39;onButtonClicked:&#39;,current_thread().getName(), get_ident())</span><br><span class="line"></span><br><span class="line">    def onTimerExpire(self):</span><br><span class="line">        self.timer.stop()</span><br><span class="line">        print(&#39;QTimer:&#39;,current_thread().getName(), get_ident())</span><br><span class="line"></span><br><span class="line">class Worker(QThread):</span><br><span class="line"></span><br><span class="line">    labelSignal &#x3D; pyqtSignal(str)</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#39;QThread:&#39;,current_thread().getName(), get_ident())</span><br><span class="line">        self.labelSignal.connect(self.onSignalEmit)</span><br><span class="line">        self.labelSignal.emit(&#39;Hello signal&#39;)</span><br><span class="line"></span><br><span class="line">    def onSignalEmit(self):</span><br><span class="line">        print(&#39;Signal:&#39;,current_thread().getName(), get_ident())</span><br><span class="line"></span><br><span class="line">app &#x3D; QApplication(sys.argv)</span><br><span class="line">mainForm &#x3D; MainForm()</span><br><span class="line">mainForm.show()</span><br><span class="line">print(&#39;Main:&#39;,current_thread().getName(), get_ident())</span><br><span class="line">worker &#x3D; Worker()</span><br><span class="line">worker.start()</span><br><span class="line">sys.exit(app.exec())</span><br></pre></td></tr></table></figure>

<p>程序运行结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python3 form.py</span><br><span class="line">Main: MainThread 140735591891840</span><br><span class="line">QThread: Dummy-1 123145307324416</span><br><span class="line">Signal: MainThread 140735591891840</span><br><span class="line">QTimer: MainThread 140735591891840</span><br><span class="line">onButtonClicked: MainThread 140735591891840</span><br></pre></td></tr></table></figure>

<h3 id="MainThread"><a href="#MainThread" class="headerlink" title="MainThread"></a>MainThread</h3><blockquote>
<p>In normal conditions, the main thread is the thread from which the Python interpreter was started.</p>
</blockquote>
<p>MainThread 就是 Python 开始解释运行的一个线程，就 Qt 而言又叫 UI 线程，负责 UI 更新和事件响应。</p>
<p>代码中的 app.exec() 本质上是个大循环，Qt 在里面更新 UI 和处理事件。</p>
<h3 id="QTimer"><a href="#QTimer" class="headerlink" title="QTimer"></a>QTimer</h3><p>QTimer 本质上是运行在 MainThread 内的软件定时器，可以直接更新 UI，不能做耗时长的操作。</p>
<h3 id="QThread"><a href="#QThread" class="headerlink" title="QThread"></a>QThread</h3><p>QThread 本质上是个 thread，但是可以定义 pyqtSignal 成员变量。</p>
<h3 id="Signal-和-Slot"><a href="#Signal-和-Slot" class="headerlink" title="Signal 和 Slot"></a>Signal 和 Slot</h3><p>Signal 是 pyqtSignal 类的实例，其 emit 方法会向 MainThread 推送一个函数来执行，这个函数就是 slot，通过 signal 的 connect 方法来绑定。</p>
<p>不准确的来讲，可以把 MainThread 看作 worker thread，signal 就是向 worker thread 内 push 函数来执行。</p>
<p>所以 slot 函数是运行在 MainThread 内的，可以直接操作 UI。</p>
<h2 id="错误以及处理"><a href="#错误以及处理" class="headerlink" title="错误以及处理"></a>错误以及处理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WARNING **: Error retrieving accessibility bus address: org.freedesktop.DBus.Error.ServiceUnknown: The name org.a11y.Bus was not provided by any .service files</span><br></pre></td></tr></table></figure>

<p><a href="https://www.raspberrypi.org/forums/viewtopic.php?t=196070">https://www.raspberrypi.org/forums/viewtopic.php?t=196070</a></p>
<p><code>sudo apt-get install at-spi2-core</code></p>
<h2 id="QSS"><a href="#QSS" class="headerlink" title="QSS"></a>QSS</h2><p>控件的 QSS 必须包含所有预期的样式，否则就会用默认的，比如想设置 QPushButton 圆角，若只在 QSS 内配置了 border-radius 是无效的，因为 border 的宽度和颜色默认都是无。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>编译 OpenOCD</title>
    <url>/2020/12/09/Complie%20&amp;%20Debug/OpenOCD/%E7%BC%96%E8%AF%91%20OpenOCD/</url>
    <content><![CDATA[<h2 id="Download-and-compile-source-code"><a href="#Download-and-compile-source-code" class="headerlink" title="Download and compile source code"></a>Download and compile source code</h2><p><strong>Download：</strong></p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git:&#x2F;&#x2F;repo.or.cz&#x2F;openocd.git</span><br></pre></td></tr></table></figure>

<p><strong>Compile：</strong></p>
<p><em>Reference README 和 README.OSX.</em></p>
<ol>
<li><p>Install Dependencies:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install libtool pkg-config autoconf automake texinfo libusb libusb-compat hidapi libftdi</span><br></pre></td></tr></table></figure>
</li>
<li><p>Compiling:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bootstrap (when building from the git repository)</span><br><span class="line">.&#x2F;configure [options]</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
</li>
<li><p>Find src/openocd</p>
</li>
</ol>
]]></content>
      <categories>
        <category>OpenOCD</category>
      </categories>
  </entry>
  <entry>
    <title>MQT 学习</title>
    <url>/2020/12/09/Network/MQTT/MQT%20%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><a href="https://zhuanlan.zhihu.com/p/20888181">MQTT入门篇</a></p>
<p><a href="https://www.jianshu.com/p/1553c1686337">MQTT example</a></p>
<p><a href="http://blog.csdn.net/github_33304260/article/details/73562071">MQTT服务器Mosquitto安装及使用</a></p>
<p><a href="https://github.com/mqtt/mqtt.github.io/wiki/libraries">libraries</a></p>
<p>[MQTT Essentials – A Lightweight IoT Protocol](../resources/MQTT Essentials – A Lightweight IoT Protocol.epub) — Good Book !!! 🐂</p>
<p>MQTT 是种基于<code>订阅-发布</code>机制的<code>异步</code>通信技术，核心是<code>解耦</code>。</p>
<p>解耦(Decouple)是 [MQTT Essentials – A Lightweight IoT Protocol](resources/MQTT Essentials – A Lightweight IoT Protocol.epub) 内反复多次提到的一个词 。</p>
<a id="more"></a>

<blockquote>
<h3 id="发布-订阅模式-Publish-subscribe-pattern"><a href="#发布-订阅模式-Publish-subscribe-pattern" class="headerlink" title="发布/订阅模式(Publish-subscribe pattern)"></a>发布/订阅模式(Publish-subscribe pattern)</h3><p>与请求/回答这种同步模式不同，发布/定义模式解耦了发布消息的客户（发布者）与订阅消息的客户（订阅者）之间的关系，这意味着发布者和订阅者之间并不需要直接建立联系。打个比方，你打电话给朋友，一直要等到朋友接电话了才能够开始交流，是一个典型的同步请求/回答的场景；而给一个好友邮件列表发电子邮件就不一样，你发好电子邮件该干嘛干嘛，好友们到有空了去查看邮件就是了，是一个典型的异步发布/订阅的场景。</p>
<p>熟悉编程的同学一定非常熟悉这种设计模式了，因为它带来了这些好处：</p>
<ul>
<li>发布者与订阅者不必了解彼此，只要认识同一个消息代理即可。</li>
<li>发布者和订阅者不需要交互，发布者无需等待订阅者确认而导致锁定。</li>
<li>发布者和订阅者不需要同时在线，可以自由选择时间来消费消息。</li>
</ul>
<h3 id="主题-Topic"><a href="#主题-Topic" class="headerlink" title="主题(Topic)"></a>主题(Topic)</h3><p>MQTT是通过主题对消息进行分类的，本质上就是一个UTF-8的字符串，不过可以通过反斜杠表示多个层级关系。主题并不需要创建，直接使用就是了。</p>
<p>主题还可以通过通配符进行过滤。其中，+可以过滤一个层级，而*只能出现在主题最后表示过滤任意级别的层级。举个例子：</p>
<ul>
<li>building-b/floor-5：代表B楼5层的设备。</li>
<li>+/floor-5：代表任何一个楼的5层的设备。</li>
<li>building-b/*：代表B楼所有的设备。</li>
</ul>
<p>注意，MQTT允许使用通配符订阅主题，但是并不允许使用通配符广播。</p>
</blockquote>
<h2 id="遗言机制-Last-will"><a href="#遗言机制-Last-will" class="headerlink" title="遗言机制(Last will)"></a>遗言机制(Last will)</h2><p>遗言机制可以让订阅者知道设备异常离线，最重要的是离线后要做什么操作，这也是遗言的现实意义。</p>
<p><a href="https://segmentfault.com/a/1190000007266638">https://segmentfault.com/a/1190000007266638</a></p>
<p><a href="https://stackoverflow.com/questions/17270863/mqtt-what-is-the-purpose-or-usage-of-last-will-testament/17385293#17385293">https://stackoverflow.com/questions/17270863/mqtt-what-is-the-purpose-or-usage-of-last-will-testament/17385293#17385293</a></p>
<blockquote>
<p>I’m surely missing something about how the whole MQTT protocol works, as I can’t grasp the usage pattern of <em>Last Will Testament</em> messages: what’s their purpose?<br>One example I often see is about informing that a device has gone offline. It doesn’t make very much sense to me, since it’s obvious that if a device isn’t publishing any data it may be offline or there could be some network problems.</p>
<p>So, what are some practical usages of the LWT? What was it invented for?</p>
<hr>
<p>LWT messages are not really concerned about detecting whether a client has gone offline or not (that task is handled by keepAlive messages). LWT messages are about <strong>what happens after the client has gone offline</strong>. </p>
<p>The analogy is that of a <em>real</em> last will: If a person dies, she can formulate a testament, in which she declares what actions should be taken after she has passed away. An executor will heed those wishes and execute them on her behalf. The analogy in the MQTT world is that a client can formulate a testament, in which it declares what message should be sent on it’s behalf by the broker, after it has gone offline.</p>
<p><strong>A fictitious example:</strong></p>
<p>I have a sensor, which sends crucial data, but very infrequently. It has formulated a last will statement in the form of [topic: ‘/node/gone-offline’, message: ‘:id’], with :id being a unique id for the sensor. I also have a <em>emergency-subscriber</em> for the topic ‘node/gone-offline’, which will send a SMS to my phone every time a message is published on that channel.</p>
<p>During normal operation, the sensor will keep the connection to the MQTT-broker open by sending periodic keepAlive messages interspersed with the actual sensor readings. If the sensor goes offline, the connection to the broker will time out, due to the lack of keepAlives. </p>
<p>This is where LWT comes in: If no LWT is specified, the broker doesn’t care and just closes the connection. In our case however, the broker will execute the sensor’s last will and publish the LWT-message ‘/node/gone-offline: :id’. The message will then be consumed to my <em>emergency-subscriber</em>and I will be notified of the sensor’s ID via SMS so that I can check up on what’s going on.</p>
<p><strong>In short:</strong></p>
<p>Instead of just closing the connection after a client has gone offline, LWT messages can be leveraged to define a message to be published by the broker on behalf of the client, since the client is offline and cannot publish anymore.</p>
<p>Furthermore, keepAlive messages are only sent and received by the broker and there’s the main difference with the Last Will: anyone can suscribe to this topic and be aware of the client going offline</p>
</blockquote>
<h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p>page 69</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Client            Server</span><br><span class="line">   |--- CONNECT ---&gt;|</span><br><span class="line">   |&lt;-- CONNACK ----|</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MQTT</category>
      </categories>
  </entry>
  <entry>
    <title>mosquitto</title>
    <url>/2020/12/09/Network/MQTT/mosquitto/</url>
    <content><![CDATA[<h2 id="Mosquitto"><a href="#Mosquitto" class="headerlink" title="Mosquitto"></a>Mosquitto</h2><p>安装 mosquitto:</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install mosquitto</span><br></pre></td></tr></table></figure>

<p>启动 MQTT broker 服务:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew services start mosquitto</span><br></pre></td></tr></table></figure>

<p>Or</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;sbin&#x2F;mosquitto -c &#x2F;usr&#x2F;local&#x2F;etc&#x2F;mosquitto&#x2F;mosquitto.conf</span><br></pre></td></tr></table></figure>

<p>停止 MQTT broker 服务:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew services mosquitto stop</span><br></pre></td></tr></table></figure>

<h2 id="Mosquitto-with-TLS"><a href="#Mosquitto-with-TLS" class="headerlink" title="Mosquitto with TLS"></a>Mosquitto with TLS</h2><h3 id="tlsv1-alert-internal-error"><a href="#tlsv1-alert-internal-error" class="headerlink" title="tlsv1 alert internal error"></a>tlsv1 alert internal error</h3><p>按 “MQTT Essentials – A Lightweight IoT Protocol” 书中 “Configuring TLS transport security in Mosquitto” 章节所述的 Client subscribe 命令会报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mosquitto_sub -V mqttv311 -p 8883 --cafile &#x2F;usr&#x2F;local&#x2F;etc&#x2F;mosquitto&#x2F;certificates&#x2F;ca.crt -t sensors&#x2F;drone01&#x2F;altitude -d</span><br><span class="line">Client mosqsub|1181-yangshiwei sending CONNECT</span><br><span class="line">Error: A TLS error occurred.</span><br></pre></td></tr></table></figure>

<p>Broker 端错误日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1517841349: OpenSSL Error: error:14094438:SSL routines:ssl3_read_bytes:tlsv1 alert internal error</span><br><span class="line">1517841349: OpenSSL Error: error:140940E5:SSL routines:ssl3_read_bytes:ssl handshake failure</span><br><span class="line">1517841349: Socket error on client &lt;unknown&gt;, disconnecting.</span><br></pre></td></tr></table></figure>

<p>Wireshark 抓包数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5	::1	::1	TLSv1.2	 383 Client Hello</span><br><span class="line">7	::1	::1	TLSv1.2	2439 Server Hello, Certificate, Server Key Exchange, Server Hello Done</span><br><span class="line">9	::1	::1	TLSv1.2	  83 Alert (Level: Fatal, Description: Internal Error)</span><br></pre></td></tr></table></figure>

<pre><code>Transmission Control Protocol, Src Port: 49355, Dst Port: 8883, Seq: 308, Ack: 2364, Len: 7
Secure Sockets Layer
    TLSv1.2 Record Layer: Alert (Level: Fatal, Description: Internal Error)
        Content Type: Alert (21)
        Version: TLS 1.2 (0x0303)
        Length: 2
        Alert Message
            Level: Fatal (2)
            Description: Internal Error (80)</code></pre>
<p>无论是错误日志还是抓包数据都看不出来具体原因，只能知道是 Client 发生了内部错误，主动断开了连接。</p>
<p>最终在 google 上找到了答案：</p>
<p>原来是因为我的 CA root certificate 是自签名的，mosquiito 认为有安全风险，所以主动断开了连接。</p>
<p><a href="https://mcuoneclipse.com/2017/04/23/tuturial-mbedtls-sll-certificate-verification-with-mosquitto-lwip-and-mqtt/">Tuturial: mbedTLS SSL Certificate Verification with Mosquitto, lwip and MQTT</a></p>
<blockquote>
<h3 id="Mosquitto-Client-and-Server-Certificate-Usage"><a href="#Mosquitto-Client-and-Server-Certificate-Usage" class="headerlink" title="Mosquitto Client and Server Certificate Usage"></a>Mosquitto Client and Server Certificate Usage</h3><p>I’m running the broker with the following server certificate setting:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">certfile C:\Program Files (x86)\mosquitto\certs\m2mqtt_srv.crt</span><br></pre></td></tr></table></figure>

<p>Using the mosquitto client to subscribe, I can subscribe to a topic with the following command line, using that same certificate:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mosquitto_sub -c -i MyMQTTclient -h localhost -p 8883 -q 0 -t HSLU&#x2F;test -v --cafile c:\tmp\tls_ssl\client\m2mqtt_srv.crt --insecure</span><br></pre></td></tr></table></figure>

<p>Notice that I have to specify the option <strong>–insecure</strong>. Without the –insecure it will give an error message like this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1492934878: OpenSSL Error: error:14094438:SSL routines:ssl3_read_bytes:tlsv1 alert internal error</span><br><span class="line">1492934878: OpenSSL Error: error:140940E5:SSL routines:ssl3_read_bytes:ssl handshake failure</span><br><span class="line">1492934878: Socket error on client &lt;unknown&gt;, disconnecting.</span><br></pre></td></tr></table></figure>

<p>It took me while to find out why it is failing. A good way to test the TLS handshaking and connection is to use</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl s_client -connect localhost:8883</span><br></pre></td></tr></table></figure>

<p>which gives me the reason in the last line of the output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----END CERTIFICATE-----</span><br><span class="line">subject&#x3D;&#x2F;C&#x3D;CH&#x2F;ST&#x3D;Switzerland&#x2F;L&#x3D;Lucerne&#x2F;O&#x3D;HSLU&#x2F;OU&#x3D;T&amp;A&#x2F;CN&#x3D;ErichStyger-PC&#x2F;emailAddress&#x3D;mail@hslu.ch</span><br><span class="line">issuer&#x3D;&#x2F;C&#x3D;CH&#x2F;ST&#x3D;Switzerland&#x2F;L&#x3D;Lucerne&#x2F;O&#x3D;HSLU&#x2F;OU&#x3D;T&amp;A&#x2F;CN&#x3D;ErichStyger-PC&#x2F;emailAddress&#x3D;mail@hslu.ch</span><br><span class="line">---</span><br><span class="line">No client certificate CA names sent</span><br><span class="line">Peer signing digest: SHA512</span><br><span class="line">Server Temp Key: ECDH, P-256, 256 bits</span><br><span class="line">---</span><br><span class="line">SSL handshake has read 1605 bytes and written 434 bytes</span><br><span class="line">---</span><br><span class="line">New, TLSv1&#x2F;SSLv3, Cipher is ECDHE-RSA-AES256-GCM-SHA384</span><br><span class="line">Server public key is 2048 bit</span><br><span class="line">Secure Renegotiation IS supported</span><br><span class="line">Compression: NONE</span><br><span class="line">Expansion: NONE</span><br><span class="line">No ALPN negotiated</span><br><span class="line">SSL-Session:</span><br><span class="line">    Protocol  : TLSv1.2</span><br><span class="line">    Cipher    : ECDHE-RSA-AES256-GCM-SHA384</span><br><span class="line">    Session-ID: D241F3BFA8D26BDEE381353E2C517E46F8D04B48F307467A0E46FD7A2F3EB6BB</span><br><span class="line">    Session-ID-ctx:</span><br><span class="line">    Master-Key: &lt;cut&gt;</span><br><span class="line">    Key-Arg   : None</span><br><span class="line">    PSK identity: None</span><br><span class="line">    PSK identity hint: None</span><br><span class="line">    SRP username: None</span><br><span class="line">    TLS session ticket lifetime hint: 7200 (seconds)</span><br><span class="line">    TLS session ticket:</span><br><span class="line">    0000 - a0 fa a5 f5 8d 54 78 1a-7c 4e 86 51 4c 24 45 30   .....Tx.|N.QL$E0</span><br><span class="line">    0010 - 97 44 de c1 fb c7 06 96-46 ed ef 27 67 c2 91 6f   .D......F..&#39;g..o</span><br><span class="line">    0020 - 40 38 ef 86 2a 12 59 cb-f0 60 0d 34 e6 be 2a ef   @8..*.Y..&#96;.4..*.</span><br><span class="line">    0030 - e5 7c c8 ee c3 ac cb 25-ef 63 49 3c 27 2e b0 3c   .|.....%.cI&lt;&#39;..&lt;</span><br><span class="line">    0040 - e3 a6 88 53 08 20 4b 53-2f 2b 6e 44 20 1a e7 24   ...S. KS&#x2F;+nD ..$</span><br><span class="line">    0050 - 60 a3 1a b0 08 74 74 56-46 13 22 0a 76 df 32 53   &#96;....ttVF.&quot;.v.2S</span><br><span class="line">    0060 - d7 b1 6b 82 63 34 fc c8-9c 2c a6 16 a2 73 75 9d   ..k.c4...,...su.</span><br><span class="line">    0070 - 33 03 dc c7 db e0 c7 89-d0 49 ac fd 7d d3 33 0e   3........I..&#125;.3.</span><br><span class="line">    0080 - 35 eb df fc 05 b3 d0 bb-b7 02 25 67 86 71 76 f4   5.........%g.qv.</span><br><span class="line">    0090 - 56 59 3b 39 2a dc 04 0e-e1 60 ae e4 17 1c 8f 62   VY;9*....&#96;.....b</span><br><span class="line">    00a0 - b9 bf f1 99 5e c5 15 3c-ae 60 60 cb 8e 63 1a af   ....^..&lt;.&#96;&#96;..c..</span><br><span class="line"></span><br><span class="line">    Start Time: 1492935504</span><br><span class="line">    Timeout   : 300 (sec)</span><br><span class="line">    Verify return code: 18 (self signed certificate)</span><br><span class="line">---</span><br><span class="line">closed</span><br></pre></td></tr></table></figure>

<p>Ah, that makes sense: I have used a self-signed certificate :-). Now I know why I have to use the option <strong>–insecure</strong> with mosquitto_sub. I guess I could get rid of this with an non-self-signed certificate, but that’s too much of an effort for me now, as I’m only testing the connection.</p>
</blockquote>
<h4 id="mcuoneclipse-com"><a href="#mcuoneclipse-com" class="headerlink" title="mcuoneclipse.com"></a>mcuoneclipse.com</h4><p><a href="https://mcuoneclipse.com/">https://mcuoneclipse.com</a> 是个非常好的 MCU 开发网站。</p>
<p>关于 MQTT 还有一系列文章：</p>
<p><a href="https://mcuoneclipse.com/2017/04/17/tutorial-secure-tls-communication-with-mqtt-using-mbedtls-on-top-of-lwip/">Tutorial: Secure TLS Communication with MQTT using mbedTLS on top of lwip</a></p>
<p><a href="https://mcuoneclipse.com/2017/04/14/enable-secure-communication-with-tls-and-the-mosquitto-broker/">Enable Secure Communication with TLS and the Mosquitto Broker</a></p>
<h4 id="self-signed-certificate"><a href="#self-signed-certificate" class="headerlink" title="self-signed certificate"></a>self-signed certificate</h4><p><a href="https://en.wikipedia.org/wiki/Self-signed_certificate">Self-signed certificate</a></p>
<blockquote>
<p>In technical terms a self-signed certificate is one signed with its own <a href="https://en.wikipedia.org/wiki/Public-key_cryptography">private key</a>.</p>
</blockquote>
<h4 id="root-certificate"><a href="#root-certificate" class="headerlink" title="root certificate"></a>root certificate</h4><p><a href="https://zh.wikipedia.org/wiki/%E6%A0%B9%E8%AF%81%E4%B9%A6">wikipeida</a></p>
<blockquote>
<p>根证书没有上层机构再为其本身作数字签名，所以都是<a href="https://zh.wikipedia.org/w/index.php?title=%E8%87%AA%E7%B0%BD%E8%AD%89%E6%9B%B8&action=edit&redlink=1">自签证书</a>。许多<a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6">应用软件</a>（例如<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>、<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8">网页浏览器</a>）会预先安装可被信任的根证书，这代表用户授权了应用软件代为审核哪些根证书机构属于可靠，例如是公认可靠的政府机关（如<a href="https://zh.wikipedia.org/wiki/%E9%A6%99%E6%B8%AF%E9%83%B5%E6%94%BF">香港邮政</a>[<a href="https://zh.wikipedia.org/wiki/%E6%A0%B9%E8%AF%81%E4%B9%A6#cite_note-2">2]</a>）、专职机构（如<a href="https://zh.wikipedia.org/wiki/Google">Google</a>[<a href="https://zh.wikipedia.org/wiki/%E6%A0%B9%E8%AF%81%E4%B9%A6#cite_note-3">3]</a>、<a href="https://zh.wikipedia.org/wiki/Let%27s_Encrypt">Let’s Encrypt</a>、<a href="https://zh.wikipedia.org/wiki/CAcert">CAcert.org</a>、<a href="https://zh.wikipedia.org/wiki/%E7%A7%91%E6%91%A9%E5%A4%9A%E9%9B%86%E5%9B%A2">Comodo</a>、<a href="https://zh.wikipedia.org/wiki/DigiCert">DigiCert</a>、<a href="https://zh.wikipedia.org/wiki/GlobalSign">GlobalSign</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A8%81%E7%91%9E%E4%BF%A1">Verisign</a>）等。</p>
</blockquote>
]]></content>
      <categories>
        <category>MQTT</category>
      </categories>
  </entry>
  <entry>
    <title>PPP</title>
    <url>/2020/12/09/Network/TCPIP/PPP/</url>
    <content><![CDATA[<h2 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a>PPP</h2><h3 id="PPP-是神马？"><a href="#PPP-是神马？" class="headerlink" title="PPP 是神马？"></a>PPP 是神马？</h3><p><code>Point-to-Point Protocol</code>，是<code>点对点</code>的<code>数据链路层</code>协议。</p>
<p>组成如下：</p>
<ul>
<li>封装成帧。如帧定界符，CRC 校验。</li>
<li>链路建立，配置和监控协议（Link Control Protocol) LCP。如拨号验证，监控链路是否正常。</li>
<li>网络控制协议（Network Control Protocol) NCP。如协商来知晓或者配置网络层地址（如 IP 地址）。</li>
</ul>
<h3 id="PPP-文档在哪里？"><a href="#PPP-文档在哪里？" class="headerlink" title="PPP 文档在哪里？"></a>PPP 文档在哪里？</h3><p>入门在<a href="https://en.wikipedia.org/wiki/Point-to-Point_Protocol">WiKi</a>，详解在 RFC (其实也是 WiKi 跳过去的)。</p>
<ul>
<li><a href="https://tools.ietf.org/html/rfc1662">PPP 帧格式</a></li>
<li><a href="https://tools.ietf.org/html/rfc1661">PPP 和 LCP</a></li>
</ul>
<a id="more"></a>

<ul>
<li><a href="https://tools.ietf.org/html/rfc1332#page-2">NCP 和 IPCP</a></li>
<li><a href="https://tools.ietf.org/html/rfc1340#page-65">Protocol and Configure Field Number Assignments</a></li>
<li><a href="https://tools.ietf.org/html/rfc1661#page-6">PPP 流程</a></li>
</ul>
<h3 id="PPP-的层次"><a href="#PPP-的层次" class="headerlink" title="PPP 的层次"></a>PPP 的层次</h3><table>
<thead>
<tr>
<th align="left">Layer Name</th>
<th align="left">Example</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Network Layer</td>
<td align="left">IP, IPX</td>
</tr>
<tr>
<td align="left">Abstract Link Data Layer</td>
<td align="left">PPPoE, PPPoS</td>
</tr>
<tr>
<td align="left">Physical Link Data Layer</td>
<td align="left">Ethernet, Serial</td>
</tr>
<tr>
<td align="left">Physical Layer</td>
<td align="left">Coaxial cable, RS232</td>
</tr>
</tbody></table>
<p>PPP 是位于数据链路层和网络层之间的一个抽象的链路层，它可以让上层协议无需修改就可以在多种数据链路层上运行，比如通过 PPPoE 和 PPPoS，同一套TCP/IP 协议栈可以在各种厂家的以太网/串行接口网卡上运行（类比 Java 虚拟机）。</p>
<h3 id="PPP-的应用场合"><a href="#PPP-的应用场合" class="headerlink" title="PPP 的应用场合"></a>PPP 的应用场合</h3><p>无论是帧格式还是功能， PPP 看起来和以太网等链路协议都很相似，那么为什么不直接使用以太网，还要用 PPPoE(以太网上的 PPP) 呢，或者说 PPP 的应用场合是什么呢？</p>
<p>除了上节所述 PPP 向网络层提供了统一的抽象链路层功能外，PPP 还解决两个需求：</p>
<ul>
<li>用户鉴权<br>拨号上网方式需要认证用户的身份（如账号和密码），显然以太网协议中没有这个功能。</li>
<li>网络协商<br>局域网中新入网设备通过 DHCP 协议来获取 IP 地址，但显然拨号上网没有这个功能。</li>
</ul>
<p>PPP 提供了用户鉴权和网络协商，其实是个 2.5 层的协议。</p>
<h3 id="PPP-工作的三个阶段"><a href="#PPP-工作的三个阶段" class="headerlink" title="PPP 工作的三个阶段"></a>PPP 工作的三个阶段</h3><ul>
<li>配置协商阶段</li>
<li>用户鉴权阶段</li>
<li>网络协商阶段</li>
</ul>
<p><em>参考 &lt;计算机网络教程（第4版）&gt; - 3.2 点对点协议 PPP</em></p>
<h3 id="PPP-帧格式"><a href="#PPP-帧格式" class="headerlink" title="PPP 帧格式"></a>PPP 帧格式</h3><h3 id="PPP-转义"><a href="#PPP-转义" class="headerlink" title="PPP 转义"></a>PPP 转义</h3><h3 id="ACCM"><a href="#ACCM" class="headerlink" title="ACCM"></a>ACCM</h3><p>为什么 LCP 中控制字符会转义，而 NCP 中不被转义？<br>因为默认的 ACCM 是 0xFFFFFFFF，代表着所有的控制字符都要转义，所以 LCP 阶段的控制字符要转义，在 LCP 协商后，ACCM 协商为 0x00000000，代表着所遇的控制字符都不转义，所以在 LCP 阶段后就不被转义了。</p>
<h3 id="PPP-流程"><a href="#PPP-流程" class="headerlink" title="PPP 流程"></a>PPP 流程</h3><h2 id="PPPoS"><a href="#PPPoS" class="headerlink" title="PPPoS"></a>PPPoS</h2><p>PPP on Serial，即运行于串行接口上的 PPP 协议。例如 PC 通过 PPPoS 协议连接 GRPS 网卡实现上网。</p>
<h3 id="AT-指令和-PPP-的关系"><a href="#AT-指令和-PPP-的关系" class="headerlink" title="AT 指令和 PPP 的关系"></a>AT 指令和 PPP 的关系</h3><p>AT 指令和 PPP <code>没有半毛钱关系</code>。</p>
<p>PPP 是<code>数据链路层协议</code>；而 AT 指令是<code>终端指令集</code>，比如开关机，休眠，复位等。它们之间的区别就好像是 TCP/IP 和 Shell 命令之间的区别。</p>
<p>在实际应用中，主机要先通过 AT 指令来初始化和配置网卡，然后切换到数据模式来发起PPP协商，获取IP地址和鉴权，然后就可以上网了。</p>
<p>参考：<a href="https://www.cnblogs.com/emlslxl/p/6101181.html">关于PPP拨号 和 AT指令实现GPRS模块联网的疑问</a></p>
<h3 id="GPRS-模块-AT-模式和数据模式的切换"><a href="#GPRS-模块-AT-模式和数据模式的切换" class="headerlink" title="GPRS 模块 AT 模式和数据模式的切换"></a>GPRS 模块 AT 模式和数据模式的切换</h3><p>不同厂家的 GPRS 模块的初始化和配置流程是不同的，但一般都是在 ATD call 指令成功后自动切换到数据模式。</p>
<p>比如 MC35 的 ATD call 指令格式为ATDT<em>99**</em>1#rn，若在该指令执行之后给定的时间内返回CONNECT信息，则表明与服务提供商的连接建立成功；否则，表明拨号失败，无线传输功能无法正常启动。MC35成功登录移动梦网网关之后，将自动从命令模式切换到数据通信模式。</p>
<p>参考：<br><a href="http://www.eeworld.com.cn/mcu/2014/1114/article_17155.html">基于S3C2410的三导联远程心电监护</a><br><a href="http://bbs.csdn.net/topics/210057079/">ATD<em>99**</em>1这条AT命令是做什么用的</a></p>
<blockquote>
<p>对于会话管理层消息流程来说，PDP上下文激活和ATD＊99＃是完全一样地效果。<br>但是ATD＊99＃除了激活PDP上下文，MODEM内部一些状态也会发生改变，不会再保持AT命令状态，转而进入分组数据收发模式，这样才可以进行PPP协商。</p>
</blockquote>
<h3 id="GPRS-常见初始化指令"><a href="#GPRS-常见初始化指令" class="headerlink" title="GPRS 常见初始化指令"></a>GPRS 常见初始化指令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: GSM register</span><br><span class="line">op1&#x3D;&gt;operation: GPRS attach</span><br><span class="line">e&#x3D;&gt;end: PDP active</span><br><span class="line">st-&gt;op1-&gt;e</span><br></pre></td></tr></table></figure>

<p><a href="http://blog.sina.com.cn/s/blog_893e7cc101014hze.html">AT命令控制上网</a></p>
<h3 id="PPPoS-是运行在-MCU-和-GPRS-modem-之间的协议。"><a href="#PPPoS-是运行在-MCU-和-GPRS-modem-之间的协议。" class="headerlink" title="PPPoS 是运行在 MCU 和 GPRS modem 之间的协议。"></a>PPPoS 是运行在 MCU 和 GPRS modem 之间的协议。</h3><p>最初接触 PPPoS 时我以为 GPRS modem 仅仅是个透明传输，用户终端和 ISP 之间通过 PPP 协议来通信，其实并非这样，PPP 协议只存在于用户终端和 GPRS modem 之间，GPRS modem 和 ISP 之间使用的是 GPRS 内部协议来通信。也即 GPRS modem 内运行着一套 PPP stack，实现了 PPP 协议的各种功能（部分需要通过 GPRS 协议来实现）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[MCU]--&gt;| PPP |B[GRPS modem]</span><br><span class="line">B--&gt;|GPRS|C[ISP]</span><br></pre></td></tr></table></figure>

<p>比如 PPP 的 IPCP 用以获取 IP 地址，实际流程是这样的： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">MCU-&gt;&gt;GPRS modem: IPCP request (need IP)</span><br><span class="line">GPRS modem-&gt;&gt;ISP: PDP active</span><br><span class="line">ISP-&gt;&gt;GPRS modem: PDP context (contain IP)</span><br><span class="line">GPRS modem-&gt;&gt;MCU: IPCP ACK (contain IP)</span><br></pre></td></tr></table></figure>

<p>参考：<br><a href="http://www.xuebuyuan.com/924787.html">GPRS与PPP</a><br><a href="http://blog.chinaunix.net/uid-22477616-id-3511474.html">GPRS-PDP上下文的激活过程(外部协议栈)</a></p>
<h2 id="PPPoS-in-LwIP"><a href="#PPPoS-in-LwIP" class="headerlink" title="PPPoS in LwIP"></a>PPPoS in LwIP</h2><p><strong>以下内容均来自：<a href="resources/LwIP/doc/ppp.txt">doc/ppp.txt</a>，这是个牛逼且详细的关于在 LwIP 上使用 PPP 的文档，必须仔细读！</strong></p>
<p>在 LwIP 中使用（移植） PPPoS 只需要两步操作：</p>
<ol>
<li>开启 PPP 功能</li>
<li>配置 PPPoS</li>
</ol>
<h4 id="Enable-PPP"><a href="#Enable-PPP" class="headerlink" title="Enable PPP"></a>Enable PPP</h4><p>在用户定义的 lwipopts.h 内开启 PPP 的编译即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define PPP_SUPPORT 1</span><br></pre></td></tr></table></figure>

<p>因为 GPRS modem 还需要 PAP 鉴权，所以还要开启 PPP 的 PAP 部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define PAP_SUPPORT 1</span><br></pre></td></tr></table></figure>
<p>就酱</p>
<h4 id="Setup-PPPoS"><a href="#Setup-PPPoS" class="headerlink" title="Setup PPPoS"></a>Setup PPPoS</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A&#x3D;&gt;operation: Initialize GPRS modem.</span><br><span class="line">B&#x3D;&gt;operation: Create a new PPP connection(include interface).</span><br><span class="line">C&#x3D;&gt;operation: Set the PPP interface as the default network interface.</span><br><span class="line">D&#x3D;&gt;operation: Set PPP Authentication type, User name and Password.</span><br><span class="line">E&#x3D;&gt;operation: Initiate the PPP connection.</span><br><span class="line">F&#x3D;&gt;operation: Receive data from GPRS modem through UART.</span><br><span class="line">G&#x3D;&gt;operation: Pass received raw characters to PPPoS to be decoded through lwIP TCPIP thread.</span><br><span class="line">A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G-&gt;F</span><br></pre></td></tr></table></figure>
<ol>
<li>实现一个 UART 发送函数以供 PPP 协议栈内使用来发送 PPP 帧。比如:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static uint32_t ppp_output_callback(ppp_pcb *pcb, u8_t *data, uint32_t len, void *ctx)</span><br><span class="line">&#123;</span><br><span class="line">    return uart_write_bytes(data, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>实现一个事件回调函数以供 PPP 协议栈内使用来通知应用层各种事件。比如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void ppp_status_cb(ppp_pcb *pcb, int err_code, void *ctx)</span><br><span class="line">&#123;</span><br><span class="line">    switch (err_code) </span><br><span class="line">    &#123;</span><br><span class="line">    case PPPERR_NONE:</span><br><span class="line">    case PPPERR_PARAM:</span><br><span class="line">    case PPPERR_OPEN:</span><br><span class="line">    case PPPERR_DEVICE:</span><br><span class="line">    case PPPERR_ALLOC:</span><br><span class="line">    case PPPERR_USER:</span><br><span class="line">    case PPPERR_CONNECT:</span><br><span class="line">    case PPPERR_AUTHFAIL:</span><br><span class="line">    case PPPERR_PROTOCOL:</span><br><span class="line">    case PPPERR_PEERDEAD:</span><br><span class="line">    case PPPERR_IDLETIMEOUT:</span><br><span class="line">    case PPPERR_CONNECTTIME:</span><br><span class="line">    case PPPERR_LOOPBACK:</span><br><span class="line">    default:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建一个 PPP 连接。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* The PPP control block *&#x2F;</span><br><span class="line">ppp_pcb *ppp;</span><br><span class="line">&#x2F;* The PPP IP interface *&#x2F;</span><br><span class="line">struct netif ppp_netif;</span><br><span class="line"></span><br><span class="line">ppp &#x3D; pppapi_pppos_create(&amp;ppp_netif, ppp_output_callback, ppp_status_cb, NULL);</span><br></pre></td></tr></table></figure></li>
<li>设置为默认的网卡：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pppapi_set_default(ppp);</span><br></pre></td></tr></table></figure></li>
<li>配置鉴权方式，用户名和密码(中国移动不需要，所以为空)：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pppapi_set_auth(ppp, PPPAUTHTYPE_PAP, NULL, NULL);</span><br></pre></td></tr></table></figure></li>
<li>开始 PPP 连接：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pppapi_connect(ppp, 0);</span><br></pre></td></tr></table></figure></li>
<li>循环接收串口数据并交付给协议栈处理：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int len</span><br><span class="line">uint8_t data[1024];</span><br><span class="line"></span><br><span class="line">for(;;) </span><br><span class="line">&#123;</span><br><span class="line">    len &#x3D; uart_read_bytes(data, 1024, 10);</span><br><span class="line">    if (len &gt; 0) </span><br><span class="line">    &#123;</span><br><span class="line">        pppos_input_tcpip(ppp, (u8_t *)data, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>指示 PPP 的各个阶段：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void ppp_notify_phase_cb(ppp_pcb *pcb, u8_t phase, void *ctx) &#123;</span><br><span class="line">  switch (phase) &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Session is down (either permanently or briefly) *&#x2F;</span><br><span class="line">  case PPP_PHASE_DEAD:</span><br><span class="line">    led_set(PPP_LED, LED_OFF);</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">  &#x2F;* We are between two sessions *&#x2F;</span><br><span class="line">  case PPP_PHASE_HOLDOFF:</span><br><span class="line">    led_set(PPP_LED, LED_SLOW_BLINK);</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Session just started *&#x2F;</span><br><span class="line">  case PPP_PHASE_INITIALIZE:</span><br><span class="line">    led_set(PPP_LED, LED_FAST_BLINK);</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Session is running *&#x2F;</span><br><span class="line">  case PPP_PHASE_RUNNING:</span><br><span class="line">    led_set(PPP_LED, LED_ON);</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">  default:</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>TCPIP</category>
      </categories>
  </entry>
  <entry>
    <title>TCPIP Hacking</title>
    <url>/2020/12/09/Network/TCPIP/TCPIP%20Hacking/</url>
    <content><![CDATA[<h2 id="ARP-欺骗：发送伪造的网关-Gratuitous-ARP-包"><a href="#ARP-欺骗：发送伪造的网关-Gratuitous-ARP-包" class="headerlink" title="ARP 欺骗：发送伪造的网关 Gratuitous ARP 包"></a>ARP 欺骗：发送伪造的网关 Gratuitous ARP 包</h2><h3 id="无回报-Gratuitous-ARP请求"><a href="#无回报-Gratuitous-ARP请求" class="headerlink" title="无回报 (Gratuitous) ARP请求"></a>无回报 (Gratuitous) ARP请求</h3><p>主机在刚启动后一般会向局域网广播一个自己的<code>&lt;IP : MAC&gt;</code>信息，称为<code>无回报(gratuitous)ARP请求</code>。<br>无回报 ARP 请求其实就是<strong>目的 IP 是自己的 ARP 请求</strong>。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>比如一个局域网的网关地址是<code>192.168.31.1</code>，在此局域网内不停地发送伪造的 Gratuitous ARP 包，那么局域网内的所有的主机 ARP 表中的<code>192.168.31.1</code>就会被更新为伪造的随机 MAC 地址，进而导致主机发送的数据包都到不了网关，也无法与外界通信。</p>
<p>防御 ARP 欺骗的唯一方法就是在主机上为此网关添加一条静态的ARP映射，但是一般用户不会操作。</p>
<h3 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h3><p>在linux中提供了PF_PACKET接口可以操作链路层的数据。</p>
<a id="more"></a>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IP|ETH_P_ARP|ETH_P_ALL))</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>TCPIP</category>
      </categories>
  </entry>
  <entry>
    <title>TCP 协议抓包分析</title>
    <url>/2020/12/09/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="延迟确认"><a href="#延迟确认" class="headerlink" title="延迟确认"></a>延迟确认</h3><p><code>192.168.3.6</code>向<code>192.168.3.10</code>发送了一个数据报，<code>192.168.3.10</code>并没有马上回复 ACK，而是选择先等待一段时间…</p>
<p><strong>捎带确认</strong></p>
<p><img src="/2020/12/09/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/%5Btcp%5D-piggybacking-client.png" alt="tcp-piggybacking-client"></p>
<p><img src="/2020/12/09/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/%5Btcp%5D-piggybacking-server.png" alt="piggybacking-server"></p>
<p>刚好在 20 ms 后有数据报要发送给对方，于是就捎带上了这个 ACK。</p>
<p><strong>累计确认</strong></p>
<a id="more"></a>

<p><img src="/2020/12/09/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/%5Btcp%5D-delayedack-2seg.png" alt="delayedack"></p>
<p>很快它又收到了一个数据报，于是就回复了一个 ACK 来确认两个数据报。</p>
<p><strong>超时之后</strong></p>
<p><img src="/2020/12/09/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/%5Btcp%5D-delayedack-timeout.png" alt="delayedack"></p>
<p>过了 300 ms 后，即没有待发的数据报，也没有收到新的数据报，于是就回复了一个 ACK。</p>
<p><strong>总结</strong><br>一个 ACK 没有携带用户数据，却要发送至少 40 个字节长度的数据包，是对网络流量的浪费。不管捎带确认还是累计确认，目的都是尽量减少网络中的小包数量。</p>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p><code>192.168.3.6</code>向<code>192.168.3.10</code>连续发送数据。</p>
<p><img src="/2020/12/09/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/fast_retransmit.png" alt="fast_retransmit"></p>
<p>其中序号<code>3241</code>的数据报丢失了，所以<code>192.168.3.10</code>对所有后续到来的数据报都立即回复<code>ACK=3241</code>，如<code>78``79</code>号包。TCP 协议规定在连续收到 3 个相同的 ACK 后要快速重传，此处只有 2 个相同的 ACK 所以<code>192.168.3.6</code>会继续发送数据报。</p>
<p>在第 3 个相同的 ACK 后（<code>82</code>号包），<code>192.168.3.6</code>开始快速重传序号<code>3241</code>的数据报（<code>87</code>号包）。</p>
<p><code>192.168.3.10</code>收到序号<code>3241</code>的数据报后，应该回复<code>ACK=3241+536=3777</code>，但是事实上回复的是<code>ACK=8065</code>（<code>88</code>号包），为什么呢？因为虽然序号<code>3241</code>的数据报丢失了，但是序号<code>3777</code>到<code>7529</code>的数据报被<code>192.168.3.10</code>收到并且缓存了起来。所以当收到重传的序号<code>3241</code>的数据报后，<code>192.168.3.10</code>回复的是<code>ACK=8065</code>。</p>
<p>再往下看<code>94``95</code>号包又是两个重复<code>ACK=8065</code>，这是为什么呢？<strong>因为快速重传只会重传丢失的那一个数据报，而不会把后面所有未确认的包全部重传。</strong><code>192.168.3.6</code>只重传了序号<code>3241</code>的包，然后接着从序号<code>11817</code>的数据报开始发送了，但是<code>192.168.3.10</code>的期待接收的下个数据报序号是<code>8065</code>，所以回复了重复的 ACK。</p>
<h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p><code>192.168.3.6</code>向<code>192.168.3.10</code>连续发送数据。</p>
<p><img src="/2020/12/09/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/retransmit_timeout.png" alt="retransmit_timeout"></p>
<p>在发送完序号<code>13229</code>的数据报后等了 300ms 没有收到 ACK（<code>192.168.3.10</code>异常掉线），于是<code>192.168.3.6</code>开始超时重传。</p>
<p>第一个重传间隔是<code>RTO</code>，后面的重传间隔都是前面的 2 倍，也就是说重传间隔是按 2 的指数方式增长（术语：backoff，退避算法），直到第 12 次重传仍然没有收到 ACK，于是<code>192.168.3.6</code>就认为<code>192.168.3.10</code>已经异常掉线，就向它发送了一个<code>RST</code>。</p>
<h3 id="零窗口探测"><a href="#零窗口探测" class="headerlink" title="零窗口探测"></a>零窗口探测</h3><p><code>192.168.3.6</code>向<code>192.168.3.10</code>连续发送数据。</p>
<p><img src="/2020/12/09/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/zero_window_probe.png" alt="zero_window_probe"></p>
<p>发送完序号<code>22</code>包后，<code>192.168.3.10</code>向<code>192.168.3.6</code>回复了一个零窗口 ACK，表示自己的不能再接收数据了。然后<code>192.168.3.6</code>就会发送<code>TCP ZeroWindowProbe</code>。</p>
<p>TCP 通过接收窗口来实现流量控制。发送方接到零窗口通告时，则会停止报文段的发送，直到接收方通告非零的窗口。非零窗口通告一般在一个不含任何数据的ACK报文中发送，但ACK的传输并不可靠（ACK报文段不会被确认和重传），假设一个非零窗口通告丢失了，接收方等待接收数据（因为它已通告了一个非零的窗口），而发送方在等待非零窗口更新，就会产生死锁。为了解决这个问题，发送方使用一个坚持定时器<code>persist timer</code>来周期性地向接收方窗口是否被非零，这样的报文段称为窗口探査报文<code>window probe</code>。 </p>
<p>在 LwIP 中，<strong>窗口探测报本质是个长度为 1，序号为待确认报文段（如果没有，则是待发送报文段）的第 1 个字节的 TCP 数据报</strong>，对方一定会返回一个 ACK。协议栈收到一个零窗口通告后就开始窗口探查，收到非零窗口通告后就停止窗口探查。窗口探测的间隔时间会递增，但达到一个值后就不再改变。</p>
<p>关于零窗口探测包的实现，<a href="https://www.rfc-editor.org/rfc/rfc793.txt">RFC 793-Section 3.7-Page 42</a>中描述如下：</p>
<blockquote>
<p>The sending TCP must be prepared to accept from the user and send at least one octet of new data even if the send window is zero.  The sending TCP must regularly retransmit to the receiving TCP even when the window is zero.  Two minutes is recommended for the retransmission interval when the window is zero.  This retransmission is essential to guarantee that when either TCP has a zero window the re-opening of the window will be reliably reported to the other.</p>
<p>When the receiving TCP has a zero window and a segment arrives it must still send an acknowledgment showing its next expected sequence number and current window (zero).</p>
</blockquote>
<p>也就是说 TCP 发送方的零窗口探测报至少要包含一个字节的数据。但是在一些系统的实现中并没有严格遵守这个规范，比如吊吊的 Linux 中实际上发送的是长度为 0，序号为对方期望接收的序号减 1 的 TCP ACK 包（和 keep alive 报一毛一样）。</p>
<p>关于 Linux 上零窗口探测报的实现，老外的提问和解答 (<a href="http://linux.derkeiler.com/Newsgroups/comp.os.linux.networking/2004-04/0184.html">原文链接</a>):</p>
<blockquote>
<h4 id="Re-TCP-zero-window-probing"><a href="#Re-TCP-zero-window-probing" class="headerlink" title="Re: TCP zero window probing"></a>Re: TCP zero window probing</h4><p>From: Tauno Voipio (tauno.voipio_at_iki.fi.NOSPAM.invalid)<br>Date: 04/05/04</p>
<p>Louis Laborde wrote: </p>
<blockquote>
<p>It seems that to probe a closed receive window,<br>linux TCP implementation sends an empty segment<br>with its sequence number set to SND.UNA-1.<br>I was wondering if this was compliant with RFC<br>793 which does not seem to describe precisely<br>what such a probe should contain. </p>
<p>Thanks,<br>Louis. </p>
</blockquote>
<p>It is sensed as an extra retransmit/ACK for a byte<br>lready transferred. The peer should respond to<br>t with the current sequence &amp; acknowledgement<br>alues - which also carries the current window<br>nformation. </p>
<p>This is, IMHO, easier to handle than the pure<br>FC version of sending one byte over the window<br>size.</p>
<p>Tauno Voipio<br>tauno voipio @ iki fi </p>
</blockquote>
<p>还有一个(<a href="http://www.linuxsa.org.au/pipermail/linuxsa/2004-April/068243.html">原文链接</a>)，这个没有解答，但是抓包可供参考:</p>
<blockquote>
<p>Hi,</p>
<p>I am running a  client-server  program with client  running on a linux machine with 2.4.18-14 kernel installed.</p>
<p>When the server  announces  zero-window  to the  client,  client starts  sending   zero-window   probes  which  are  nothing  but unacceptable segments.</p>
<p>A short trace  obtained  using  tcpdump  and  interpreted  using ethereal is shown below:</p>
<blockquote>
<p>16:27:17.979349 e.f.g.h.33464 &gt; a.b.c.d.40000: P Seq=76441951 Ack=802335667 Win 5840 len=1080<br>27:18.040407 a.b.c.d.40000 &gt; e.f.g.h.33464: . Seq=802335667 Ack=764413031 Win 0 len=0<br>27:18.256213 e.f.g.h.33464 &gt; a.b.c.d.40000: . Seq=76443030 Ack=802335667 Win 5840 len=0</p>
</blockquote>
<p>This sequence continues as per retransmission algorithm.</p>
<p>It can be seen above that unacceptable  zero-length packets with a  sequence  no.  already   unacknowledged   is  being  used  as zero-window probes.</p>
<p>Zero  window  probes are defined in RFC 793 and  RFC1122 to be a data  segment  containing  atleast  one byte of data  beyond the window of the receiver who has closed the window.</p>
<p>This  seems  to be a bug.  Has it been  already  fixed in  later kernel versions or is this how it is intended to remain?</p>
<p>Regards,</p>
<p>Praveen</p>
</blockquote>
<p>从 Linux 的观点来看，不管使用什么方法，只要能让对方返回 ACK 就行了。</p>
<p>规范也是人定出来的，并不是真理，要不然也不会有那么多的修订版了，所以不要一昧迷信书本，须知尽信书不如无书，黑猫白猫抓到老鼠就是好猫。</p>
<h3 id="保活机制"><a href="#保活机制" class="headerlink" title="保活机制"></a>保活机制</h3><p>客户端<code>192.168.3.6</code>连接服务器<code>192.168.3.10</code>。</p>
<p><img src="/2020/12/09/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/keep_alive.png" alt="keep_alive"></p>
<p>客户端发送序号<code>14</code>的数据报后，过了很久（一般是 2 个小时）也没有新的数据发送，服务器为了确认客户端是否仍然正常运行，开始周期性（一般是 75 秒）的发送<code>Keep-Alive</code>探测包，当发送了 N 次（一般为 9 次）探测包客户端仍然没有相应时，就认为客户端已经异常掉线了，发送一个 RST 包。</p>
<p>在 LwIP 中，<strong>保活探查报本质上是长度为 0，序号为对方期望接收的序号减 1 的 TCP ACK 包</strong>，对方认为这是个失序的 TCP 报，就一定会返回一个 ACK。协议栈中 Keep alive 默认是关闭的，打开和配置代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int optval;</span><br><span class="line"></span><br><span class="line">&#x2F;* Enable keep alive *&#x2F;</span><br><span class="line">optval &#x3D; 1;</span><br><span class="line">setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, sizeof(optval));</span><br><span class="line"></span><br><span class="line">&#x2F;* Idle time before first KEEPALIVE probe is sent *&#x2F;</span><br><span class="line">optval &#x3D; 10;</span><br><span class="line">setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;optval, sizeof(optval));</span><br><span class="line"></span><br><span class="line">&#x2F;* Interval between probes *&#x2F;</span><br><span class="line">optval &#x3D; 5;</span><br><span class="line">setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &amp;optval, sizeof(optval));</span><br><span class="line"></span><br><span class="line">&#x2F;* Total number of probes sent *&#x2F;</span><br><span class="line">optval &#x3D; 5;</span><br><span class="line">setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &amp;optval, sizeof(optval));</span><br></pre></td></tr></table></figure>

<h3 id="伪重传"><a href="#伪重传" class="headerlink" title="伪重传"></a>伪重传</h3><p>在 wireshark 抓去 Wi-Fi 包时经常遇到<code>spurious retransmission</code>的情况：</p>
<p><img src="/2020/12/09/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/spurious_retransmission.png" alt="spurious_retransmission"></p>
<p>三次重传的间隔只有几毫秒，远小于超时重传的间隔，事实上这是 Wi-Fi 层的重传，并不是<code>伪重传</code>，只是 wireshark 显示的问题。</p>
<p>判断是 Wi-Fi 重传还是 TCP 重传的方法就是看 IP 包的 ID，如果一样那就是 Wi-Fi 重传，否则就是 TCP 重传，因为 TCP 重传包是新的 IP 包，所以 ID 也是不同。</p>
<h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><h3 id="ARP-的本质"><a href="#ARP-的本质" class="headerlink" title="ARP 的本质"></a>ARP 的本质</h3><p>ARP 的本质是<code>IP 和 MAC 的映射</code>，核心是<code>ARP 缓存表</code>。</p>
<h3 id="ARP-表更新的途径"><a href="#ARP-表更新的途径" class="headerlink" title="ARP 表更新的途径"></a>ARP 表更新的途径</h3><ul>
<li>收到发给自己的 ARP 回复</li>
<li>收到 ARP 请求</li>
<li>收到 IP 包</li>
</ul>
<h3 id="Wireshark-抓包"><a href="#Wireshark-抓包" class="headerlink" title="Wireshark 抓包"></a>Wireshark 抓包</h3><ul>
<li><p>Request</p>
<p><img src="/2020/12/09/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/%5Barp%5D-request.png" alt="arp-request"></p>
</li>
<li><p>Response</p>
<p><img src="/2020/12/09/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/%5Barp%5D-reponse.png" alt="arp-reponse"></p>
</li>
<li><p>Gratuitous</p>
<p><img src="/2020/12/09/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/%5Barp%5D-gratuitous.png" alt="arp-gratuitous"></p>
</li>
</ul>
<h3 id="无回报-Gratuitous-ARP请求"><a href="#无回报-Gratuitous-ARP请求" class="headerlink" title="无回报 (Gratuitous) ARP请求"></a>无回报 (Gratuitous) ARP请求</h3><p>主机在刚启动后一般会向局域网广播一个自己的<code>&lt;IP : MAC&gt;</code>信息，称为<code>无回报(gratuitous)ARP请求</code>。<br>无回报 ARP 请求其实就是<strong>目的 IP 是自己的 ARP 请求</strong>。</p>
<h3 id="ARP-欺骗：发送伪造的网关-Gratuitous-ARP-包"><a href="#ARP-欺骗：发送伪造的网关-Gratuitous-ARP-包" class="headerlink" title="ARP 欺骗：发送伪造的网关 Gratuitous ARP 包"></a>ARP 欺骗：发送伪造的网关 Gratuitous ARP 包</h3><p>比如一个局域网的网关地址是<code>192.168.31.1</code>，在此局域网内不停地发送伪造的 Gratuitous ARP 包，那么局域网内的所有的主机 ARP 表中的<code>192.168.31.1</code>就会被更新为伪造的 MAC 值，进而导致主机发送的数据包都到不了网关。</p>
<h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><h3 id="频繁重连后DHCP无法获取地址或获取地址慢"><a href="#频繁重连后DHCP无法获取地址或获取地址慢" class="headerlink" title="频繁重连后DHCP无法获取地址或获取地址慢"></a>频繁重连后DHCP无法获取地址或获取地址慢</h3><p><strong>摘要：</strong>WIFI上网时，有时会出现无线用户接入后获取地址慢，而且经常无线网卡提示连接受限的现象。该情况将直接影响到用户的使用感受。本文主要分析了该问题发生的主要原因以及解决方案。</p>
<p><strong>关键词：</strong>WIFI  连接受限  DHCP获取地址慢</p>
<p><strong>正文：</strong></p>
<p>在无锡市区的一些热点区域，经常会有用户反映出现无线接入后获取地址慢，而且有时会出现无线网卡提示受限连接的现象。该情况将直接影响到用户的使用感受。  </p>
<p>针对上面的现象，我们进行了现场的分析和定位，确定了最终的原因：<strong>该现象的最终原因不是WLAN接入造成，而是DHCP server所引起的。</strong> </p>
<p><strong>DHCP Server进行了一定的保护，也就是当DHCP server成功分配出一个地址以后，对于再次来自于客户端设备的DHCP请求将不作处理，只有原来的表项老化以后，才可能继续重新为客户端设备分配地址。</strong></p>
<p>由于无线的特殊性，网卡在信号不稳的时候会出现重新连接，或者最终用户在使用过程中可能直接拔插网卡的情况，这样相当于链路异常断开，最终导致DHCP server不知道用户已经下线。<strong>而当用户再次申请地址的时候，DHCP server可能认为报文非法而不进行处理，最终出现了获取地址慢的现象。</strong></p>
<p>通过有线进行测试也验证同样存在该问题。先使用有线网卡连接，保证成功获取地址，之后直接将网卡禁用后在使能，可以发现该网卡同样无法在短时间内获取地址。  </p>
<p>下面是用户DHCP申请地址的流程：</p>
<p><img src="/2020/12/09/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/%5Bdhcp%5D-dhcp_flow.png" alt="dhcp-dhcp_flow"></p>
<p>造成获取地址慢的原因：当DHCP server成功发送DHCP ACK报文之后，DHCP server将认为它已经成功为Client分配了一个IP地址，在没有接收到Release报文之前，或者自己的表项没有老化之前，再次收到来自于Client的报文，DHCP server将作为非法报文处理。  </p>
<ul>
<li><strong>获取地址慢的出现情况一：</strong>  </li>
</ul>
<p>如果客户端出现异常断开（也就是客户端虽然断开连接，但是没有发送DHCP Release报文），当该客户端再次连接的时候会出现无法获取地址，只有等待足够的一段时间后，才可以获取地址的问题。</p>
<p>能够造成该种情况的操作：  </p>
<ol>
<li>直接将有线网卡禁用；</li>
<li>直接将无线网卡禁用；</li>
<li>直接拔插无线网卡； </li>
</ol>
<ul>
<li><strong>获取地址慢的出现情况二：</strong></li>
</ul>
<p>由于客户端和服务器经过了大量的有线网络，所以在获取地址的瞬间，有可能出现报文延时的问题，特别当DHCP server回复的DHCP ACK报文延时到达客户端的时候，此时客户端会认为它已经发送的DHCP request报文超时，状态机回到初始位置，重新发送DHCP discovery报文。但是由于DHCP服务器已经发送了ACK，所以认为已经成功给客户端分配了地址，所以会忽略掉客户端的新的DHCP discovery请求。造成客户端获取不到地址或者需要经过一段时间后才可以获取地址。</p>
<p>下面是在AP上行端口抓包，第110条报文，AP将客户端的DHCP request报文成功发送出去，但是等待了10ms之后没有收到服务器的DHCP ACK报文，所以重新发送DHCP discovery报文申请地址；但是此时服务器实际上已经发送了一个DHCP ACK报文（只是该报文在60ms之后到达）。这样就造成了客户端和服务器的状态机不一致，服务器不再处理新的DHCP Discovery请求。</p>
<p><img src="/2020/12/09/Network/TCPIP/TCP%20%E5%8D%8F%E8%AE%AE%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/%5Bdhcp%5D-dhcp_timeout.png" alt="dhcp-dhcp_timeout"></p>
<p>这个现象只能通过DHCP server上面的优化，目前该现象与WLAN网络和有线网络都没有关系，WLAN设备没有问题。由于DHCP服务器管理了很多的接入服务，需要仔细考虑如何进行优化。</p>
]]></content>
      <categories>
        <category>TCPIP</category>
      </categories>
  </entry>
  <entry>
    <title>AliOS-Things KV</title>
    <url>/2020/12/09/OS/AliOS-Things/AliOS-Things%20KV/</url>
    <content><![CDATA[<h2 id="block"><a href="#block" class="headerlink" title="block"></a>block</h2><p>block 的头部如下：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* Flash block header description *&#x2F;</span><br><span class="line">typedef struct _block_header_t &#123;</span><br><span class="line">    uint8_t     magic;          &#x2F;* The magic number of block *&#x2F;</span><br><span class="line">    uint8_t     state;          &#x2F;* The state of the block *&#x2F;</span><br><span class="line">    uint8_t     reserved[2];</span><br><span class="line">&#125; __attribute__((packed)) block_hdr_t;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">magic</th>
<th align="left">state</th>
<th align="left">reserved</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ASCII ‘K’</td>
<td align="left">1B</td>
<td align="left">2B</td>
</tr>
</tbody></table>
<p>magic 是 ASCII 码 ‘K’：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static const uint8_t BLK_MAGIC_NUM  &#x3D; &#39;K&#39;; &#x2F;* The block header magic number *&#x2F;</span><br></pre></td></tr></table></figure>

<p>state 有 3 种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define BLK_STATE_USED  0xCC &#x2F;* Block state: USED --&gt; block is inused and without dirty data *&#x2F;</span><br><span class="line">#define BLK_STATE_CLEAN 0xEE &#x2F;* Block state: CLEAN --&gt; block is clean, ready for used *&#x2F;</span><br><span class="line">#define BLK_STATE_DIRTY 0x44 &#x2F;* Block state: DIRTY --&gt; block is inused and with dirty data *&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="item"><a href="#item" class="headerlink" title="item"></a>item</h2><p>item 的头部如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* Key-value item header description *&#x2F;</span><br><span class="line">typedef struct _item_header_t &#123;</span><br><span class="line">    uint8_t     magic;          &#x2F;* The magic number of key-value item *&#x2F;</span><br><span class="line">    uint8_t     state;          &#x2F;* The state of key-value item *&#x2F;</span><br><span class="line">    uint8_t     crc;            &#x2F;* The crc-8 value of key-value item *&#x2F;</span><br><span class="line">    uint8_t     key_len;        &#x2F;* The length of the key *&#x2F;</span><br><span class="line">    uint16_t    val_len;        &#x2F;* The length of the value *&#x2F;</span><br><span class="line">    uint16_t    origin_off;     &#x2F;* The origin key-value item offset, it will be used when updating *&#x2F;</span><br><span class="line">&#125; __attribute__((packed)) item_hdr_t;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">magic</th>
<th align="left">state</th>
<th align="left">crc</th>
<th align="left">key_len</th>
<th align="left">val_len</th>
<th align="left">origin_off</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ASCII ‘I’</td>
<td align="left">1B</td>
<td align="left">1B</td>
<td align="left">1B</td>
<td align="left">2B</td>
<td align="left">2B</td>
</tr>
</tbody></table>
<p>magic 是 ASCII 码 ‘I’：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static const uint8_t ITEM_MAGIC_NUM &#x3D; &#39;I&#39;; &#x2F;* The key-value item header magic number *&#x2F;</span><br></pre></td></tr></table></figure>

<p>state 有 2 种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define ITEM_STATE_NORMAL 0xEE &#x2F;* Key-value item state: NORMAL --&gt; the key-value item is valid *&#x2F;</span><br><span class="line">#define ITEM_STATE_DELETE 0    &#x2F;* Key-value item state: DELETE --&gt; the key-value item is deleted *&#x2F;</span><br></pre></td></tr></table></figure>

<p>crc 是 key 和 value 的 8 bit 校验码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* CRC-8: the poly is 0x31 (x^8 + x^5 + x^4 + 1) *&#x2F;</span><br><span class="line">static uint8_t utils_crc8(uint8_t *buf, uint16_t length)</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t crc &#x3D; 0x00;</span><br><span class="line">    uint8_t i;</span><br><span class="line"></span><br><span class="line">    while (length--) &#123;</span><br><span class="line">        crc ^&#x3D; *buf++;</span><br><span class="line">        for (i &#x3D; 8; i &gt; 0; i--) &#123;</span><br><span class="line">            if (crc &amp; 0x80) &#123;</span><br><span class="line">                crc &#x3D; (crc &lt;&lt; 1) ^ 0x31;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                crc &lt;&lt;&#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return crc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>key_len 是 key 的长度</p>
<p>val_len 是 value 的长度</p>
<p>origin_off 是上个旧 item 的 offset</p>
<p>通过一个实验来理解，例如，我 set name snowyang，然后 set name snowyang-1992，再 set name snowyang-19920202，最后 dump 出来的 binary 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000h: 4B 44 00 00 49 00 98 04 08 00 00 00 6E 61 6D 65 ; KD..I.......name</span><br><span class="line">00000010h: 73 6E 6F 77 79 61 6E 67 49 00 37 04 0D 00 04 00 ; snowyangI.7.....</span><br><span class="line">00000020h: 6E 61 6D 65 73 6E 6F 77 79 61 6E 67 2D 31 39 39 ; namesnowyang-199</span><br><span class="line">00000030h: 32 00 00 00 49 EE D6 04 11 00 18 00 6E 61 6D 65 ; 2...IîÖ.....name</span><br><span class="line">00000040h: 73 6E 6F 77 79 61 6E 67 2D 31 39 39 32 30 32 30 ; snowyang-1992020</span><br><span class="line">00000050h: 32 00 00 00 FF FF FF FF FF FF FF FF FF FF FF FF ; 2...ÿÿÿÿÿÿÿÿÿÿÿÿ</span><br></pre></td></tr></table></figure>

<p>可见第二个 item 的 <code>origin_off</code> 是 0x04，也就是第一个 item 的地址，同样地，第三个 item 的 <code>origin_off</code> 是第二个 item 的地址 0x18</p>
<p>具体作用不明</p>
<h3 id="描述-item-的结构体如下："><a href="#描述-item-的结构体如下：" class="headerlink" title="描述 item 的结构体如下："></a>描述 item 的结构体如下：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* Key-value item description *&#x2F;</span><br><span class="line">typedef struct _kv_item_t &#123;</span><br><span class="line">    item_hdr_t  hdr;            &#x2F;* The header of the key-value item, detail see the item_hdr_t structure *&#x2F;</span><br><span class="line">    char       *store;          &#x2F;* The store buffer for key-value *&#x2F;</span><br><span class="line">    uint16_t    len;            &#x2F;* The length of the buffer *&#x2F;</span><br><span class="line">    uint16_t    pos;            &#x2F;* The store position of the key-value item *&#x2F;</span><br><span class="line">&#125; kv_item_t;</span><br></pre></td></tr></table></figure>

<p>需要注意：这个结构体是用来描述一个 item 的，是一个变量，不是描述 item 的存储结构的</p>
<p>hdr 是上述头部</p>
<p>store 是实际存储 key 和 value 的 buffer，一般是 malloc 来的</p>
<p>len 是 header + key + value 的长度，注意是 4 字节对齐</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">len &#x3D; (ITEM_HEADER_SIZE + hdr-&gt;key_len + hdr-&gt;val_len + ~KV_ALIGN_MASK) &amp; KV_ALIGN_MASK;</span><br></pre></td></tr></table></figure>

<p>pos 是 item 在 flash 中的地址</p>
]]></content>
      <categories>
        <category>AliOS-Things</category>
      </categories>
  </entry>
  <entry>
    <title>FreeRTOS</title>
    <url>/2020/12/09/OS/FreeRTOS/FreeRTOS/</url>
    <content><![CDATA[<h2 id="FreeRTOS"><a href="#FreeRTOS" class="headerlink" title="FreeRTOS"></a>FreeRTOS</h2><ul>
<li><p>老版本的 FreeRTOS 如何下载？<br><a href="https://sourceforge.net/p/freertos/code/HEAD/tree/%EF%BC%8C%E7%82%B9%E5%87%BB">https://sourceforge.net/p/freertos/code/HEAD/tree/，点击</a> tags 进入，选择版本然后点击<code>Download Snapshot</code>按钮即可启动下载。</p>
</li>
<li><p>FreeRTOS 配置选项<br>FreeRTOSConfig.h 的说明：<a href="https://www.freertos.org/a00110.html">https://www.freertos.org/a00110.html</a></p>
</li>
<li><p>如何移植<br><a href="https://www.freertos.org/FreeRTOS-porting-guide.html">https://www.freertos.org/FreeRTOS-porting-guide.html</a></p>
</li>
<li><p>中断优先级设置？</p>
<p>在移植 5062 时遇到了 StartScheduler 函数内执行 SVC 0 指令后触发 Hardfault 的错误，调试发现是 SVC 中断被屏蔽所导致的。FreeRTOS 在 StartScheduler 前会 portDISABLE_INTERRUPTS，Cortex-M 是通过写 BASEPRI 来屏蔽中断的，5062 的BASRPRI 的值被写为 0x20，而 SVC 的优先级恰好也被设置成了 0x20，所以 SVC 中断被屏蔽了。在 SVC 中断被屏蔽时去触发它会产生一个用法错误 - Hardfaut。</p>
<blockquote>
<p>configMAX_SYSCALL_INTERRUPT_PRIORITY needs to be a raw priority value as it is written to the NVIC priority registers in the Cortex-M3 device, as documented in the ARM manuals. The priorities of 0..15 are not real Cortex-M3 priorities, and are simplified priorities for use in some library calls (because the real priorities are so complex on Cortex-M devices).</p>
</blockquote>
</li>
</ul>
<a id="more"></a>

<blockquote>
<p>If you want a simplified priority of 8, then you need to set configMAX_SYSCALL_INTERRUPT_PRIORITY to 0x8n, where n can be any value, but by convention, and for future proofing in case future STM32 parts implement more priority bits, should be set to f. Therefore, the priority you want is 0x8f.<br>“the code app-faults at “svc 0” in vPortStartFirstTask”<br>Presumably a hard fault because you are attempting a call to effectively a synchronous interrupt while simultaneously having that interrupt masked out.</p>
</blockquote>
<ul>
<li><p>FreeRTOS 只有在任务切换时才会检查栈当前栈是否溢出，所以不是所有的线程的栈溢出都能被检查到的。</p>
</li>
<li><p>在移植 STM32L431RC 时遇到了上位机发送数据后，UART 接收线程却没有接收到数据的问题。</p>
<p>UART 接收大致流程如下：</p>
<blockquote>
<p>用户线程：拿 semphr -&gt; 读取数据<br>UART 接收中断：给 semphr</p>
</blockquote>
<p>调试发现中断中给了 semphr ，但是线程没有拿到，原来是在拿 semphr 中的临界区出了问题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">taskENTER_CRITICAL();</span><br><span class="line"><span class="keyword">const</span> UBaseType_t uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;</span><br><span class="line"><span class="keyword">if</span>( uxMessagesWaiting &gt; ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get data</span></span><br><span class="line">    <span class="comment">// Return</span></span><br><span class="line">&#125;</span><br><span class="line">taskEXIT_CRITICAL();</span><br><span class="line"><span class="comment">// Block current thread untill semphr is gived</span></span><br></pre></td></tr></table></figure>

<p>taskENTER_CRITICAL 是把优先级低于 CORTEX_NVIC_PRIO_BITS 的中断全部屏蔽。</p>
<p>STM32L431RC 的抢占优先级数是 4，而我把 CORTEX_NVIC_PRIO_BITS 设置成了 3，刚好 UART 中断配的是最高优先级 0，所以 taskENTER_CRITICAL 实际上对 UART 中断不起作用，若在第 2 行后刚好来了一个 UART 接收中断，虽然中断内给了 semphr，但是中断返回后，第 4 行还是认为没有给 semphr，所以出错。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>FreeRTOS</category>
      </categories>
  </entry>
  <entry>
    <title>sudo</title>
    <url>/2020/12/09/OS/Linux/sudo/</url>
    <content><![CDATA[<p><code>sudo</code>就是<code>su do</code>的意思。</p>
<p><code>su</code>是<code>super user</code>的缩写。</p>
<p>在 user 账号下 pip install 的库，sudo 是找不到的，必须 sudo pip install，因为 sudo 会切到 root 账号。</p>
<a id="more"></a>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Zephyr Primer</title>
    <url>/2020/12/09/OS/Zephyr/Zephyr%20Primer/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Zephyr 最初是<code>Wind River</code>公司在 2015 年推出的为 IoT 开发的<code>Rocket内核</code>，更早时称为<code>Microkernel Profile for VxWorks</code>。代码移植于2001年并购<code>Eonic Systems</code>得来的<code>Virtuoso DSP RTOS</code>。在2016年，它成为Linux基金会的项目而改称 zephyr。</p>
<p>参考：<a href="https://zh.wikipedia.org/wiki/Zephyr">Zephyr Wiki</a></p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p><strong>官网</strong>：<a href="https://zephyrproject.org/">https://zephyrproject.org</a></p>
<p><strong>文档</strong>：<a href="https://docs.zephyrproject.org/latest">https://docs.zephyrproject.org/latest</a></p>
<p><strong>源代码</strong>：<a href="https://github.com/zephyrproject-rtos/zephyr">https://github.com/zephyrproject-rtos/zephyr</a></p>
<p><strong>Wiki</strong>：<a href="https://github.com/zephyrproject-rtos/zephyr/wiki">https://github.com/zephyrproject-rtos/zephyr/wiki</a></p>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>参考<a href="https://docs.zephyrproject.org/latest/getting_started/index.html">Getting Started Guide</a></p>
<h2 id="配置-Kconfig"><a href="#配置-Kconfig" class="headerlink" title="配置 Kconfig"></a>配置 Kconfig</h2><p>参考<a href="https://docs.zephyrproject.org/latest/guides/kconfig/menuconfig.html">Interactive Kconfig interfaces</a></p>
<p>有两个交互式配置界面可以配置 Kconfig选项：<code>menuconfig</code>和 <code>guiconfig</code>。<code>menuconfig</code>是在终端中运行的基于curses的界面，<code>guiconfig</code>而是图形配置界面。</p>
<p>要运行 menuconfig，请执行以下操作：</p>
<ol>
<li><p>使用<code>west</code>或者<code>cmake</code>构建您的应用程序：</p>
<p>使用west</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">west build -b &lt;board&gt;</span><br></pre></td></tr></table></figure>

<p>使用CMake和忍者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line">cmake -GNinja -DBOARD&#x3D;&lt;board&gt; ..</span><br><span class="line">ninja</span><br></pre></td></tr></table></figure>
</li>
<li><p>要运行基于终端的<code>menuconfig</code>界面，请使用以下命令之一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">west build -t menuconfig</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ninja menuconfig</span><br></pre></td></tr></table></figure>

<p>要运行图形<code>guiconfig</code>，请使用以下命令之一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">west build -t guiconfig</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ninja guiconfig</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">west build -b nrf52dk_nrf52832 samples&#x2F;hello_world</span><br><span class="line">west flash</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Zephyr</category>
      </categories>
  </entry>
  <entry>
    <title>磁盘占用查看工具 - treesize</title>
    <url>/2020/12/09/OS/Windows/%E7%A3%81%E7%9B%98%E5%8D%A0%E7%94%A8%E6%9F%A5%E7%9C%8B%E5%B7%A5%E5%85%B7%20-%20treesize/</url>
    <content><![CDATA[<p>有时候 C 盘红了，不知道哪些大文件吃了硬盘，可以用 treesize 来分析。</p>
<p><img src="/2020/12/09/OS/Windows/%E7%A3%81%E7%9B%98%E5%8D%A0%E7%94%A8%E6%9F%A5%E7%9C%8B%E5%B7%A5%E5%85%B7%20-%20treesize/image-20201203110215721.png" alt="image-20201203110215721"></p>
<a id="more"></a>

]]></content>
      <categories>
        <category>Windows</category>
      </categories>
  </entry>
  <entry>
    <title>Zephyr UART</title>
    <url>/2020/12/09/OS/Zephyr/Zephyr%20UART/</url>
    <content><![CDATA[<p>Demo</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;zephyr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;drivers/uart.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cli_uart_isr</span><span class="params">(<span class="keyword">const</span> struct device *uart, <span class="keyword">void</span> *user_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint8_t</span> c;</span><br><span class="line">	<span class="keyword">int</span> rx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get all of the data off UART as fast as we can */</span></span><br><span class="line">	<span class="keyword">while</span> (uart_irq_update(uart) &amp;&amp; uart_irq_rx_ready(uart)) &#123;</span><br><span class="line">		rx = uart_fifo_read(uart, &amp;c, <span class="keyword">sizeof</span>(c));</span><br><span class="line">		<span class="keyword">if</span> (rx &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		uart_poll_out(dev, c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uart_fifo_flush</span><span class="params">(<span class="keyword">const</span> struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint8_t</span> c;</span><br><span class="line">	<span class="keyword">while</span> (uart_fifo_read(dev, &amp;c, <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">uart_dev</span> =</span> device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);    </span><br><span class="line">  </span><br><span class="line">  uart_irq_rx_disable(uart_dev);</span><br><span class="line">	uart_irq_tx_disable(uart_dev);</span><br><span class="line">	uart_fifo_flush(uart_dev);</span><br><span class="line">	uart_irq_callback_set(uart_dev, cli_uart_isr);</span><br><span class="line">	uart_irq_rx_enable(uart_dev);</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		k_sleep(K_SECONDS(<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Zephyr</category>
      </categories>
  </entry>
  <entry>
    <title>C 入口函数分析</title>
    <url>/2020/12/09/Programing%20Language/C/C%20%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>Linux系统下一般程序的入口是<code>_start</code>，这个函数是Linux系统库（Glibc）的一部分。同样地，newlib等C库也是以<code>_start</code>作为入口函数。</p>
<p>对于C++程序，有两个特殊的段：<code>.init</code> 和 <code>.fini</code>。这两个段.init和.fini的存在有着特别的目的，如果一个函数放到.init段，在main函数执行前系统就会执行它。同理，假如一个函数放到.fint段，在main函数返回后该函数就会被执行。利用这两个特性，C++的全局构造和析构函数就由此实现。</p>
<a id="more"></a>

]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>C 整型转换</title>
    <url>/2020/12/09/Programing%20Language/C/C%20%E6%95%B4%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int8_t a &#x3D; -1;</span><br><span class="line">uint32_t b &#x3D; a;</span><br><span class="line">b &#x3D; ?</span><br></pre></td></tr></table></figure>

<p>这要用到整型转换规则， <strong>C Programming Language(K &amp; R)</strong> (A.6.2)上这样解释：</p>
<blockquote>
<p>将任何整数转换为某种指定的无符号数类型数的方法是：以该无符号数类型能够表示的最大值加1为模，找出与此整数同余的最小的非负值。<br>在对二的补码表示中，如果该无符号类型的位模式较窄，这就相当于左截取；如果该符号类型的位模式较宽，这就相当于对带符号的值进行符号扩展和对无符号的值进行0填充。</p>
</blockquote>
<p>将任何整数转换为带符号类型时，如果它可以在新的类型中表示出来，则其值保持不变，否则它的值同具体的实现有关。</p>
<p>其中<code>以该无符号数类型能够表示的最大值加1为模，找出与此整数同余的最小的非负值</code>，我觉得太拗口，下面那段才比较好理解<code>在对二的补码表示中，如果该无符号类型的位模式较窄，这就相当于左截取；如果该符号类型的位模式较宽，这就相当于对带符号的值进行符号扩展和对无符号的值进行0填充。</code></p>
<p>比如把 0x1234 放到一个 uint8_t 类型变量 x 中，那么高 8 位就被截掉，低 8 位被放到变量中，最终 x 的值为 0x34。<br>比如把 -1 放到 x 中，因为 -1 的二进制码是 0xFFFFFFFF，那么 x 的值就等于 0xFF。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>C 隐式类型转换</title>
    <url>/2020/12/09/Programing%20Language/C/C%20%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>在项目中遇到一个奇怪的问题，伪代码如下：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int8_t  a &#x3D; 0x8F;</span><br><span class="line">uint8_t b &#x3D; 0x8F；</span><br><span class="line"></span><br><span class="line">if( a &#x3D;&#x3D; b )</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;a &#x3D; b\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;a !&#x3D; b, a &#x3D; %02x, b &#x3D; %02x\n&quot;, a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照我的理解，<code>if(a == b)</code>一定为真。但运行结果却让我大跌眼镜:</p>
<p><code>a != b, a = ffffff8f, b = 8F</code></p>
<p>首先，变量<code>a</code>不等于<code>b</code>已经让我吃惊了，然后，打印出来<code>a</code>的值竟然是<code>ffffff8f</code>！<br>查了一通资料，我才知道，原来在 C 语言中有<code>隐式类型转换</code>这么一个规则。<br><code>隐式类型转换</code>是指变量在运算中的一种隐式的类型转换，主要分两种：<code>算术</code>和<code>赋值</code>转换。</p>
<p>##算术转换</p>
<hr>
<p>算术转换的规则可以用一张图来表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HIGH</span><br><span class="line">  ^</span><br><span class="line">double &lt;-- float</span><br><span class="line">  |</span><br><span class="line">long</span><br><span class="line">  |</span><br><span class="line">unsigned </span><br><span class="line">  |</span><br><span class="line">int &lt;-- char, short</span><br><span class="line">  ^</span><br><span class="line">LOW  </span><br></pre></td></tr></table></figure>

<p>此图中有两个箭头。</p>
<p>竖向箭头表示不同的数据类型在进行混合运算的时候，会有一个低字节向高字节转换的过程。术语叫<code>寻常算术转换</code>（<code>usual arithmetic conversion</code>）。</p>
<p>横向箭头表示不管该类型有没有进行混合运算都势必会进行转换，再进行运算，术语叫<code>整型提升</code>（<code>Integral promotions</code>）。</p>
<p>##赋值转换</p>
<hr>
<p>进行赋值操作时，赋值运算符右边的数据类型必须转换成赋值号左边的类型，若右边的数据类型的长度大于左边，则要进行求余的截取操作。</p>
<p>如定义变量<code>uint8_t a = 257；</code>，因为<code>uint8_t</code>类型的最大值是<code>256</code>，所以要求余的截取操作，最终<code>a = 257 % 256 = 1</code>。</p>
<p>又如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int8_t a &#x3D; -1;</span><br><span class="line">int32_t b &#x3D; a;</span><br><span class="line">printf(&quot;a &#x3D; %x, b &#x3D; %x\n&quot;,a, b);</span><br></pre></td></tr></table></figure>

<p>这就是一个扩展操作，<code>a</code>先被转为<code>int</code>,再被转为<code>unsigned</code>,<code>b</code>的十六进制值等于<code>0xFFFFFFFF</code>。</p>
<p>回到最开始的那个问题，在<code>==</code>运算中，<code>a</code>和<code>b</code>都被隐式地转换成了<code>int</code>型，一个是<code>-113</code>，一个是<code>143</code>,肯定不一样。</p>
<p><code>prinf</code>的参数实际上也是一种赋值转换，因为<code>%02x</code>指定了参数的类型是<code>uint32_t</code>，所以<code>a</code>被隐式地转换为了<code>uint32_t</code>的类型，也即<code>0xfffffff8</code>。</p>
<p>##参考</p>
<hr>
<p><a href="https://zh.wikipedia.org/wiki/%E6%95%B4%E5%9E%8B%E6%8F%90%E5%8D%87">整型提升</a></p>
<p><a href="https://my.oschina.net/Ccx371161810/blog/293941">C的隐式类型转换</a></p>
<p><a href="http://www.embedu.org/Column/5653.html">关于C语言的隐式类型转换</a></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>C 整形提升</title>
    <url>/2020/12/09/Programing%20Language/C/C%20%E6%95%B4%E5%BD%A2%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<p>摘自<a href="https://zh.wikipedia.org/wiki/%E6%95%B4%E5%9E%8B%E6%8F%90%E5%8D%87">维基百科</a>：</p>
<p>整型提升是C程序设计语言中的一项规定：在表达式计算时，各种整形首先要提升为int类型，如果int类型不足以表示则要提升为unsigned int类型；然后执行表达式的运算。[1]</p>
<p>这一规则是由C语言的发明人丹尼斯·里奇与肯·汤普逊创设的：[2]</p>
<blockquote>
<p>A character, a short integer, or an integer bit-field, all either signed or not, or an object of enumeration type, may be used in an expression wherever an integer maybe used. If an int can represent all the values of the original type, then the value is converted to int; otherwise the value is converted to unsigned int. This process is called integral promotion.</p>
</blockquote>
<p>这段话的大意是：表达式中可以使用整数的地方，就可以使用枚举类型，或有符号或无符号的字符、短整数、整数位域。如果一个int可以表示上述类型，则该值被转化为int类型的值；否则，该值被转化为unsigned int类型的值。这一过程被称作integral promotion。</p>
<p>整型提升的意义在于：表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节长度，同时也是CPU的通用寄存器的长度。因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。通用CPU（general-purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令中可能有这种字节相加指令）。所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。</p>
<a id="more"></a>

]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>newlib 中的 crt0 流程分析</title>
    <url>/2020/12/09/Programing%20Language/C/newlib%20%E4%B8%AD%E7%9A%84%20crt0%20%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>最近对 newlib 中的启动代码 crt0 产生了兴趣，于是就分析了下其代码。crt0 的源码位于 libgloss/arm/crt0.S，为了兼容各种 ARM 架构，crt0.S 中有大量的条件判断宏定义，对于只关心 ARMv7e-M 的我来说很是痛苦。刚好手上有个基于 STM32F412 的 mbed 工程用的是 crt0 的启动方式，参考 crt0.o 的反汇编我可以提炼出 crt0.S 中和 ARMv7e-M 相关的部分代码。</p>
<p>crt0.o 的反汇编如下：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">08008220 &lt;_mainCRTStartup&gt;:</span><br><span class="line"> 8008220:    4b15          ldr    r3, [pc, #84]    ; (8008278 &lt;_mainCRTStartup+0x58&gt;)</span><br><span class="line"> 8008222:    2b00          cmp    r3, #0</span><br><span class="line"> 8008224:    bf08          it    eq</span><br><span class="line"> 8008226:    4b13          ldreq    r3, [pc, #76]    ; (8008274 &lt;_mainCRTStartup+0x54&gt;)</span><br><span class="line"> 8008228:    469d          mov    sp, r3</span><br><span class="line"> 800822a:    f5a3 3a80     sub.w    sl, r3, #65536    ; 0x10000</span><br><span class="line"> 800822e:    2100          movs    r1, #0</span><br><span class="line"> 8008230:    468b          mov    fp, r1</span><br><span class="line"> 8008232:    460f          mov    r7, r1</span><br><span class="line"> 8008234:    4813          ldr    r0, [pc, #76]    ; (8008284 &lt;_mainCRTStartup+0x64&gt;)</span><br><span class="line"> 8008236:    4a14          ldr    r2, [pc, #80]    ; (8008288 &lt;_mainCRTStartup+0x68&gt;)</span><br><span class="line"> 8008238:    1a12          subs    r2, r2, r0</span><br><span class="line"> 800823a:    f01c fcd7     bl    8024bec &lt;memset&gt;</span><br><span class="line"> 800823e:    4b0f          ldr    r3, [pc, #60]    ; (800827c &lt;_mainCRTStartup+0x5c&gt;)</span><br><span class="line"> 8008240:    2b00          cmp    r3, #0</span><br><span class="line"> 8008242:    d000          beq.n    8008246 &lt;_mainCRTStartup+0x26&gt;</span><br><span class="line"> 8008244:    4798          blx    r3</span><br><span class="line"> 8008246:    4b0e          ldr    r3, [pc, #56]    ; (8008280 &lt;_mainCRTStartup+0x60&gt;)</span><br><span class="line"> 8008248:    2b00          cmp    r3, #0</span><br><span class="line"> 800824a:    d000          beq.n    800824e &lt;_mainCRTStartup+0x2e&gt;</span><br><span class="line"> 800824c:    4798          blx    r3</span><br><span class="line"> 800824e:    2000          movs    r0, #0</span><br><span class="line"> 8008250:    2100          movs    r1, #0</span><br><span class="line"> 8008252:    0004          movs    r4, r0</span><br><span class="line"> 8008254:    000d          movs    r5, r1</span><br><span class="line"> 8008256:    480d          ldr    r0, [pc, #52]    ; (800828c &lt;_mainCRTStartup+0x6c&gt;)</span><br><span class="line"> 8008258:    2800          cmp    r0, #0</span><br><span class="line"> 800825a:    d002          beq.n    8008262 &lt;_mainCRTStartup+0x42&gt;</span><br><span class="line"> 800825c:    480c          ldr    r0, [pc, #48]    ; (8008290 &lt;_mainCRTStartup+0x70&gt;)</span><br><span class="line"> 800825e:    f00f f868     bl    8017332 &lt;__wrap_atexit&gt;</span><br><span class="line"> 8008262:    f01c f805     bl    8024270 &lt;__libc_init_array&gt;</span><br><span class="line"> 8008266:    0020          movs    r0, r4</span><br><span class="line"> 8008268:    0029          movs    r1, r5</span><br><span class="line"> 800826a:    f00f f821     bl    80172b0 &lt;__wrap_main&gt;</span><br><span class="line"> 800826e:    f00f f85d     bl    801732c &lt;__wrap_exit&gt;</span><br><span class="line"> 8008272:    bf00          nop</span><br><span class="line"> 8008274:    00080000     .word    0x00080000</span><br><span class="line"> 8008278:    20040000     .word    0x20040000</span><br><span class="line"> 800827c:    00000000     .word    0x00000000</span><br><span class="line"> 8008280:    080172a3     .word    0x080172a3</span><br><span class="line"> 8008284:    20000c00     .word    0x20000c00</span><br><span class="line"> 8008288:    2000ac58     .word    0x2000ac58</span><br><span class="line"> 800828c:    08017333     .word    0x08017333</span><br><span class="line"> 8008290:    00000000     .word    0x00000000</span><br></pre></td></tr></table></figure>

<p>提炼后的 crt0.S 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    FUNC_START  _mainCRTStartup</span><br><span class="line">    FUNC_START  _start</span><br><span class="line">&#x2F;* Start by setting up a stack *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;*  Set up the stack pointer to a fixed value *&#x2F;</span><br><span class="line">    &#x2F;*  Changes by toralf:</span><br><span class="line">        - Allow linker script to provide stack via __stack symbol - see</span><br><span class="line">          defintion of .Lstack</span><br><span class="line">        - Provide &quot;hooks&quot; that may be used by the application to add</span><br><span class="line">          custom init code - see .Lhwinit and .Lswinit  </span><br><span class="line">        - Go through all execution modes and set up stack for each of them.</span><br><span class="line">          Loosely based on init.s from ARM&#x2F;Motorola example code.</span><br><span class="line">              Note: Mode switch via CPSR is not allowed once in non-privileged</span><br><span class="line">            mode, so we take care not to enter &quot;User&quot; to set up its sp,</span><br><span class="line">            and also skip most operations if already in that mode. *&#x2F;</span><br><span class="line"></span><br><span class="line">    ldr r3, .Lstack</span><br><span class="line">    cmp r3, #0</span><br><span class="line"></span><br><span class="line">    it  eq</span><br><span class="line"></span><br><span class="line">    ldreq   r3, .LC0</span><br><span class="line">    &#x2F;* Note: This &#39;mov&#39; is essential when starting in User, and ensures we</span><br><span class="line">         always get *some* sp value for the initial mode, even if we </span><br><span class="line">         have somehow missed it below (in which case it gets the same</span><br><span class="line">         value as FIQ - not ideal, but better than nothing.) *&#x2F;</span><br><span class="line">    mov sp, r3</span><br><span class="line"></span><br><span class="line">.LC23:</span><br><span class="line">    &#x2F;* Setup a default stack-limit in-case the code has been</span><br><span class="line">       compiled with &quot;-mapcs-stack-check&quot;.  Hard-wiring this value</span><br><span class="line">       is not ideal, since there is currently no support for</span><br><span class="line">       checking that the heap and stack have not collided, or that</span><br><span class="line">       this default 64k is enough for the program being executed.</span><br><span class="line">       However, it ensures that this simple crt0 world will not</span><br><span class="line">       immediately cause an overflow event:  *&#x2F;</span><br><span class="line">    sub sl, r3, #64 &lt;&lt; 10   &#x2F;* Still assumes 256bytes below sl *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Zero the memory in the .bss section.  *&#x2F;</span><br><span class="line">    movs    a2, #0          &#x2F;* Second arg: fill value *&#x2F;</span><br><span class="line">    mov fp, a2          &#x2F;* Null frame pointer *&#x2F;</span><br><span class="line">    mov r7, a2          &#x2F;* Null frame pointer for Thumb *&#x2F;</span><br><span class="line">    </span><br><span class="line">    ldr a1, .LC1        &#x2F;* First arg: start of memory block *&#x2F;</span><br><span class="line">    ldr a3, .LC2    </span><br><span class="line">    subs    a3, a3, a1      &#x2F;* Third arg: length of block *&#x2F;</span><br><span class="line">    </span><br><span class="line">    bl  memset</span><br><span class="line"></span><br><span class="line">&#x2F;* Changes by toralf: Taken from libgloss&#x2F;m68k&#x2F;crt0.S</span><br><span class="line"> * initialize target specific stuff. Only execute these</span><br><span class="line"> * functions it they exist.</span><br><span class="line"> *&#x2F;</span><br><span class="line">    ldr r3, .Lhwinit</span><br><span class="line">    cmp r3, #0</span><br><span class="line">    beq .LC24</span><br><span class="line">    indirect_call r3</span><br><span class="line">.LC24:  </span><br><span class="line">    ldr r3, .Lswinit</span><br><span class="line">    cmp r3, #0</span><br><span class="line">    beq .LC25</span><br><span class="line">    indirect_call r3</span><br><span class="line"></span><br><span class="line">.LC25:  </span><br><span class="line">    movs    r0, #0      &#x2F;*  no arguments  *&#x2F;</span><br><span class="line">    movs    r1, #0      &#x2F;*  no argv either *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Some arm&#x2F;elf targets use the .init and .fini sections</span><br><span class="line">       to create constructors and destructors, and for these</span><br><span class="line">       targets we need to call the _init function and arrange</span><br><span class="line">       for _fini to be called at program exit.  *&#x2F;</span><br><span class="line">    movs    r4, r0</span><br><span class="line">    movs    r5, r1e</span><br><span class="line"></span><br><span class="line">    &#x2F;* Make reference to atexit weak to avoid unconditionally pulling in</span><br><span class="line">       support code.  Refer to comments in __atexit.c for more details.  *&#x2F;</span><br><span class="line">    ldr r0, .Latexit</span><br><span class="line">    cmp r0, #0</span><br><span class="line">    beq .Lweak_atexit</span><br><span class="line"></span><br><span class="line">    ldr r0, .Lfini</span><br><span class="line">    bl  atexit</span><br><span class="line">.Lweak_atexit:</span><br><span class="line">    bl  _init</span><br><span class="line">    movs    r0, r4</span><br><span class="line">    movs    r1, r5</span><br><span class="line"></span><br><span class="line">    bl  main</span><br><span class="line"></span><br><span class="line">    bl  exit        &#x2F;* Should not return.  *&#x2F;</span><br><span class="line">    </span><br><span class="line">    &#x2F;* For Thumb, constants must be after the code since only </span><br><span class="line">       positive offsets are supported for PC relative addresses.  *&#x2F;</span><br><span class="line">.LC0:</span><br><span class="line">    .word   0x80000         &#x2F;* Top of RAM on the PIE board.  *&#x2F;</span><br><span class="line">.Lstack:    </span><br><span class="line">    .word   __stack</span><br><span class="line">.Lhwinit:   </span><br><span class="line">    .word   ardware_init_hook</span><br><span class="line">.Lswinit:</span><br><span class="line">    .word   software_init_hook</span><br><span class="line"></span><br><span class="line">    &#x2F;* Set up defaults for the above variables in the form of weak symbols</span><br><span class="line">       - so that application will link correctly, and get value 0 in</span><br><span class="line">       runtime (meaning &quot;ignore setting&quot;) for the variables, when the user</span><br><span class="line">       does not provide the symbols. (The linker uses a weak symbol if,</span><br><span class="line">       and only if, a normal version of the same symbol isn&#39;t provided</span><br><span class="line">       e.g. by a linker script or another object file.) *&#x2F;  </span><br><span class="line"></span><br><span class="line">    .weak __stack</span><br><span class="line">    .weak hardware_init_hook</span><br><span class="line">    .weak software_init_hook</span><br><span class="line"></span><br><span class="line">.LC1:</span><br><span class="line">  .word __bss_start__</span><br><span class="line">.LC2:</span><br><span class="line">  .word __bss_end__</span><br><span class="line"></span><br><span class="line">  .weak atexit</span><br><span class="line">.Latexit:</span><br><span class="line">  .word atexit</span><br><span class="line"></span><br><span class="line">  &#x2F;* Weak reference _fini in case of lite exit.  *&#x2F;</span><br><span class="line">  .weak _fini</span><br><span class="line">.Lfini:</span><br><span class="line">  .word _fini</span><br></pre></td></tr></table></figure>

<p>crt0 启动流程如下：</p>
<ol>
<li>设置 SP 为 __stack，若 __stack 未被用户定义，则使用默认的值（0x80000处的值）。</li>
<li>清空 .bss 段，起始地址为 <strong>bss_start__，结束地址为 __bss_end</strong> 。</li>
<li>若用户定义了 hardware_init_hook 和 software_init_hook ，则调用它们。</li>
<li>若用户定义了 atexit，则调用它，并将传递参数 _fini（_fini 被宏定义为 __libc_fini_array）。</li>
<li>调用 _init（_ini 被宏定义为 __libc_ini_array）。</li>
<li>调用 main（argc 和 argv 都等于 0）。</li>
<li>调用 exit。</li>
</ol>
<p>其中 <strong>stack，__bss_start__ 和 __bss_end</strong> 必须被定义。</p>
<p>hardware_init_hook 和 software_init_hook 可以实现一些需要在 main 之前的功能。</p>
<p>aiexit，exit，_init 和 _fini 一般是和 C++ 的全局构造和析构有关，这个放在下一节来分析。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>strtol</title>
    <url>/2020/12/09/Programing%20Language/C/strtol/</url>
    <content><![CDATA[<h2 id="strtol"><a href="#strtol" class="headerlink" title="strtol"></a>strtol</h2><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long int strtol(const char *nptr, char **endptr, int base);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>字符串无法解析，例如出现了非数字字符等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If endptr is not NULL, strtol() stores the address of the first invalid</span><br><span class="line">character  in *endptr.  If there were no digits at all, strtol() stores</span><br><span class="line">the original value of nptr in *endptr (and returns 0).  In  particular,</span><br><span class="line">if  *nptr is not &#39;\0&#39; but **endptr is &#39;\0&#39; on return, the entire string</span><br><span class="line">is valid.</span><br></pre></td></tr></table></figure>
</li>
<li><p>数值越界</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If an  underflow  occurs,  strtol()</span><br><span class="line">returns  LONG_MIN.   If  an overflow occurs, strtol() returns LONG_MAX.</span><br><span class="line">In both cases, errno is set to ERANGE.  Precisely the  same  holds  for</span><br><span class="line">strtoll()  (with  LLONG_MIN  and  LLONG_MAX  instead  of  LONG_MIN  and</span><br><span class="line">LONG_MAX).</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><code>$ man strtol</code> 例程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> base;</span><br><span class="line">    <span class="keyword">char</span> *endptr, *str;</span><br><span class="line">    <span class="keyword">long</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s str [base]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    str = argv[<span class="number">1</span>];</span><br><span class="line">    base = (argc &gt; <span class="number">2</span>) ? atoi(argv[<span class="number">2</span>]) : <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    errno = <span class="number">0</span>; <span class="comment">/* To distinguish success/failure after call */</span></span><br><span class="line">    val = strtol(str, &amp;endptr, base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for various possible errors */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((errno == ERANGE &amp;&amp; (val == LONG_MAX || val == LONG_MIN)) || (errno != <span class="number">0</span> &amp;&amp; val == <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;strtol&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (endptr == str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;No digits were found\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we got here, strtol() successfully parsed a number */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strtol() returned %ld\n&quot;</span>, val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*endptr != <span class="string">&#x27;\0&#x27;</span>) <span class="comment">/* Not necessarily an error... */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Further characters after number: %s\n&quot;</span>, endptr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>Mermaid 画图</title>
    <url>/2020/12/09/Programing%20Language/Markdown/Mermaid%20%E7%94%BB%E5%9B%BE/</url>
    <content><![CDATA[<p><a href="https://mermaid-js.github.io/mermaid/#/">Mermaid</a>（美人鱼）通过代码来表示画图。</p>
<a id="more"></a>

]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>Python Static variable</title>
    <url>/2020/12/09/Programing%20Language/Python/Python%20Static%20variable/</url>
    <content><![CDATA[<h2 id="How-to-declare-a-static-variable-in-a-function-in-Python"><a href="#How-to-declare-a-static-variable-in-a-function-in-Python" class="headerlink" title="How to declare a static variable in a function in Python"></a>How to declare a static variable in a function in Python</h2><p>Use a variable <code>func.var</code>, where <code>func</code> is the name of the function and <code>var</code> is the name of a variable as a static variable in <code>func</code>. Either initialize the variable outside of the function or in the function, call <a href="https://kite.com/python/docs/builtins.hasattr"><code>hasattr(fun, var)</code></a> to test if <code>func.var</code> has been initialized. If it has not, initialize it to the appropriate value, otherwise continue with the function.</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span>():</span></span><br><span class="line">    myfunc.counter += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> myfunc.counter</span><br><span class="line"></span><br><span class="line">myfunc.counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">count1 = myfunc()</span><br><span class="line">print(count1)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def myfunc():</span><br><span class="line">    if not hasattr(myfunc, &quot;counter&quot;):</span><br><span class="line">         myfunc.counter &#x3D; 0</span><br><span class="line">    myfunc.counter +&#x3D; 1</span><br><span class="line">    return myfunc.counter</span><br><span class="line"></span><br><span class="line">count1 &#x3D; myfunc()</span><br><span class="line">print(count1)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Python Primer</title>
    <url>/2020/12/09/Programing%20Language/Python/Python%20Primer/</url>
    <content><![CDATA[<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="安全的访问-dict-中的-key"><a href="#安全的访问-dict-中的-key" class="headerlink" title="安全的访问 dict 中的 key"></a>安全的访问 dict 中的 key</h3><p>如果key不存在，访问 dict就会报错：</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Thomas&#x27;</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">&#x27;Thomas&#x27;</span></span><br></pre></td></tr></table></figure>

<p>要避免key不存在的错误，有两种办法，一是通过<code>in</code>判断key是否存在：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Thomas&#x27;</span> <span class="keyword">in</span> d</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>二是通过dict提供的<code>get()</code>方法，如果key不存在，可以返回<code>None</code>，或者自己指定的value：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">&#x27;Thomas&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">&#x27;Thomas&#x27;</span>, -<span class="number">1</span>)</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>注意：返回<code>None</code>的时候Python的交互环境不显示结果。</p>
<h3 id="删除-key"><a href="#删除-key" class="headerlink" title="删除 key"></a>删除 key</h3><p>要删除一个key，用<code>pop(key)</code>方法，对应的value也会从dict中删除：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop(<span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line"><span class="number">75</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">&#x27;Michael&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;Tracy&#x27;</span>: <span class="number">85</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="List-和-Dict-的对比"><a href="#List-和-Dict-的对比" class="headerlink" title="List 和 Dict 的对比"></a>List 和 Dict 的对比</h3><p>和list比较，dict有以下几个特点：</p>
<ul>
<li>查找和插入的速度极快，不会随着key的增加而变慢；</li>
<li>需要占用大量的内存，内存浪费多。</li>
</ul>
<p>而list相反：</p>
<ul>
<li>查找和插入的时间随着元素的增加而增加；</li>
<li>占用空间小，浪费内存很少。</li>
</ul>
<p>所以，dict是用空间来换取时间的一种方法。</p>
<p>dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是<strong>不可变对象</strong>。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p>
<p>重复元素在set中自动被过滤：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>add(key)</code>方法可以添加元素到set中，可以重复添加，但不会有效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>remove(key)</code>方法可以删除元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="built_in">set</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 &amp; s2</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 | s2</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p><code>L[0:3]</code>表示，从索引<code>0</code>开始取，直到索引<code>3</code>为止，但不包括索引<code>3</code>。即索引<code>0</code>，<code>1</code>，<code>2</code>，正好是3个元素。</p>
<p>记住倒数第一个元素的索引是<code>-1</code>。</p>
<p>切片操作十分有用。我们先创建一个0-99的数列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">100</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ..., <span class="number">99</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>前10个数：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">10</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>后10个数：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[-<span class="number">10</span>:]</span><br><span class="line">[<span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>前11-20个数：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">10</span>:<span class="number">20</span>]</span><br><span class="line">[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>前10个数，每2个取1个：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">10</span>:<span class="number">2</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>所有数，每5个取1个：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[::<span class="number">5</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">55</span>, <span class="number">60</span>, <span class="number">65</span>, <span class="number">70</span>, <span class="number">75</span>, <span class="number">80</span>, <span class="number">85</span>, <span class="number">90</span>, <span class="number">95</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>原样复制一个list：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[:]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ..., <span class="number">99</span>]</span><br></pre></td></tr></table></figure>

<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>默认情况下，dict迭代的是key。如果要迭代value，可以用<code>for value in d.values()</code>，如果要同时迭代key和value，可以用<code>for k, v in d.items()</code>。</p>
<p>Python内置的<code>enumerate</code>函数可以把一个list变成索引-元素对，这样就可以在<code>for</code>循环中同时迭代索引和元素本身：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]):</span><br><span class="line"><span class="meta">... </span>    print(i, value)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> A</span><br><span class="line"><span class="number">1</span> B</span><br><span class="line"><span class="number">2</span> C</span><br></pre></td></tr></table></figure>

<h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p>如果要生成<code>[1x1, 2x2, 3x3, ..., 10x10]</code>怎么做？方法一是循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line"><span class="meta">... </span>   L.append(x * x)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<p>写列表生成式时，把要生成的元素<code>x * x</code>放到前面，后面跟<code>for</code>循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。</p>
<p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<p>还可以使用两层循环，可以生成全排列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">&#x27;XYZ&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;AX&#x27;</span>, <span class="string">&#x27;AY&#x27;</span>, <span class="string">&#x27;AZ&#x27;</span>, <span class="string">&#x27;BX&#x27;</span>, <span class="string">&#x27;BY&#x27;</span>, <span class="string">&#x27;BZ&#x27;</span>, <span class="string">&#x27;CX&#x27;</span>, <span class="string">&#x27;CY&#x27;</span>, <span class="string">&#x27;CZ&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">now</span>():</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">&#x27;2015-3-25&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = now</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()</span><br><span class="line"><span class="number">2015</span>-<span class="number">3</span>-<span class="number">25</span></span><br></pre></td></tr></table></figure>

<p>现在，假设我们要增强<code>now()</code>函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改<code>now()</code>函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。</p>
<p>本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call %s():&#x27;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<p>观察上面的<code>log</code>，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;2015-3-25&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>调用<code>now()</code>函数，不仅会运行<code>now()</code>函数本身，还会在运行<code>now()</code>函数前打印一行日志：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>now()</span><br><span class="line">call now():</span><br><span class="line"><span class="number">2015</span>-<span class="number">3</span>-<span class="number">25</span></span><br></pre></td></tr></table></figure>

<p>把<code>@log</code>放到<code>now()</code>函数的定义处，相当于执行了语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">now = log(now)</span><br></pre></td></tr></table></figure>

<p>由于<code>log()</code>是一个decorator，返回一个函数，所以，原来的<code>now()</code>函数仍然存在，只是现在同名的<code>now</code>变量指向了新的函数，于是调用<code>now()</code>将执行新函数，即在<code>log()</code>函数中返回的<code>wrapper()</code>函数。</p>
<p><code>wrapper()</code>函数的参数定义是<code>(*args, **kw)</code>，因此，<code>wrapper()</code>函数可以接受任意参数的调用。在<code>wrapper()</code>函数内，首先打印日志，再紧接着调用原始函数。</p>
<h2 id="使用-propery"><a href="#使用-propery" class="headerlink" title="使用 @propery"></a>使用 @propery</h2><p>在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = Student()</span><br><span class="line">s.score = <span class="number">9999</span></span><br></pre></td></tr></table></figure>

<p>这显然不合逻辑。为了限制score的范围，可以通过一个<code>set_score()</code>方法来设置成绩，再通过一个<code>get_score()</code>来获取成绩，这样，在<code>set_score()</code>方法里，就可以检查参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_score</span>(<span class="params">self</span>):</span></span><br><span class="line">         <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_score</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must be an integer!&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must between 0 ~ 100!&#x27;</span>)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure>

<p>现在，对任意的Student实例进行操作，就不能随心所欲地设置score了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_score(<span class="number">60</span>) <span class="comment"># ok!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.get_score()</span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_score(<span class="number">9999</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between <span class="number">0</span> ~ <span class="number">100</span>!</span><br></pre></td></tr></table></figure>

<p>但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。</p>
<p>有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？对于追求完美的Python程序员来说，这是必须要做到的！</p>
<p>还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。</p>
<p>Python内置的<code>@property</code>装饰器就是负责把一个方法变成属性调用的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must be an integer!&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must between 0 ~ 100!&#x27;</span>)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure>

<p><code>@property</code>的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上<code>@property</code>就可以了，此时，<code>@property</code>本身又创建了另一个装饰器<code>@score.setter</code>，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">60</span> <span class="comment"># OK，实际转化为s.set_score(60)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score <span class="comment"># OK，实际转化为s.get_score()</span></span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">9999</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between <span class="number">0</span> ~ <span class="number">100</span>!</span><br></pre></td></tr></table></figure>

<p>注意到这个神奇的<code>@property</code>，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。</p>
<p>还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">birth</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._birth</span><br><span class="line"></span><br><span class="line"><span class="meta">    @birth.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">birth</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self._birth = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2015</span> - self._birth</span><br></pre></td></tr></table></figure>

<p>上面的<code>birth</code>是可读写属性，而<code>age</code>就是一个<em>只读</em>属性，因为<code>age</code>可以根据<code>birth</code>和当前时间计算出来。</p>
<h2 id="使用枚举类"><a href="#使用枚举类" class="headerlink" title="使用枚举类"></a>使用枚举类</h2><p>当我们需要定义常量时，一个办法是用大写变量通过整数来定义，例如月份：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">JAN = <span class="number">1</span></span><br><span class="line">FEB = <span class="number">2</span></span><br><span class="line">MAR = <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">NOV = <span class="number">11</span></span><br><span class="line">DEC = <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>好处是简单，缺点是类型是<code>int</code>，并且仍然是变量。</p>
<p>更好的方法是为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了<code>Enum</code>类来实现这个功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line">Month = Enum(<span class="string">&#x27;Month&#x27;</span>, (<span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Feb&#x27;</span>, <span class="string">&#x27;Mar&#x27;</span>, <span class="string">&#x27;Apr&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;Jun&#x27;</span>, <span class="string">&#x27;Jul&#x27;</span>, <span class="string">&#x27;Aug&#x27;</span>, <span class="string">&#x27;Sep&#x27;</span>, <span class="string">&#x27;Oct&#x27;</span>, <span class="string">&#x27;Nov&#x27;</span>, <span class="string">&#x27;Dec&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>这样我们就获得了<code>Month</code>类型的枚举类，可以直接使用<code>Month.Jan</code>来引用一个常量，或者枚举它的所有成员：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name, member <span class="keyword">in</span> Month.__members__.items():</span><br><span class="line">    print(name, <span class="string">&#x27;=&gt;&#x27;</span>, member, <span class="string">&#x27;,&#x27;</span>, member.value)</span><br></pre></td></tr></table></figure>

<p><code>value</code>属性则是自动赋给成员的<code>int</code>常量，默认从<code>1</code>开始计数。</p>
<p>如果需要更精确地控制枚举类型，可以从<code>Enum</code>派生出自定义类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</span><br><span class="line"></span><br><span class="line"><span class="meta">@unique</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weekday</span>(<span class="params">Enum</span>):</span></span><br><span class="line">    Sun = <span class="number">0</span> <span class="comment"># Sun的value被设定为0</span></span><br><span class="line">    Mon = <span class="number">1</span></span><br><span class="line">    Tue = <span class="number">2</span></span><br><span class="line">    Wed = <span class="number">3</span></span><br><span class="line">    Thu = <span class="number">4</span></span><br><span class="line">    Fri = <span class="number">5</span></span><br><span class="line">    Sat = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><code>@unique</code>装饰器可以帮助我们检查保证没有重复值。</p>
<p>访问这些枚举类型可以有若干种方法：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>day1 = Weekday.Mon</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(day1)</span><br><span class="line">Weekday.Mon</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Weekday.Tue)</span><br><span class="line">Weekday.Tue</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Weekday[<span class="string">&#x27;Tue&#x27;</span>])</span><br><span class="line">Weekday.Tue</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Weekday.Tue.value)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(day1 == Weekday.Mon)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(day1 == Weekday.Tue)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Weekday(<span class="number">1</span>))</span><br><span class="line">Weekday.Mon</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(day1 == Weekday(<span class="number">1</span>))</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Weekday(<span class="number">7</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: <span class="number">7</span> <span class="keyword">is</span> <span class="keyword">not</span> a valid Weekday</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, member <span class="keyword">in</span> Weekday.__members__.items():</span><br><span class="line"><span class="meta">... </span>    print(name, <span class="string">&#x27;=&gt;&#x27;</span>, member)</span><br><span class="line">...</span><br><span class="line">Sun =&gt; Weekday.Sun</span><br><span class="line">Mon =&gt; Weekday.Mon</span><br><span class="line">Tue =&gt; Weekday.Tue</span><br><span class="line">Wed =&gt; Weekday.Wed</span><br><span class="line">Thu =&gt; Weekday.Thu</span><br><span class="line">Fri =&gt; Weekday.Fri</span><br><span class="line">Sat =&gt; Weekday.Sat</span><br></pre></td></tr></table></figure>

<p>可见，既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>pypi 镜像使用帮助</title>
    <url>/2020/12/09/Programing%20Language/Python/pypi%20%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9/</url>
    <content><![CDATA[<h2 id="清华大学开源软件镜像站"><a href="#清华大学开源软件镜像站" class="headerlink" title="清华大学开源软件镜像站"></a>清华大学开源软件镜像站</h2><p>pypi 镜像每 5 分钟同步一次。</p>
<h3 id="临时使用"><a href="#临时使用" class="headerlink" title="临时使用"></a>临时使用</h3><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple some-package</span><br></pre></td></tr></table></figure>

<p>注意，<code>simple</code> 不能少, 是 <code>https</code> 而不是 <code>http</code></p>
<h3 id="设为默认"><a href="#设为默认" class="headerlink" title="设为默认"></a>设为默认</h3><p>升级 pip 到最新的版本 (&gt;=10.0.0) 后进行配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pip -U</span><br><span class="line">pip config set global.index-url https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br></pre></td></tr></table></figure>

<p>如果您到 pip 默认源的网络连接较差，临时使用本镜像站来升级 pip：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple pip -U</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/">https://mirrors.tuna.tsinghua.edu.cn/help/pypi/</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>大大提升终端体验的好工具：Rich</title>
    <url>/2020/12/09/Programing%20Language/Python/%E5%A4%A7%E5%A4%A7%E6%8F%90%E5%8D%87%E7%BB%88%E7%AB%AF%E4%BD%93%E9%AA%8C%E7%9A%84%E5%A5%BD%E5%B7%A5%E5%85%B7%EF%BC%9ARich/</url>
    <content><![CDATA[<p>导语：Rich 是一个可以在终端中提供富文本和精美格式的 Python 库。支持中文，终端爱好者可以试一下。</p>
<p><strong>简介</strong></p>
<p>今天给大家介绍的 Rich ，已经连续两天登上 GitHub 日榜，在 GitHub 快拿下 1.5 万 Star。它的开发者是国外开发小哥 Will McGugan。</p>
<p>Rich 的 API 相当丰富，可以很轻松地给终端输出添加各种颜色和不同风格。</p>
<p>它还可以绘制漂亮的表格、进度条、markdown、代码高亮等。</p>
<p><strong>项目主页</strong></p>
<p><a href="https://github.com/willmcgugan/rich">https://github.com/willmcgugan/rich</a></p>
<p><strong>功能一览</strong></p>
<a id="more"></a>

<p><img src="/2020/12/09/Programing%20Language/Python/%E5%A4%A7%E5%A4%A7%E6%8F%90%E5%8D%87%E7%BB%88%E7%AB%AF%E4%BD%93%E9%AA%8C%E7%9A%84%E5%A5%BD%E5%B7%A5%E5%85%B7%EF%BC%9ARich/640-20201203235229689.png" alt="img"></p>
<p><em>（点击看大图）</em></p>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>Rich 支持三大平台 Linux、OSX 和 Windows。真彩色/表情符号可与新的 Windows 终端一起使用，Windows 的经典终端仅限 8 种颜色。</p>
<p>Rich 要求 Python 版本最低 v 3.6.1。可以与Jupyter 笔记本一起使用，而无需其他配置。</p>
<h2 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a>安装说明</h2><p>使用<code>pip</code>或其他 PyPi 软件包管理器进行安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install rich</span><br></pre></td></tr></table></figure>

<h2 id="Rich-的打印功能"><a href="#Rich-的打印功能" class="headerlink" title="Rich 的打印功能"></a>Rich 的打印功能</h2><p>只需导入 rich 打印方法，就可以想毫不费力地把 Rich 的输出功能添加到应用程序中。该方法和其他 Python 的自带功能的参数类似。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rich import print</span><br><span class="line"></span><br><span class="line">print(&quot;Hello, [bold magenta]World[&#x2F;bold magenta]!&quot;, &quot;:vampire:&quot;, locals())</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/09/Programing%20Language/Python/%E5%A4%A7%E5%A4%A7%E6%8F%90%E5%8D%87%E7%BB%88%E7%AB%AF%E4%BD%93%E9%AA%8C%E7%9A%84%E5%A5%BD%E5%B7%A5%E5%85%B7%EF%BC%9ARich/640-20201203235229589.png" alt="img"></p>
<h2 id="使用控制台"><a href="#使用控制台" class="headerlink" title="使用控制台"></a>使用控制台</h2><p>想要对 Rich 终端内容进行更多控制，直接导入并构造一个控制台对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rich.console import Console</span><br><span class="line"></span><br><span class="line">console &#x3D; Console()</span><br></pre></td></tr></table></figure>

<p>Console 对象含有一个<code>print</code> 方法，其界面与 python 内置的<code>print</code>功能界面相似。</p>
<p>您可以试试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.print(&quot;Hello&quot;, &quot;World!&quot;)</span><br></pre></td></tr></table></figure>

<p>这时终端上会显示“ Hello World！”。</p>
<p><em>请注意，与内置的“打印”功能不同，Rich 会将文字自动换行以适合终端宽度。</em></p>
<p>有几种方法可以为输出添加颜色和样式。添加<code>style</code>关键字参数来为整个输出设置样式。例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.print(&quot;Hello&quot;, &quot;World!&quot;, style&#x3D;&quot;bold red&quot;)</span><br></pre></td></tr></table></figure>

<p>输出如下图：<img src="/2020/12/09/Programing%20Language/Python/%E5%A4%A7%E5%A4%A7%E6%8F%90%E5%8D%87%E7%BB%88%E7%AB%AF%E4%BD%93%E9%AA%8C%E7%9A%84%E5%A5%BD%E5%B7%A5%E5%85%B7%EF%BC%9ARich/640-20201203235229579.png" alt="img"></p>
<h2 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h2><p>将名称放在两个冒号之间，即可在控制台输出中插入表情符号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; console.print(&quot;:smiley: :vampire: :pile_of_poo: :thumbs_up: :raccoon:&quot;)</span><br><span class="line">😃 🧛 💩 👍 🦝</span><br></pre></td></tr></table></figure>

<p><em>注：Rich 的开发者提醒这个功能慎用。</em></p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>Rich 可以使用 Unicode 框字符来呈现多变的表格。Rich 包含多种边框、样式、单元格对齐等格式设置的选项。</p>
<p>请看下面示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rich.console import Console</span><br><span class="line">from rich.table import Column, Table</span><br><span class="line"></span><br><span class="line">console &#x3D; Console()</span><br><span class="line"></span><br><span class="line">table &#x3D; Table(show_header&#x3D;True, header_style&#x3D;&quot;bold magenta&quot;)</span><br><span class="line">table.add_column(&quot;Date&quot;, style&#x3D;&quot;dim&quot;, width&#x3D;12)</span><br><span class="line">table.add_column(&quot;Title&quot;)</span><br><span class="line">table.add_column(&quot;Production Budget&quot;, justify&#x3D;&quot;right&quot;)</span><br><span class="line">table.add_column(&quot;Box Office&quot;, justify&#x3D;&quot;right&quot;)</span><br><span class="line">table.add_row(</span><br><span class="line">    &quot;Dev 20, 2019&quot;, &quot;Star Wars: The Rise of Skywalker&quot;, &quot;$275,000,000&quot;, &quot;$375,126,118&quot;</span><br><span class="line">)</span><br><span class="line">table.add_row(</span><br><span class="line">    &quot;May 25, 2018&quot;,</span><br><span class="line">    &quot;[red]Solo[&#x2F;red]: A Star Wars Story&quot;,</span><br><span class="line">    &quot;$275,000,000&quot;,</span><br><span class="line">    &quot;$393,151,347&quot;,</span><br><span class="line">)</span><br><span class="line">table.add_row(</span><br><span class="line">    &quot;Dec 15, 2017&quot;,</span><br><span class="line">    &quot;Star Wars Ep. VIII: The Last Jedi&quot;,</span><br><span class="line">    &quot;$262,000,000&quot;,</span><br><span class="line">    &quot;[bold]$1,332,539,889[&#x2F;bold]&quot;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">console.print(table)</span><br></pre></td></tr></table></figure>

<p>示例输出如下：</p>
<p><img src="/2020/12/09/Programing%20Language/Python/%E5%A4%A7%E5%A4%A7%E6%8F%90%E5%8D%87%E7%BB%88%E7%AB%AF%E4%BD%93%E9%AA%8C%E7%9A%84%E5%A5%BD%E5%B7%A5%E5%85%B7%EF%BC%9ARich/640.png" alt="img"></p>
<h2 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h2><p>Rich 可以渲染多个不闪烁的进度条形图，用来跟踪长时间运行的任务。</p>
<p>使用用法：用<code>track</code>函数调用任何程序并迭代结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rich.progress import track</span><br><span class="line"></span><br><span class="line">for step in track(range(100)):</span><br><span class="line">    do_step(step)</span><br></pre></td></tr></table></figure>

<p>还支持添加多个进度条。</p>
<p><img src="/2020/12/09/Programing%20Language/Python/%E5%A4%A7%E5%A4%A7%E6%8F%90%E5%8D%87%E7%BB%88%E7%AB%AF%E4%BD%93%E9%AA%8C%E7%9A%84%E5%A5%BD%E5%B7%A5%E5%85%B7%EF%BC%9ARich/640.gif" alt="img"></p>
<h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><p>Rich 可以呈现 markdown，并可相当不错的将其格式转移到终端。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rich.console import Console</span><br><span class="line">from rich.markdown import Markdown</span><br><span class="line"></span><br><span class="line">console &#x3D; Console()</span><br><span class="line">with open(&quot;README.md&quot;) as readme:</span><br><span class="line">    markdown &#x3D; Markdown(readme.read())</span><br><span class="line">console.print(markdown)</span><br></pre></td></tr></table></figure>

<p>样例输出如下图：</p>
<p><img src="/2020/12/09/Programing%20Language/Python/%E5%A4%A7%E5%A4%A7%E6%8F%90%E5%8D%87%E7%BB%88%E7%AB%AF%E4%BD%93%E9%AA%8C%E7%9A%84%E5%A5%BD%E5%B7%A5%E5%85%B7%EF%BC%9ARich/640-20201203235229637.png" alt="img"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Rich 简单介绍就到这里了，喜欢的童鞋还可以看一下视频介绍，请见：<a href="https://calmcode.io/rich/introduction.html">https://calmcode.io/rich/introduction.html</a></p>
<p>更详细介绍，请见项目主页：<a href="https://github.com/willmcgugan/rich">https://github.com/willmcgugan/rich</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>OpenSSL</title>
    <url>/2020/12/09/Security/TLS/OpenSSL/</url>
    <content><![CDATA[<h2 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h2><p>OpenSSL 是个<code>实现了 TLS 协议</code>的开源的商业级的<code>开发套件</code>。</p>
<p>OpenSSL toolkit 包含：</p>
<ul>
<li>TLS 协议</li>
<li>加密算法库</li>
<li>命令行工具</li>
</ul>
<h2 id="下载，编译和安装"><a href="#下载，编译和安装" class="headerlink" title="下载，编译和安装"></a>下载，编译和安装</h2><p>OpenSSL 官网：<a href="https://www.openssl.org/">https://www.openssl.org</a></p>
<h4 id="下载："><a href="#下载：" class="headerlink" title="下载："></a>下载：</h4><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone git:&#x2F;&#x2F;git.openssl.org&#x2F;openssl.git</span><br></pre></td></tr></table></figure>

<h4 id="编译和安装："><a href="#编译和安装：" class="headerlink" title="编译和安装："></a>编译和安装：</h4><p>参考源码下的：README, INSTALL。</p>
<p><strong>OS X[^1]</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;config</span><br><span class="line">$ make</span><br><span class="line">$ make test</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure>

<p>[^1]: OS X 下安装需要 root 权限</p>
]]></content>
      <categories>
        <category>TLS</category>
      </categories>
  </entry>
  <entry>
    <title>Ruby Install</title>
    <url>/2020/12/09/Programing%20Language/Ruby/Ruby%20Install/</url>
    <content><![CDATA[<h2 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h2><p>macOS 自带 ruby，但是千万不要用，因为自带的 ruby 是给系统用，搞乱了会出问题。</p>
<p>所以需要自己另外安装：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install ruby</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brew reinstall ruby</span><br><span class="line">&#x3D;&#x3D;&gt; Reinstalling ruby </span><br><span class="line">&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;homebrew-bottles&#x2F;bottles&#x2F;ru</span><br><span class="line">Already downloaded: &#x2F;Users&#x2F;snowyang&#x2F;Library&#x2F;Caches&#x2F;Homebrew&#x2F;downloads&#x2F;ce913df96139a56c9bc1ad301492f882a83f160400516538c5d4737f6c6d5e51--ruby-2.7.0.high_sierra.bottle.tar.gz</span><br><span class="line">&#x3D;&#x3D;&gt; Pouring ruby-2.7.0.high_sierra.bottle.tar.gz</span><br><span class="line">&#x3D;&#x3D;&gt; Caveats</span><br><span class="line">By default, binaries installed by gem will be placed into:</span><br><span class="line">  &#x2F;usr&#x2F;local&#x2F;lib&#x2F;ruby&#x2F;gems&#x2F;2.7.0&#x2F;bin</span><br><span class="line"></span><br><span class="line">You may want to add this to your PATH.</span><br><span class="line"></span><br><span class="line">ruby is keg-only, which means it was not symlinked into &#x2F;usr&#x2F;local,</span><br><span class="line">because macOS already provides this software and installing another version in</span><br><span class="line">parallel can cause all kinds of trouble.</span><br><span class="line"></span><br><span class="line">If you need to have ruby first in your PATH run:</span><br><span class="line">  echo &#39;export PATH&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;ruby&#x2F;bin:$PATH&quot;&#39; &gt;&gt; ~&#x2F;.bash_profile</span><br><span class="line"></span><br><span class="line">For compilers to find ruby you may need to set:</span><br><span class="line">  export LDFLAGS&#x3D;&quot;-L&#x2F;usr&#x2F;local&#x2F;opt&#x2F;ruby&#x2F;lib&quot;</span><br><span class="line">  export CPPFLAGS&#x3D;&quot;-I&#x2F;usr&#x2F;local&#x2F;opt&#x2F;ruby&#x2F;include&quot;</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; Summary</span><br><span class="line">🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;ruby&#x2F;2.7.0: 20,346 files, 32.8MB</span><br></pre></td></tr></table></figure>

<p>添加到 PATH 中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;ruby&#x2F;bin:$PATH&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Ruby</category>
      </categories>
  </entry>
  <entry>
    <title>TLS 学习</title>
    <url>/2020/12/09/Security/TLS/TLS%20%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="初次了解："><a href="#初次了解：" class="headerlink" title="初次了解："></a>初次了解：</h2><p><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">SSL/TLS协议运行机制的概述</a> - ==强烈推荐==<br><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">图解SSL/TLS协议</a></p>
<h2 id="进一步了解SSL-handshake的过程和细节："><a href="#进一步了解SSL-handshake的过程和细节：" class="headerlink" title="进一步了解SSL handshake的过程和细节："></a>进一步了解SSL handshake的过程和细节：</h2><p><a href="http://www.cnblogs.com/piyeyong/archive/2010/07/02/1770208.html">证书的应用之一 —— TCP&amp;SSL通信实例及协议分析(中)</a><br><a href="http://www.cnblogs.com/afarmer/archive/2009/11/25/1610884.html">SSL握手协议</a></p>
<h2 id="有关数字证书知识："><a href="#有关数字证书知识：" class="headerlink" title="有关数字证书知识："></a>有关数字证书知识：</h2><p><a href="http://www.linuxde.net/2012/03/8301.html">SSL 与 数字证书 的基本概念和工作原理</a> - ==强烈推荐==<br><a href="http://www.cnblogs.com/guogangj/p/4118605.html">那些证书相关的玩意儿(SSL,X.509,PEM,DER,CRT,CER,KEY,CSR,P12等)</a><br><a href="http://www.cnblogs.com/aLittleBitCool/archive/2011/09/22/2185418.html">利用openssl进行RSA加密解密</a></p>
<h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a href="https://tools.ietf.org/html/rfc5246#page-37">RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2</a></p>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><a id="more"></a>

<h3 id="网络风险"><a href="#网络风险" class="headerlink" title="网络风险"></a>网络风险</h3><p>不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。</p>
<blockquote>
<p>（1） <strong>窃听风险</strong>（eavesdropping）：第三方可以获知通信内容。</p>
<p>（2） <strong>篡改风险</strong>（tampering）：第三方可以修改通信内容。</p>
<p>（3） <strong>冒充风险</strong>（pretending）：第三方可以冒充他人身份参与通信。</p>
</blockquote>
<p>SSL/TLS协议是为了解决这三大风险而设计的，希望达到：</p>
<blockquote>
<p>（1） 所有信息都是<strong>加密传播</strong>，第三方无法窃听。</p>
<p>（2） 具有<strong>校验机制</strong>，一旦被篡改，通信双方会立刻发现。</p>
<p>（3） 配备<strong>身份证书</strong>（包含数字签名），防止身份被冒充。</p>
</blockquote>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>通过私钥可以计算出公钥，反之则不行。<br>公钥加密：公钥加密的内容可以用私钥来解密——只有私钥持有者才能解密。<br>私钥签名：私钥签名的内容可以用公钥验证。公钥能验证的签名均可视为私钥持有人所签署。</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>签名方对一段明文使用私钥加密，并把密文（称为<code>数字签名</code>）附在明文后。验证方使用签名方的公钥把数字签名解密出来，如果和明文相同，就可以确定这段明文是签名方认证的。</p>
<p>考虑到非对称加密非常耗时，所以通常把明文的 hash 值用私钥加密作为数字签名。</p>
<p>数字签名的作用是对一段明文进行认证，本质是这段明文的密文。</p>
<h3 id="RSA-和-ECDSA-的区别"><a href="#RSA-和-ECDSA-的区别" class="headerlink" title="RSA 和 ECDSA 的区别"></a>RSA 和 ECDSA 的区别</h3><p><a href="http://zhiqiang.org/blog/it/das-and-ecdsa-rsa.html">签名算法DSA和ECDSA﻿﻿</a></p>
<blockquote>
<p>比特币协议里使用了ECDSA（椭圆曲线签名算法），我之前以为它和基于大数分解的RSA公钥密码体系差不多。这两天看了下维基百科，才发现它们之间的差异挺大。最本质的区别是，DSA和ECDSA都只是签名算法，它用来确保信息发布人的身份和信息的完整性，不能用来做加密传输，为了实现这个功能，信息的原文（或者<a href="http://zhiqiang.org/blog/science/computer-science/preliminary-computer-theory-xiao-yun-wang-from-the-hash-function-to-crack-md5.html">HASH摘要</a>）必须随着签名一起传输和公布才能被验证。而RSA是公钥加密体系，它可以用来加密传输（即信息原文在传输中加密，到达对方后解密），它也可以实现签名验证。</p>
<p>DSA和ECSDA的基本架构和RSA一样，签名者持有私钥，对应公钥向全世界公开。当需要对信息签名时，签名者用私钥对信息签名，然后将签名信息和信息原文发给对方（RSA协议中，信息原文不需要发给对方，签名信息解密后就是信息原文），验证者可用签名者公开的公钥对签名信息和信息原文验证签名。由于信息长度可能比较长，在实际操作中，大家通常在信息的HASH摘要上进行签名。</p>
</blockquote>
<p>RSA 可以使用<code>公钥</code>由<code>密文</code>解出明文，而 ECDSA 不能，它只能通过<code>公钥</code>，<code>密文</code>和<code>明文</code>来验证此密文是否是私钥加密的，所以 ECDSA 是个纯粹的签名算法。</p>
<p><a href="http://blog.csdn.net/jiangwlee/article/details/11817579">用Openssl计算ECDSA签名</a></p>
<blockquote>
<p>ECDSA的全名是Elliptic Curve DSA，即椭圆曲线DSA。它是Digital Signature Algorithm (DSA)应用了椭圆曲线加密算法的变种。椭圆曲线算法的原理很复杂，但是具有很好的公开密钥算法特性，通过公钥无法逆向获得私钥。</p>
<p><strong>第一部分 ： DSA的签名和验证过程</strong></p>
<p>要了解ECDSA，首先要了解DSA签名的过程和验证过程。为了理解的方便，这里省去诸多DSA算法的细节，仅就重要的几个点进行讨论。</p>
<ol>
<li>签名过程</li>
</ol>
<p>​    假设要签名的消息是一个字符串：“Hello World!”。DSA签名的第一个步骤是对待签名的消息生成一个消息摘要。不同的签名算法使用不同的消息摘要算法。比如，DSS使用SHA1来生成160比特的摘要，而ECDSA256使用SHA256生成256比特的摘要。</p>
<p>​        摘要生成结束后，应用签名算法对摘要进行签名：</p>
<p>​    1. 产生一个随机数k</p>
<p>​    2. 利用随机数k，计算出两个大数r和s。将r和s拼在一起就构成了对消息摘要的签名。</p>
<p>这里需要注意的是，因为随机数k的存在，对于同一条消息，使用同一个算法，产生的签名是不一样的。从函数的角度来理解，签名函数对同样的输入会产生不同的输出。因为函数内部会将随机值混入签名的过程。</p>
<ol start="2">
<li>验证过程</li>
</ol>
<p>​    关于验证过程，这里不讨论它的算法细节。从宏观上看，消息的接收方从签名中分离出r和s，然后利用公开的密钥信息和s计算出r。如果计算出的r和接收到的r值相同，则表示验证成功。否则，表示验证失败。</p>
</blockquote>
<h3 id="创建和查看证书"><a href="#创建和查看证书" class="headerlink" title="创建和查看证书"></a>创建和查看证书</h3><p><strong>创建根私钥和根证书</strong></p>
<p>根私钥就是所谓的 Certificate Authority (CA) 机构用来签名服务器证书的私钥，根证书就是客户端用来验证服务器证书的证书。</p>
<p>Generate root private key：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out ca.key 2048</span><br></pre></td></tr></table></figure>

<p>Generate self-signed<a href="%E5%9B%A0%E4%B8%BA%E6%A0%B9%E8%AF%81%E4%B9%A6%E6%B2%A1%E6%9C%89%E4%B8%8A%E7%BA%A7%E4%BA%86%EF%BC%8C%E6%89%80%E4%BB%A5%E5%8F%AA%E8%83%BD%E8%87%AA%E5%B7%B1%E7%BB%99%E8%87%AA%E5%B7%B1%E7%AD%BE%E5%90%8D%E3%80%82">^自签名</a> X.509 digital root certificate:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl req -x509 -new -nodes -key ca.key -sha256 -days 3650 -out ca.crt</span><br></pre></td></tr></table></figure>

<p>Display the details for the certificate:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl x509 -in ca.crt -noout -text</span><br></pre></td></tr></table></figure>

<p><strong>创建服务器证书</strong></p>
<p>Generate server private key：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out server.key 2048</span><br></pre></td></tr></table></figure>

<p>Generate a certificate signing request, also known as CSR.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl req -new -key server.key -out server.csr</span><br></pre></td></tr></table></figure>

<p>Generate X.509 digital certificate:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 3650 -sha256</span><br></pre></td></tr></table></figure>

<p>Display the details for the certificate:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl x509 -in server.crt -noout -text</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>TLS</category>
      </categories>
  </entry>
  <entry>
    <title>20 VS Code Shortcuts for Faster Coding</title>
    <url>/2020/12/09/Software/VSCode/20%20VS%20Code%20Shortcuts%20for%20Faster%20Coding/</url>
    <content><![CDATA[<p>This article hopes to help people using VS Code to code even faster.</p>
<p>Not everyone has time to go through every tip and trick to find the ones that help them code faster — there’s just too many.</p>
<p>So I’ll list my favorite shortcuts that make me a fast coder.</p>
<p>Let’s start.</p>
<h1 id="Join-Line"><a href="#Join-Line" class="headerlink" title="Join Line"></a>Join Line</h1><p><img src="https://miro.medium.com/freeze/max/60/1*UyDM7R7QbTWMiUdWIERoqw.gif?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/1120/1*UyDM7R7QbTWMiUdWIERoqw.gif" alt="Image for post"></p>
<p>Join line</p>
<a id="more"></a>

<ul>
<li>On Mac: Ctrl+J</li>
<li>On Ubuntu, Windows**:** Open keyboard shortcuts from <code>File</code> &gt; <code>Preferences</code> &gt; <code>Keyboard shortcuts</code>, and bind <code>editor.action.joinLines</code> to a shortcut of your choice.</li>
</ul>
<h1 id="Code-Formatting"><a href="#Code-Formatting" class="headerlink" title="Code Formatting"></a>Code Formatting</h1><p>This shortcut helps to indent the code as already set up in the editor settings.</p>
<p><img src="https://miro.medium.com/freeze/max/60/1*e5rQrZB8WB5g9zzh_MNllw.gif?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/973/1*e5rQrZB8WB5g9zzh_MNllw.gif" alt="Image for post"></p>
<p>Code formatting</p>
<p><strong>Tip:</strong> Use this in the end or the start. I prefer using it when I’m done with the code in a file.</p>
<ul>
<li>On Windows: Shift + Alt + F</li>
<li>On Mac: Shift + Option + F</li>
<li>On Ubuntu: Ctrl + Shift + I</li>
</ul>
<h1 id="Trim-Trailing-White-Space"><a href="#Trim-Trailing-White-Space" class="headerlink" title="Trim Trailing White Space"></a>Trim Trailing White Space</h1><p>This command help to get rid of extra white space at the beginning and end and will save you from any type of strict Lints.</p>
<p><img src="https://miro.medium.com/freeze/max/60/1*h3XpGuLYp3yTzr-F8rw4YA.gif?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/1084/1*h3XpGuLYp3yTzr-F8rw4YA.gif" alt="Image for post"></p>
<p>Trim white space</p>
<p><strong>Tip:</strong> Use this in the end, once you’re done with the code in a file.</p>
<p>Alternatively, you can enable white-space trimming from the settings itself:</p>
<ol>
<li>Open VS User Settings (Preferences &gt; Settings &gt; User Settings tab).</li>
<li>Click the <code>&#123;&#125;</code> icon in the top-right part of the window. This will open a document.</li>
<li>Add a new <code>&quot;files.trimTrailingWhitespace&quot;: true</code> setting to the User Settings documents if it’s not already there. This is so you aren’t editing the default setting directly — but instead adding to it.</li>
<li>Save the User Settings file.</li>
</ol>
<p>We also added a new command to trigger this manually (<code>Trim Trailing Whitespace</code> from the command palette).</p>
<p>Or if you use a new version, then follow setup 1, and see the below image.</p>
<p><img src="https://miro.medium.com/max/60/1*hwesLTI1NVXOmNVhkioMbA.png?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/815/1*hwesLTI1NVXOmNVhkioMbA.png" alt="Image for post"></p>
<h1 id="Code-Folding"><a href="#Code-Folding" class="headerlink" title="Code Folding"></a>Code Folding</h1><p>Sometimes if the file size is big and you just wanted to get an overall understanding of the code, code folding is required.</p>
<p><img src="https://miro.medium.com/freeze/max/60/1*cy6XqWvKUFpnIi0YR-yOFQ.gif?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/1086/1*cy6XqWvKUFpnIi0YR-yOFQ.gif" alt="Image for post"></p>
<p>Code folding</p>
<ol>
<li>To fold the innermost uncollapsed region at the cursor:</li>
</ol>
<ul>
<li>On Windows /Ubuntu: Ctrl + Shift + [</li>
<li>On Mac: Command+ Option + [</li>
</ul>
<p>\2. Unfold unfolds the collapsed region at the cursor:</p>
<ul>
<li>On Windows /Ubuntu: Ctrl + Shift + ]</li>
<li>On Mac: Command+ Option + ]</li>
</ul>
<h1 id="Copy-Line-Up-Down"><a href="#Copy-Line-Up-Down" class="headerlink" title="Copy Line Up/Down"></a>Copy Line Up/Down</h1><p><img src="https://miro.medium.com/freeze/max/60/1*5bE3zR9nHfisxDVcVLab3A.gif?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/971/1*5bE3zR9nHfisxDVcVLab3A.gif" alt="Image for post"></p>
<p>Copy line up/down</p>
<ul>
<li>On Windows: Shift + Alt + Up/Down</li>
<li>On Mac: Shift + Option + Up/Down</li>
<li>On Ubuntu: Ctrl + Shift + Alt + Up/Down</li>
</ul>
<p>Also, you can see the associated keybindings by picking: File &gt; Preferences &gt; Keyboard Shortcuts and editing the binding as per your choice.</p>
<h1 id="Split-Editor"><a href="#Split-Editor" class="headerlink" title="Split Editor"></a>Split Editor</h1><p><img src="https://miro.medium.com/freeze/max/60/1*hY5-C0YyWDaIZi5H5PxTxQ.gif?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/2100/1*hY5-C0YyWDaIZi5H5PxTxQ.gif" alt="Image for post"></p>
<ul>
<li>On Windows: Shift + Alt + \ or 2,3,4</li>
<li>On Mac: Command + \ or 2,3,4</li>
<li>On Ubuntu: Shift + Alt + \ or 2,3,4</li>
</ul>
<p>To split the editor, you can use the <code>split editor</code> command. The original keyboard shortcut for a split editor is <code>123</code>. It’s useful in case of side-by-side editing.</p>
<p>Also, you can see the associated keybindings by picking: File &gt; Preferences &gt; Keyboard Shortcuts and editing the binding as per your choice.</p>
<h1 id="Grid-Editor-Layout"><a href="#Grid-Editor-Layout" class="headerlink" title="Grid Editor Layout"></a>Grid Editor Layout</h1><p>By default, editor groups are laid out in vertical columns (for example, when you split an editor to open it to the side). You can easily arrange editor groups in any layout you like, both vertically and horizontally:</p>
<p><img src="https://miro.medium.com/freeze/max/60/1*ifovtizfLuOqxIZ1YafKbw.gif?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/1819/1*ifovtizfLuOqxIZ1YafKbw.gif" alt="Image for post"></p>
<p>To support flexible layouts, you can create empty editor groups. By default, closing the last editor of an editor group will also close the group itself, but you can change this behavior with the new setting <code>workbench.editor.closeEmptyGroups: false</code>.</p>
<p>There are a predefined set of editor layouts in the new View &gt; Editor Layout menu:</p>
<p><img src="https://miro.medium.com/max/50/1*F4s204XXQPUMa-wlKECr8Q.png?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/688/1*F4s204XXQPUMa-wlKECr8Q.png" alt="Image for post"></p>
<h1 id="Select-Word"><a href="#Select-Word" class="headerlink" title="Select Word"></a>Select Word</h1><p><img src="https://miro.medium.com/max/60/1*0QSbS0gcAjLzqgj9YlgzIg.png?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/1405/1*0QSbS0gcAjLzqgj9YlgzIg.png" alt="Image for post"></p>
<p>Select word</p>
<ul>
<li>On Windows: Ctrl+ d</li>
<li>On Mac: Command + d</li>
<li>On Ubuntu: Ctrl+ d</li>
</ul>
<p>If you hit command + d more than once, you’ll add another occurrence of the same keyword to your selection.</p>
<h1 id="Opening-and-Closing-the-Sidebar"><a href="#Opening-and-Closing-the-Sidebar" class="headerlink" title="Opening and Closing the Sidebar"></a>Opening and Closing the Sidebar</h1><p><img src="https://miro.medium.com/freeze/max/60/1*O1CGDGMIYdn_Ag6X8fSzHQ.gif?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/800/1*O1CGDGMIYdn_Ag6X8fSzHQ.gif" alt="Image for post"></p>
<p>Opening and closing of the sidebar</p>
<ul>
<li>On Windows: Ctrl+ b</li>
<li>On Mac: Command + b</li>
<li>On Ubuntu: Ctrl+ b</li>
</ul>
<p>Sometimes when the file has a long width or in case of the split editor closing, sidebar helps a lot.</p>
<h1 id="Navigate-to-a-Specific-Line"><a href="#Navigate-to-a-Specific-Line" class="headerlink" title="Navigate to a Specific Line"></a>Navigate to a Specific Line</h1><p><img src="https://miro.medium.com/freeze/max/60/1*Nz2DTqFoHsKi4oWHobjYGw.gif?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/1275/1*Nz2DTqFoHsKi4oWHobjYGw.gif" alt="Image for post"></p>
<p>Navigate to a specific line</p>
<p><strong>Note:</strong> To go to a line in the file, you use ctrl + g, then type a line number. Alternatively, you can also open the go-to file menu with command + p first. Then type <code>:</code>. Then type your line number.</p>
<ul>
<li>On Windows: Ctrl + g</li>
<li>On Mac: Ctrl + g or Ctrl + p</li>
<li>On Ubuntu: Ctrl + g</li>
</ul>
<h1 id="Go-to-Symbol-in-File"><a href="#Go-to-Symbol-in-File" class="headerlink" title="Go to Symbol in File"></a>Go to Symbol in File</h1><p><img src="https://miro.medium.com/freeze/max/50/1*kHR52ova0PdtT0PrEm9T2w.gif?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/1004/1*kHR52ova0PdtT0PrEm9T2w.gif" alt="Image for post"></p>
<ul>
<li>On Windows: Ctrl + Shift + o</li>
<li>On Mac: Command + Shift+ o</li>
<li>On Ubuntu: Ctrl + Shift + o</li>
</ul>
<p>You can group the symbols by kind by adding a colon, <code>@:</code>.</p>
<p><img src="https://miro.medium.com/max/60/1*Sdoy2ztcrCgWE_LeHMIScQ.png?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/950/1*Sdoy2ztcrCgWE_LeHMIScQ.png" alt="Image for post"></p>
<p>Group the symbols</p>
<h1 id="Go-to-Symbol-in-Workspace"><a href="#Go-to-Symbol-in-Workspace" class="headerlink" title="Go to Symbol in Workspace"></a>Go to Symbol in Workspace</h1><p><img src="https://miro.medium.com/max/60/1*An7ThNWhWKBiUhGT_8TY-Q.png?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/948/1*An7ThNWhWKBiUhGT_8TY-Q.png" alt="Image for post"></p>
<p>Go to symbol in workspace</p>
<ul>
<li>On Windows: Ctrl + t</li>
<li>On Mac: Command + t</li>
<li>On Ubuntu: Ctrl + t</li>
</ul>
<h1 id="Delete-Previous-Word"><a href="#Delete-Previous-Word" class="headerlink" title="Delete Previous Word"></a>Delete Previous Word</h1><p><img src="https://miro.medium.com/freeze/max/60/1*UfXB-qu4BqiVEmo4KT6d3Q.gif?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/814/1*UfXB-qu4BqiVEmo4KT6d3Q.gif" alt="Image for post"></p>
<ul>
<li>On Windows: Ctrl + backspace</li>
<li>On Mac: Command + delete</li>
<li>On Ubuntu: Ctrl + backspace</li>
</ul>
<p>This is very useful in situations where you make a typo, and you hate having to press and hold the backspace button to get to the part you want to delete.</p>
<h1 id="Select-in-Words"><a href="#Select-in-Words" class="headerlink" title="Select in Words"></a>Select in Words</h1><p><img src="https://miro.medium.com/freeze/max/60/1*jwqSqPZTr3IjHHlydvyYkQ.gif?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/839/1*jwqSqPZTr3IjHHlydvyYkQ.gif" alt="Image for post"></p>
<ul>
<li>On Windows: Ctrl + Shift + Right arrow / Left arrow</li>
<li>On Mac: Command + Shift + Right arrow / Left arrow</li>
<li>On Ubuntu: Ctrl + Shift + Right arrow / Left arrow</li>
</ul>
<p>This is very useful to select words faster and edit as required.</p>
<h1 id="Duplicate-Line"><a href="#Duplicate-Line" class="headerlink" title="Duplicate Line"></a>Duplicate Line</h1><p><img src="https://miro.medium.com/freeze/max/60/1*GJQWlqHsQVnRYxW9tzX_5g.gif?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/819/1*GJQWlqHsQVnRYxW9tzX_5g.gif" alt="Image for post"></p>
<ul>
<li>On Windows: Ctrl + Shift + d</li>
<li>On Mac: Command + Shift +d</li>
<li>On Ubuntu: Ctrl + Shift + d</li>
</ul>
<p>A very powerful and known feature is the ability to duplicate lines.</p>
<h1 id="Deleting-a-Line"><a href="#Deleting-a-Line" class="headerlink" title="Deleting a Line"></a>Deleting a Line</h1><p><img src="https://miro.medium.com/freeze/max/60/1*J0ZRS3WhA7qQVKK_JA8S-g.gif?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/819/1*J0ZRS3WhA7qQVKK_JA8S-g.gif" alt="Image for post"></p>
<ul>
<li>On Windows: Ctrl + x</li>
<li>On Mac: Command + x</li>
<li>On Ubuntu: Ctrl + x</li>
</ul>
<h1 id="Add-Cursor-Above-Below"><a href="#Add-Cursor-Above-Below" class="headerlink" title="Add Cursor Above/Below"></a>Add Cursor Above/Below</h1><p><img src="https://miro.medium.com/freeze/max/60/1*ZzJAoJZEvRj1jkzQYzZ6bA.gif?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/404/1*ZzJAoJZEvRj1jkzQYzZ6bA.gif" alt="Image for post"></p>
<ul>
<li>On Windows: Ctrl + Alt + Up arrow / Down arrow</li>
<li>On Mac: Command + Alt + Up arrow / Down arrow</li>
<li>On Ubuntu: Ctrl + Alt + Up arrow / Down arrow</li>
</ul>
<p>Duplicating your cursors is arguably the one feature in VS code that saves you the most time. This becomes great in situations like TypeScript</p>
<h1 id="Rename-Symbol"><a href="#Rename-Symbol" class="headerlink" title="Rename Symbol"></a>Rename Symbol</h1><p><img src="https://miro.medium.com/freeze/max/60/1*1A2IwTGn8bysVxI7jXBY5g.gif?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/1405/1*1A2IwTGn8bysVxI7jXBY5g.gif" alt="Image for post"></p>
<ul>
<li>On Windows: F2</li>
<li>On Mac: F2</li>
<li>On Ubuntu: F2</li>
</ul>
<p>Select a symbol, then type F2. Alternatively, you can use the context menu.</p>
<h1 id="Column-Box-Selection"><a href="#Column-Box-Selection" class="headerlink" title="Column (Box) Selection"></a>Column (Box) Selection</h1><p><img src="https://miro.medium.com/freeze/max/60/1*wmV3HSsDd_oil5eyp6Jhhg.gif?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/751/1*wmV3HSsDd_oil5eyp6Jhhg.gif" alt="Image for post"></p>
<ul>
<li>On Windows: Shift + Alt</li>
<li>On Mac: Shift + Option</li>
<li>On Ubuntu: Shift + Alt</li>
</ul>
<p>You can select blocks of text by using the above command while you drag your mouse. A separate cursor will be added to the end of each selected line.</p>
<h1 id="Command-Palette"><a href="#Command-Palette" class="headerlink" title="Command Palette"></a>Command Palette</h1><p><img src="https://miro.medium.com/freeze/max/60/1*m3d4062wn-VRTJd_B-d07A.gif?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/1120/1*m3d4062wn-VRTJd_B-d07A.gif" alt="Image for post"></p>
<p>Command Palette</p>
<ul>
<li>On Windows: Ctrl + p</li>
<li>On Mac: Command + p</li>
<li>On Ubuntu: Ctrl + p</li>
</ul>
<p>Access all available commands based on your current context.</p>
<p>Some of the most used are:</p>
<h2 id="1-Open-a-file"><a href="#1-Open-a-file" class="headerlink" title="1. Open a file"></a>1. Open a file</h2><p>To go to a file, you use the above command, then type the name of the file you’re looking for. This should help you locate files quickly.</p>
<p><img src="https://miro.medium.com/freeze/max/60/1*kZ4Cl5LDR3UnxIxzLEYxeA.gif?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/1600/1*kZ4Cl5LDR3UnxIxzLEYxeA.gif" alt="Image for post"></p>
<h2 id="2-See-keyboard-reference-command"><a href="#2-See-keyboard-reference-command" class="headerlink" title="2. See keyboard reference command"></a>2. See keyboard reference command</h2><p>All of the commands are in the Command Palette with the associated key binding (if it exists). If you forget a keyboard shortcut, use the Command Palette to help you out.</p>
<p><img src="https://miro.medium.com/max/60/1*hkc58WQ2gZRWsWJrpTgwEw.png?q=20" alt="Image for post"></p>
<p><img src="https://miro.medium.com/max/943/1*hkc58WQ2gZRWsWJrpTgwEw.png" alt="Image for post"></p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>Since there are a lot of shortcuts that may serve your purpose, I’m adding links to the PDFs for all VS Code shortcuts in a different OS.</p>
<p><strong>Linux:</strong> <a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-linux.pdf">https://code.visualstudio.com/shortcuts/keyboard-shortcuts-linux.pdf</a></p>
<p><strong>Window:</strong> <a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf">https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf</a></p>
<p><strong>macOS:</strong> <a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-macos.pdf">https://code.visualstudio.com/shortcuts/keyboard-shortcuts-macos.pdf</a></p>
]]></content>
      <categories>
        <category>VSCode</category>
      </categories>
  </entry>
  <entry>
    <title>BLE spec 全部版本</title>
    <url>/2020/12/09/Wireless/BLE/BLE%20spec%20%E5%85%A8%E9%83%A8%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<p>最新版本下载：<a href="https://www.bluetooth.com/specifications/bluetooth-core-specification/">https://www.bluetooth.com/specifications/bluetooth-core-specification/</a></p>
<p>历史版本下载：<a href="https://www.bluetooth.com/specifications/archived-specifications/">https://www.bluetooth.com/specifications/archived-specifications/</a></p>
<p>PDF 列表：</p>
<ul>
<li><a href="Core_v4.0.pdf">4.0</a></li>
<li><a href="Core_v4.1.pdf">4.1</a></li>
<li><a href="Core_v4.2.pdf">4.2</a></li>
<li><a href="Core_v5.0.pdf">5.0</a></li>
<li><a href="Core_v5.1.pdf">5.1</a></li>
<li><a href="Core_v5.2.pdf">5.2</a></li>
</ul>
<a id="more"></a>

]]></content>
      <categories>
        <category>BLE</category>
      </categories>
  </entry>
  <entry>
    <title>BLE 最大化吞吐量</title>
    <url>/2020/12/09/Wireless/BLE/BLE%20%E6%9C%80%E5%A4%A7%E5%8C%96%E5%90%9E%E5%90%90%E9%87%8F/</url>
    <content><![CDATA[<p>Slave 通过 notification 发送 293 字节数据，ATT_MTU 为 247 字节，所以分为两次发送。</p>
<p>抓包看有三次 connection event，其中第二次 connection event 没有数据传输，这是为什么呢？</p>
<img src=".最大化吞吐量.assets/image-20201130210148848.png" alt="image-20201130210148848" style="zoom:90%;" />

<p>因为 slave 代码中调用发送 notification API 之后，要等待发送成功事件再发送下一个 notification。</p>
<p>而发送成功事件是在收到的下个 master 数据包的 NESN 后产生，此时 slave 看到 queue 中没有数据，就回复了 Empty PDU。</p>
<p>所以第三次 connection event 才将剩下的数据发送出去。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.000000	Master	Slave		35	12	-50 dBm	Sent Write Command, Handle: 0x0049 (Unknown: Unknown)</span><br><span class="line">0.000998	Slave	Master		26	12	-45 dBm	Empty PDU</span><br><span class="line">0.007012	Master	Slave		26	12	-48 dBm	Empty PDU</span><br><span class="line">0.007999	Slave	Master		26	12	-44 dBm	Empty PDU</span><br><span class="line">0.014914	Master	Slave		26	21	-49 dBm	Empty PDU</span><br><span class="line">0.015960	Slave	Master		35	21	-45 dBm	Rcvd Handle Value Notification, Handle: 0x004b (Unknown: Unknown)</span><br><span class="line">0.021647	Master	Slave		26	32	-50 dBm	Empty PDU</span><br><span class="line">0.022649	Slave	Master		26	32	-46 dBm	Empty PDU</span><br><span class="line">0.029649	Master	Slave		26	34	-52 dBm	Empty PDU</span><br><span class="line">0.030667	Slave	Master		26	34	-53 dBm	Empty PDU</span><br><span class="line">0.036895	Master	Slave		26	12	-49 dBm	Empty PDU</span><br><span class="line">0.045277	Slave	Master		277	12	-44 dBm	Rcvd Handle Value Notification, Handle: 0x004b (Unknown: Unknown)</span><br><span class="line">0.046275	Master	Slave		26	21	-49 dBm	Empty PDU</span><br><span class="line">0.047276	Slave	Master		26	21	-44 dBm	Empty PDU</span><br><span class="line">0.051274	Master	Slave		26	19	-49 dBm	Empty PDU</span><br><span class="line">0.053273	Slave	Master		82	19	-44 dBm	Rcvd Handle Value Notification, Handle: 0x004b (Unknown: Unknown)</span><br><span class="line">0.060110	Master	Slave		26	17	-48 dBm	Empty PDU</span><br><span class="line">0.060110	Slave	Master		26	17	-44 dBm	Empty PDU</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>BLE</category>
      </categories>
  </entry>
  <entry>
    <title>CLI on GATT</title>
    <url>/2020/12/09/Wireless/BLE/CLI%20on%20GATT/</url>
    <content><![CDATA[<p>利用 GATT 作为通道以实现 Command Line Interface 功能。</p>
<h2 id="回显延迟"><a href="#回显延迟" class="headerlink" title="回显延迟"></a>回显延迟</h2><p>设备收到一个字符后要回送此字符，称之为回显。回显速度影响和用户体验，太慢会造成卡顿的感觉。</p>
<p>根据 Core_5.2 | Vol 6, Part B, 4.5.1 Connection events，BLE connection interval 最小为 7.5ms，也即一个字符来回需要 15ms，不会造成延迟感。</p>
<blockquote>
<p>The connInterval shall be a multiple of 1.25 ms in the range 7.5 ms to 4.0 s. </p>
</blockquote>
<h2 id="Nagle-算法"><a href="#Nagle-算法" class="headerlink" title="Nagle 算法"></a>Nagle 算法</h2><p>由于 connection interval 和包头包尾的开销，payload 越长则速率越高，但让应用层来去考虑这个显然是不友好且不现实的。</p>
<p>比如要将 buf 中数据以 hex 方式输出：</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;bufsize; i++)</span><br><span class="line">&#123;</span><br><span class="line">	cli_printf(<span class="string">&quot;%02x&quot;</span>, buf[i]);</span><br><span class="line">&#125;</span><br><span class="line">cli_printf(<span class="string">&quot;\r\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>显然会输出多次 2 字节的数据。</p>
<p>nagle 算法的思想是：<code>当收到上层的数据后，并不立即发送出去，而是稍等一会以期待可能更多的上层数据，合并后一起发送出去</code>。</p>
<p>最简单的方法就是将收到的上层数据缓存起来，有一个线程周期性的将缓存内的数据发送出去。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* API called by upper layer */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gatt_cli_send</span><span class="params">(<span class="keyword">uint8_t</span> *buf, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  write_to_cache(buf, len);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Send thread */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gatt_send_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    delay(<span class="number">10</span>);</span><br><span class="line">    len = read_from_cache(buf, bufsize);</span><br><span class="line">    gatt_send(buf, len);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分片和重组"><a href="#分片和重组" class="headerlink" title="分片和重组"></a>分片和重组</h2><p>Notification 和 Write without response 一次发送的数据长度不能超过 MTU，因此需要分片和重组机制来收发长数据包。</p>
<p>使用 SIG Mesh Proxy PDU 的分片和重组机制，数据包格式如下：</p>
<p><img src="/2020/12/09/Wireless/BLE/CLI%20on%20GATT/image-20201122134052225.png"></p>
<table>
<thead>
<tr>
<th>Filed Name</th>
<th>Size(bits)</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>SAR</td>
<td>2</td>
<td>Message segmentation and reassembly information.</td>
</tr>
<tr>
<td>Message Type</td>
<td>6</td>
<td>Type of message contained in the PDU.</td>
</tr>
<tr>
<td>Data</td>
<td>Variable</td>
<td>Full message or message segment.</td>
</tr>
</tbody></table>
<p>SAR 字段的含义如下：</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>0b00</td>
<td>Data field contains a complete message.</td>
</tr>
<tr>
<td>0b01</td>
<td>Data field contains the first segment of a message.</td>
</tr>
<tr>
<td>0b10</td>
<td>Data field contains a continuation segment of a message.</td>
</tr>
<tr>
<td>0b11</td>
<td>Data field contains the last segment of a message.</td>
</tr>
</tbody></table>
<p>Type 字段的含义如下：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>0x00</td>
<td>Command Line Interface</td>
<td>This message contain Command Line Interface characteristics.</td>
</tr>
<tr>
<td>0x01 - 0x3F</td>
<td>RFU</td>
<td>Reversed for Future Use.</td>
</tr>
</tbody></table>
<p><strong>在 CLI 中，不需要分片和重组</strong>，因为 CLI 是基于数据流的应用，它需要一个一个处理字符，并且有回车换行结束符来定帧。</p>
<h2 id="传输效率"><a href="#传输效率" class="headerlink" title="传输效率"></a>传输效率</h2><p>影响传输效率的有两个因素：</p>
<ul>
<li>ATT_MTU</li>
<li>Connection Interval</li>
</ul>
<p>根据<em>5.2 | Vol 6, Part B, 4.5.1 Connection events</em></p>
<blockquote>
<p>The connInterval shall be a multiple of 1.25 ms in the range 7.5 ms to 4.0 s.</p>
<p>The connInterval is set by the Initiator’s Link Layer in the CONNECT_IND or AUX_CONNECT_REQ PDU from the range given by the Host and can be changed using the Connection Update procedure (see Section 5.1.1) or Connection Parameters Request procedure (see Section 5.1.7).</p>
</blockquote>
<p>Connection Interval 由链路发起者（Master）设置，放在 CONNECT_IND 包中。</p>
<p><img src="/2020/12/09/Wireless/BLE/CLI%20on%20GATT/image-20201125233911750.png"></p>
<p><img src="/2020/12/09/Wireless/BLE/CLI%20on%20GATT/image-20201125235658557.png"></p>
<p>也可以在连接上后通过 Connection Update procedure 或者 Connection Parameters Request procedure 发起更新。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>无线模组一般通过串口或来调试，但已经组装到整机中的模组则很难调试。</p>
<p>比如在 VBS9010 项目中，经常需要知道一个灯的 mesh 地址，三元组，是否被重置等信息，但是目前没有方便的办法来获取。</p>
<p>GATT CLI 正是为解决这个问题，它基于 GATT 通道实现了 CLI 功能，设备端应用简单，消耗资源少，PC 端也只需要普通的串口终端即可。</p>
<p>随着 Wi-Fi&amp;BT combo 模组的推广，GATT CLI 会极大的方便整机产品的调试和生产。</p>
]]></content>
      <categories>
        <category>BLE</category>
      </categories>
  </entry>
  <entry>
    <title>Connection Update</title>
    <url>/2020/12/09/Wireless/BLE/Connection%20Update/</url>
    <content><![CDATA[<h2 id="Connection-Update-Procedure"><a href="#Connection-Update-Procedure" class="headerlink" title="Connection Update Procedure"></a>Connection Update Procedure</h2><p>根据<em>Core_4.0 | Vol 6, Part B, 5.1.1 Connection Update procedure</em></p>
<blockquote>
<p>The Link Layer parameters for a connection (<em>connInterval</em>, <em>connSlaveLatency</em> and <em>connSupervisionTimeout</em>) may be updated after entering the Connection State. The master can update the connection parameters by sending an LL_CONNECTION_UPDATE_REQ PDU. The slave shall not send this PDU; the slave may request a change to the connection parameters using the L2CAP LE signaling channel.</p>
</blockquote>
<h2 id="Connection-Parameters-Request-procedure"><a href="#Connection-Parameters-Request-procedure" class="headerlink" title="Connection Parameters Request procedure"></a>Connection Parameters Request procedure</h2><p>根据<em>Core_5.2 | Vol 6, Part B, 5.1.7 Connection Parameters Request procedure</em></p>
<blockquote>
<p>The master or slave may initiate a Connection Parameters Request procedure to request the remote device to have the Link Layer parameters for the connection (connInterval, connSlaveLatency and connSupervisionTimeout) updated any time after entering the Connection State.</p>
</blockquote>
<p>Master 和 Slave 都可以发起 Connection Parameters Request procedure。</p>
<p>发起者发送<code>LL_CONNECTION_PARAM_REQ</code>，包含 Interval_Min 和 Interval_Max。</p>
<a id="more"></a>

<p>对端若是 maste，则回复<code>LL_CONNECTION_UPDATE_IND</code>，若是 slave，则回复<code> LL_CONNECTION_PARAM_RSP</code>。</p>
<p>若对端不接受参数更新请求，则回复二者之一：</p>
<ul>
<li>包含了替代参数的<code>LL_CONNECTION_PARAM_RSP</code>(slave)或者<code> LL_CONNECTION_UPDATE_IND PDU</code>（master）</li>
<li><code>LL_REJECT_EXT_IND</code>，其中<code>ErrorCode</code> 设置为<code>Unsupported LL Parameter Value</code> (0x20).</li>
</ul>
<p>Slave 发送了<code>LL_CONNECTION_PARAM_REQ</code>，Interval Min = 20，Interval Max = 40，Master 在<code>LL_CONNECTION_UPDATE_REQ</code>中选择了 Interval = 40。</p>
<p><img src="/2020/12/09/Wireless/BLE/Connection%20Update/image-20201122130447407.png"></p>
<p>在<code>Zephyr</code>中<code>bt_conn_le_create</code>函数参数<code>conn_param</code>可以设置 connInterval。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** @brief Initiate an LE connection to a remote device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Allows initiate new LE link to remote peer using its address.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  The caller gets a new reference to the connection object which must be</span></span><br><span class="line"><span class="comment"> *  released with bt_conn_unref() once done using the object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This uses the General Connection Establishment procedure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param[in]  peer         Remote address.</span></span><br><span class="line"><span class="comment"> *  @param[in]  create_param Create connection parameters.</span></span><br><span class="line"><span class="comment"> *  @param[in]  conn_param   Initial connection parameters.</span></span><br><span class="line"><span class="comment"> *  @param[out] conn         Valid connection object on success.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return Zero on success or (negative) error code on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bt_conn_le_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">bt_addr_le_t</span> *peer,</span></span></span><br><span class="line"><span class="function"><span class="params">		      <span class="keyword">const</span> struct bt_conn_le_create_param *create_param,</span></span></span><br><span class="line"><span class="function"><span class="params">		      <span class="keyword">const</span> struct bt_le_conn_param *conn_param,</span></span></span><br><span class="line"><span class="function"><span class="params">		      struct bt_conn **conn)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Helper to declare connection parameters inline</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param int_min  Minimum Connection Interval (N * 1.25 ms)</span></span><br><span class="line"><span class="comment"> *  @param int_max  Maximum Connection Interval (N * 1.25 ms)</span></span><br><span class="line"><span class="comment"> *  @param lat      Connection Latency</span></span><br><span class="line"><span class="comment"> *  @param to       Supervision Timeout (N * 10 ms)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BT_LE_CONN_PARAM(int_min, int_max, lat, to) \</span></span><br><span class="line">	((struct bt_le_conn_param[]) &#123; \</span><br><span class="line">		BT_LE_CONN_PARAM_INIT(int_min, int_max, lat, to) \</span><br><span class="line">	 &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><code>Connection Update Procedure</code>和<code>Connection Parameters Request procedure</code>都实现了在连接后设置连接参数的功能(connInterval, connSlaveLatency and connSupervisionTimeout) ，那么它们有什么区别呢？</p>
<p>一开始在 BLE 4.0 中只有<code>Connection Update Procedure</code>，只能由 master 主动发起，slave 只能请求 master 发起更新，可能后来有 slave 主动发起更新的需求，又为了向后兼容，于是定义了新的<code>Connection Parameters Request procedure</code>，支持 slave 主动发起更新。</p>
]]></content>
      <categories>
        <category>BLE</category>
      </categories>
  </entry>
  <entry>
    <title>MTU exchange</title>
    <url>/2020/12/09/Wireless/BLE/MTU%20exchange/</url>
    <content><![CDATA[<h2 id="MTU-exchange"><a href="#MTU-exchange" class="headerlink" title="MTU exchange"></a>MTU exchange</h2><p>根据<em>Core_5.2 | Vol 3, Part G, 4.3.1</em></p>
<p>Client 通过此 sub-procedure 来发起 ATT_MTU 协商，最终选择两个设备 ATT_MTU 中较小的那个作为本次连接的 ATT_MTU。 <strong>MTU exchange 一次连接中只能启动一次</strong>。</p>
<p><img src="/2020/12/09/Wireless/BLE/MTU%20exchange/image-20201130002648285.png"></p>
<p>Client 向 server 发送<code>ATT_EXCHANGE_MTU_REQ</code>，包含自己的 MTU</p>
<p><img src="/2020/12/09/Wireless/BLE/MTU%20exchange/image-20201130002813940.png"></p>
<p>Server 会回复<code>ATT_EXCHANGE_MTU_RSP</code>，包含自己的 MTU</p>
<p><img src="/2020/12/09/Wireless/BLE/MTU%20exchange/image-20201130002908077.png"></p>
<a id="more"></a>



<p>在<code>Zephyr</code>中<code>bt_gatt_exchange_mtu</code>用以实现 MTU exchange 流程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** @brief Exchange MTU</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This client procedure can be used to set the MTU to the maximum possible</span></span><br><span class="line"><span class="comment"> *  size the buffers can hold.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @note Shall only be used once per connection.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param conn Connection object.</span></span><br><span class="line"><span class="comment"> *  @param params Exchange MTU parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 0 in case of success or negative value in case of error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bt_gatt_exchange_mtu</span><span class="params">(struct bt_conn *conn,</span></span></span><br><span class="line"><span class="function"><span class="params">			 struct bt_gatt_exchange_params *params)</span></span>;</span><br></pre></td></tr></table></figure>

<p>MTU 在<code>prj.conf</code>中配置，若无配置，则默认为23</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONFIG_BT_L2CAP_RX_MTU&#x3D;247</span><br><span class="line">CONFIG_BT_L2CAP_TX_MTU&#x3D;247</span><br></pre></td></tr></table></figure>

<p>若 MTU 大于 23，则还需要配置<code>Data Length Extension</code></p>
<p><img src="/2020/12/09/Wireless/BLE/MTU%20exchange/image-20201201155230522.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONFIG_BT_CTLR_DATA_LENGTH&#x3D;y</span><br><span class="line">CONFIG_BT_CTLR_DATA_LENGTH_MAX&#x3D;251</span><br></pre></td></tr></table></figure>

<h2 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h2><p>Master 发送<code>ATT_EXCHANGE_MTU_REQ</code>，Rx MTU=251。</p>
<p>Slave 回复<code>ATT_EXCHANGE_MTU_RSP</code>，Rx MTU=247。</p>
<p>最终选择 Rx MTU 为 247。</p>
<p><img src="/2020/12/09/Wireless/BLE/MTU%20exchange/image-20201130201110426.png"></p>
<p><img src="/2020/12/09/Wireless/BLE/MTU%20exchange/image-20201130201210585.png"></p>
<p>抓包数据：<a href="MTU.pcapng">MTU.pcapng</a></p>
]]></content>
      <categories>
        <category>BLE</category>
      </categories>
  </entry>
  <entry>
    <title>Wireshark 抓包</title>
    <url>/2020/12/09/Wireless/BLE/Wireshark%20%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<h2 id="如何判断漏抓包"><a href="#如何判断漏抓包" class="headerlink" title="如何判断漏抓包"></a>如何判断漏抓包</h2><p>判断是否丢包有几种方式：</p>
<ul>
<li>看 channel。一次 connection event 只在一个 channel 上，包的数量是偶数的。</li>
<li>看 master 和 slave。master 和 slave 轮流发包。</li>
<li>看 more data。more data 后面一定还跟有数据。</li>
</ul>
<a id="more"></a>

]]></content>
      <categories>
        <category>BLE</category>
      </categories>
  </entry>
  <entry>
    <title>bluepy - Python 版的 BLE 利器</title>
    <url>/2020/12/09/Wireless/BLE/bluepy%20-%20Python%20%E7%89%88%E7%9A%84%20BLE%20%E5%88%A9%E5%99%A8/</url>
    <content><![CDATA[<p>无意间发现了一个 python 版的 BLE 利器 - <a href="https://github.com/IanHarvey/bluepy">bluepy</a>。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>bluepy 是 github 上的一个开源项目，它用 python 封装了 linux 上的 BLE 接口。</p>
<p>作者主要基于树莓派开发，也可以运行在 x86 Debian Linux 上。</p>
<p>bluepy 其实是 BlueZ 的 python 封装。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>对于 Windows 和 macOS 用户，可以用虚拟机安装 Ubuntu（基于 Debian 系统）。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><a id="more"></a>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install python3-pip libglib2.0-dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo pip3 install bluepy</span></span><br></pre></td></tr></table></figure>

<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>bluepy 的<a href="http://ianharvey.github.io/bluepy-doc/#">文档</a>中的 demo 很少，所幸 github 上有个<a href="https://github.com/rlangoy/bluepy_examples_nRF51822_mbed">仓库</a>有丰富的例程，不过都是 python2，自己转了几个 python3 的例子。</p>
<p>注意：需要 root 权限来运行这些脚本。</p>
<h4 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bluepy.btle <span class="keyword">import</span> Scanner, DefaultDelegate</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScanDelegate</span>(<span class="params">DefaultDelegate</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        DefaultDelegate.__init__(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handleDiscovery</span>(<span class="params">self, dev, isNewDev, isNewData</span>):</span></span><br><span class="line">        <span class="keyword">if</span> isNewDev:</span><br><span class="line">            print(<span class="string">&quot;Discovered device&quot;</span>, dev.addr)</span><br><span class="line">        <span class="keyword">elif</span> isNewData:</span><br><span class="line">            print(<span class="string">&quot;Received new data from&quot;</span>, dev.addr)</span><br><span class="line"></span><br><span class="line">scanner = Scanner().withDelegate(ScanDelegate())</span><br><span class="line">devices = scanner.scan(<span class="number">10.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> dev <span class="keyword">in</span> devices:</span><br><span class="line">    print(<span class="string">&quot;Device %s (%s), RSSI=%d dB&quot;</span> % (dev.addr, dev.addrType, dev.rssi))</span><br><span class="line">    <span class="keyword">for</span> (adtype, desc, value) <span class="keyword">in</span> dev.getScanData():</span><br><span class="line">        print(<span class="string">&quot;  %s = %s&quot;</span> % (desc, value))</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Scanner([index=0])</code>用于产生并初始化一个新的scanner对象，index 用来指名哪一个蓝牙设备就会被用（默认0表示使用/dev/hci0）。调用start或scan函数之后开始扫描。</li>
<li><code>withDelegate(delegate)</code>存储对委托对象的引用，委托对象在接收来自设备的广播时接收回调。有关详细信息，请参阅DefaultDelegate的文档。</li>
<li><code>scan([timeout = 10])</code>开始扫描并带有扫描时间，在此扫描期间扫描到的设备会触发Delegate的回调函数，我们可以在其回调函数中实时获取并打印。当扫描结束后后会返回一个设备列表。</li>
</ul>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Discovered device 01:d1:c5:88:91:8e</span><br><span class="line">Discovered device 0d:1e:9d:f4:5a:62</span><br><span class="line">Received new data from 01:d1:c5:88:91:8e</span><br><span class="line">Discovered device 3c:32:dc:9d:24:6b</span><br><span class="line">Discovered device f4:d7:60:14:88:84</span><br><span class="line">Discovered device ab:36:be:b6:43:43</span><br><span class="line">Discovered device 96:bb:75:92:ca:8a</span><br><span class="line">Discovered device fb:ac:56:d9:44:cf</span><br><span class="line"></span><br><span class="line">Device 01:d1:c5:88:91:8e (public), RSSI&#x3D;-62 dB</span><br><span class="line">  Manufacturer &#x3D; a8010a05c90e000038d2ca307de1</span><br><span class="line">  Complete Local Name &#x3D; MeshDevice</span><br><span class="line">Device 0d:1e:9d:f4:5a:62 (public), RSSI&#x3D;-61 dB</span><br><span class="line">Device 3c:32:dc:9d:24:6b (public), RSSI&#x3D;-76 dB</span><br><span class="line">  Manufacturer &#x3D; 8f030a101c0000fa987f4f5e80ec</span><br><span class="line">Device f4:d7:60:14:88:84 (public), RSSI&#x3D;-86 dB</span><br><span class="line">  Manufacturer &#x3D; 8f030a101c0000590435ee35acec</span><br><span class="line">Device ab:36:be:b6:43:43 (public), RSSI&#x3D;-69 dB</span><br><span class="line">Device 96:bb:75:92:ca:8a (public), RSSI&#x3D;-59 dB</span><br><span class="line">Device fb:ac:56:d9:44:cf (public), RSSI&#x3D;-70 dB</span><br></pre></td></tr></table></figure>

<h4 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> bluepy.btle <span class="keyword">import</span> UUID, Peripheral</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">2</span>:</span><br><span class="line">  print(<span class="string">&quot;Fatal, must pass device address:&quot;</span>, sys.argv[<span class="number">0</span>], <span class="string">&quot;&lt;device address&gt;&quot;</span>)</span><br><span class="line">  quit()</span><br><span class="line"></span><br><span class="line">p = Peripheral(sys.argv[<span class="number">1</span>], <span class="string">&quot;public&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get all services</span></span><br><span class="line">services=p.getServices()</span><br><span class="line"><span class="keyword">for</span> service <span class="keyword">in</span> services:</span><br><span class="line">   print(service)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get all characteristics</span></span><br><span class="line">chList = p.getCharacteristics()</span><br><span class="line">print(<span class="string">&quot;Handle   UUID                                Properties&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;-------------------------------------------------------&quot;</span>)                     </span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> chList:</span><br><span class="line">   print(<span class="string">&quot;  0x&quot;</span>+ <span class="built_in">format</span>(ch.getHandle(),<span class="string">&#x27;02X&#x27;</span>)  +<span class="string">&quot;   &quot;</span>+<span class="built_in">str</span>(ch.uuid) +<span class="string">&quot; &quot;</span> + ch.propertiesToString())</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Peripheral(sys.argv[1],&quot;public&quot;)</code>是用mac地址创建一个连接，由于我们上一步用scan搜索到的mac地址为public类型，因此这里第二个参数为”public”。</li>
<li><code>getServices</code>会返回所连接设备的服务。</li>
<li><code>getCharacteristics</code>会返回所连接设备的特征值。</li>
</ul>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Service &lt;uuid&#x3D;feb3 handleStart&#x3D;1 handleEnd&#x3D;13&gt;</span><br><span class="line">Service &lt;uuid&#x3D;1828 handleStart&#x3D;14 handleEnd&#x3D;20&gt;</span><br><span class="line">Handle   UUID                                Properties</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">  0x03   0000fed4-0000-1000-8000-00805f9b34fb READ </span><br><span class="line">  0x05   0000fed5-0000-1000-8000-00805f9b34fb READ WRITE </span><br><span class="line">  0x07   0000fed6-0000-1000-8000-00805f9b34fb READ INDICATE </span><br><span class="line">  0x09   0000fed7-0000-1000-8000-00805f9b34fb READ WRITE NO RESPONSE </span><br><span class="line">  0x0B   0000fed8-0000-1000-8000-00805f9b34fb READ NOTIFY </span><br><span class="line">  0x10   00002add-0000-1000-8000-00805f9b34fb WRITE NO RESPONSE </span><br><span class="line">  0x12   00002ade-0000-1000-8000-00805f9b34fb NOTIFY</span><br></pre></td></tr></table></figure>

<h4 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h4><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>[<a href="https://www.cnblogs.com/zjutlitao/p/10171913.html">python] bluepy 一款python封装的BLE利器</a></li>
</ul>
]]></content>
      <categories>
        <category>BLE</category>
      </categories>
  </entry>
  <entry>
    <title>最大包长的变化</title>
    <url>/2020/12/09/Wireless/BLE/%E6%9C%80%E5%A4%A7%E5%8C%85%E9%95%BF%E7%9A%84%E5%8F%98%E5%8C%96/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>版本</th>
<th>ATT MTU</th>
</tr>
</thead>
<tbody><tr>
<td>4.0 - 4.1</td>
<td>23</td>
</tr>
<tr>
<td>4.2 - 5.0</td>
<td>247</td>
</tr>
<tr>
<td>5.1 - 5.2</td>
<td>248</td>
</tr>
</tbody></table>
<p>为什么不一开始就定义更大的 ATT MTU 呢，因为数据包越长则射频电路发热越严重进而导致频偏，ATT MTU 是根据当时的芯片工艺和成本来制定的。</p>
<p>以 4.2 为例，其 Linker Layer packet 格式如下：</p>
<p><img src="/2020/12/09/Wireless/BLE/%E6%9C%80%E5%A4%A7%E5%8C%85%E9%95%BF%E7%9A%84%E5%8F%98%E5%8C%96/image-20201201231940316.png"></p>
<p>其中 PDU 格式如下：</p>
<p><img src="/2020/12/09/Wireless/BLE/%E6%9C%80%E5%A4%A7%E5%8C%85%E9%95%BF%E7%9A%84%E5%8F%98%E5%8C%96/image-20201201232003913.png"></p>
<a id="more"></a>

<p>其中 Payload 就是 L2CAP，格式如下：</p>
<p><img src="/2020/12/09/Wireless/BLE/%E6%9C%80%E5%A4%A7%E5%8C%85%E9%95%BF%E7%9A%84%E5%8F%98%E5%8C%96/image-20201201220730783.png"></p>
<p>其中 Information payload 就是 ATT MTU，最大为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">257 (LL PDU) - 6 (Data Channel PDU Header + MIC) - 4 (L2CAP header) &#x3D; 247</span><br></pre></td></tr></table></figure>

<p>需要注意的是，虽然 4.0 的 Link Layer packet 中 PDU 最长为 39，按照上述计算应该是 39 - 6 - 4 = 29，但实际上是 23。</p>
<p>因为 Advertising Channel PDU 最长为 39，包含了 6 字节的 Advertising address，而 Data Channel PDU 最长为 39 - 6 = 33。</p>
<p><img src="/2020/12/09/Wireless/BLE/%E6%9C%80%E5%A4%A7%E5%8C%85%E9%95%BF%E7%9A%84%E5%8F%98%E5%8C%96/image-20201201232417478.png"></p>
]]></content>
      <categories>
        <category>BLE</category>
      </categories>
  </entry>
  <entry>
    <title>Wi-Fi 存储多组路由信息</title>
    <url>/2020/12/09/Wireless/Wi-Fi/Wi-Fi%20%E5%AD%98%E5%82%A8%E5%A4%9A%E7%BB%84%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>比如点读笔和故事机这类移动式设备，有可能不止在家里使用，若只存储一个路由器连接信息，那么每次换个地方都要重新配网，比较麻烦。</p>
<p>所以 Wi-Fi 模组应该存储多个路由器的连接信息，上电后自动去连接其中信号强度最好的那一个路由器。</p>
<a id="more"></a>

]]></content>
      <categories>
        <category>Wi-Fi</category>
      </categories>
  </entry>
  <entry>
    <title>Wi-Fi 快连</title>
    <url>/2020/12/09/Wireless/Wi-Fi/Wi-Fi%20%E5%BF%AB%E8%BF%9E/</url>
    <content><![CDATA[<p>一般的 WiFi 连接过程：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>时间（秒）</th>
</tr>
</thead>
<tbody><tr>
<td>扫描，获得路由器信息（安全，信道等）</td>
<td>1</td>
</tr>
<tr>
<td>计算 PSK</td>
<td>2</td>
</tr>
<tr>
<td>连接</td>
<td>1</td>
</tr>
</tbody></table>
<p>若已知路由器的安全和信道信息，那么可以省去扫描步骤。</p>
<p>若已知 PSK，那么可以省去计算 PSK 步骤。</p>
<p>这样就可以省去 3 秒，连接路由器只需 1 秒钟，称之为快连。</p>
<a id="more"></a>

]]></content>
      <categories>
        <category>Wi-Fi</category>
      </categories>
  </entry>
  <entry>
    <title>a,b,g,n,ac,ax 协议</title>
    <url>/2020/12/09/Wireless/Wi-Fi/a,b,g,n,ac,ax%20%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p><img src="/2020/12/09/Wireless/Wi-Fi/a,b,g,n,ac,ax%20%E5%8D%8F%E8%AE%AE/image-20201119224849711.png" alt="image-20201119224849711"></p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5G    | a --------+--- ac --+</span><br><span class="line">Mixed |           n --------+--- ax</span><br><span class="line">2.4G  | b -- g ---+</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.semiconductorstore.com/blog/2014/WiFi-standards-802-11a-b-g-n-vs-802-11ac-Which-is-Best/806/">WiFi Standards 802.11a/b/g/n vs. 802.11ac: Which is Best?</a></p>
<p><strong>802.11</strong></p>
<p>1997年，电气和电子工程师协会（IEEE）创建了第一个WLAN标准。他们以监督该组织发展的组织名称命名为802.11。不幸的是，<a href="https://www.semiconductorstore.com/Wi-Fi-80211/C/39/?cmlink=2">802.11</a>仅支持最大2 Mbps的网络带宽，对于大多数应用而言太慢了。</p>
<p><strong>802.11b</strong></p>
<p>IEEE于1999年7月扩展了原始802.11标准，从而创建了802.11b规范。802.11b支持的带宽高达11 Mbps，可与传统以太网媲美。</p>
<p>802.11b使用与原始802.11标准相同的不受管制的无线电信令频率（<a href="https://www.semiconductorstore.com/2-4GHz/C/35/?cmlink=1">2.4 GHz</a>）。供应商通常更喜欢使用这些频率来降低其生产成本。不受管制的802.11b设备可能会受到微波炉，无绳电话和其他使用相同2.4 GHz范围的设备的干扰。但是，通过将802.11b设备安装在距其他设备足够的距离的位置，可以轻松避免干扰。</p>
<ul>
<li><strong>802.11b的优点</strong>-最低成本；信号范围好，不易受阻</li>
<li><strong>802.11b的缺点</strong>-最大速度最慢；家用电器可能会干扰不受管制的频段</li>
</ul>
<p><strong>802.11a</strong></p>
<p>在802.11b开发期间，IEEE创建了对原始802.11标准的第二扩展，称为<em>802.11a</em>。因为802.11b的普及速度比802.11a快得多，所以一些人认为802.11a是在802.11b之后创建的。实际上，802.11a是同时创建的。由于成本较高，通常在商业网络上可以找到802.11a，而802.11b可以更好地服务于家庭市场。</p>
<p>802.11a支持高达54 Mbps的带宽，并以<a href="https://www.semiconductorstore.com/58GHz/C/320/?cmlink=1">5 GHz</a>附近的规定频谱提供信号。与802.11b相比，此更高的频率缩短了802.11a网络的范围。802.11a接入点发射机的覆盖面积可能不到可比802.11b / g单元的四分之一。更高的频率还意味着802.11a信号穿透墙壁和其他障碍物的难度更大。</p>
<p>由于802.11a和802.11b使用不同的频率，因此这两种技术互不兼容。一些供应商提供混合802.11a / b网络设备，但是这些产品仅并排实现两个标准，因为连接的设备必须使用一个或另一个。</p>
<ul>
<li><strong>802.11a的优点</strong>-最快的速度；稳定的频率可防止来自其他设备的信号干扰</li>
<li><strong>802.11a的缺点</strong>-成本最高；范围更短的信号更容易被阻挡</li>
</ul>
<p><strong>802.11g</strong></p>
<p>在2002年和2003年，支持新标准802.11g的WLAN产品出现在市场上。802.11g尝试结合802.11a和802.11b的优点。802.11g支持高达54 Mbps的带宽，并使用2.4 GHz频率提供更大的范围。802.11g向后兼容802.11b，这意味着802.11g接入点可与802.11b无线网络适配器配合使用，反之亦然。</p>
<ul>
<li><strong>802.11g的优点</strong>-最快的最高速度；信号范围好，不易受阻</li>
<li><strong>802.11g的缺点</strong>-成本比802.11b高；电器可能会干扰未调节的信号频率</li>
</ul>
<p><strong>802.11n</strong></p>
<p>802.11n（有时也称为“无线N”）旨在通过使用多个无线信号和天线（称为MIMO技术）而不是一个来改善802.11g的带宽支持。行业标准组织在2009年批准了802.11n，其规范提供了高达300 Mbps的网络带宽。由于802.11n增强了信号强度，因此它在早期Wi-Fi标准方面也提供了更好的范围，并且与802.11b / g装置向后兼容。</p>
<ul>
<li><strong>802.11n的优点</strong>-最快的最大速度和最佳的信号范围；更能抵抗来自外界的信号干扰</li>
<li><strong>802.11n的缺点</strong>-标准尚未最终确定；成本超过802.11g；使用多个信号可能会严重干扰附近的基于802.11b / g的网络</li>
</ul>
<p><strong>802.11ac</strong></p>
<p>802.11ac是最流行的最新一代Wi-Fi信令，它采用双频带无线技术，支持2.4 GHz和5 GHz Wi-Fi频带上的同时连接。802.11ac向后兼容802.11b / g / n，在5 GHz频段上的带宽额定高达1300 Mbps，在2.4 GHz上的带宽高达450 Mbps。</p>
<ul>
<li><strong>802.11ac的优点</strong>–通过同时连接支持提供了改进的带宽和更大的灵活性；向后兼容允许使用现有技术</li>
<li><strong>802.11ac的缺点–</strong>双频意味着成本增加；在2.4GHz频率上仍然容易受到干扰</li>
</ul>
]]></content>
      <categories>
        <category>Wi-Fi</category>
      </categories>
  </entry>
  <entry>
    <title>基础知识</title>
    <url>/2020/12/09/Wireless/Wi-Fi/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="Wi-Fi-和-802-11"><a href="#Wi-Fi-和-802-11" class="headerlink" title="Wi-Fi 和 802.11"></a>Wi-Fi 和 802.11</h2><ul>
<li>IEEE 802.11 是 IEEE 802 局域网（LAN）协议集的一部分。</li>
<li>它指定了用于实现无线局域网（WLAN）计算机通信的媒体访问控制（MAC）和物理层（PHY）协议集。</li>
<li>包含但不限于 2.4 GHz，5 GHz，6 GHz 和 60 GHz 频段。</li>
<li>Wi-Fi 是遵从 IEEE 802.11 标准的一种通信技术。</li>
</ul>
<h2 id="协议-a-b-g-n-ac-ax"><a href="#协议-a-b-g-n-ac-ax" class="headerlink" title="协议 a, b, g, n, ac, ax"></a>协议 a, b, g, n, ac, ax</h2><p><img src="https://img2018.cnblogs.com/blog/652919/201907/652919-20190702212051215-617241579.png" alt="img"></p>
<p><img src="/.%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86.assets/image-20201119212844381.png" alt="image-20201119212844381"></p>
<h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><a id="more"></a>


<h3 id="SSID，BSSID，ESSID"><a href="#SSID，BSSID，ESSID" class="headerlink" title="SSID，BSSID，ESSID"></a>SSID，BSSID，ESSID</h3><p>SSID = Service Set IDentifier </p>
<p>BSSID = Basic Service Set IDentifier </p>
<p>ESSID = Extended Service Set IDentifier</p>
<p>举个例子，一家公司面积比较大，安装了若干台无线接入点（AP或者无线路由器），公司员工只需要知道一个 SSID 就可以在公司范围内任意地方接入无线网络。<strong>BSSID其实就是每个无线接入点的MAC地址</strong>。当员工在公司内部移动的时候，SSID是不变的。但BSSID随着你切换到不同的无线接入点，是在不停变化的。</p>
<p>ESS包括了网络中所有的BSS，一般ESSID就是SSID。</p>
]]></content>
      <categories>
        <category>Wi-Fi</category>
      </categories>
  </entry>
  <entry>
    <title>负载均衡</title>
    <url>/2020/12/09/Wireless/Wi-Fi/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<p>阿里魔笔的项目，华三提出一个要求，现场可能有多个相同SSID的AP，每个AP下面挂多个 Station。希望模组能够连接 Station 较少的那个 AP。</p>
<p>这个是对3080B的一个需求，对周围多个同名SSID的AP，根据扫描到的AP下面已经连接的Station number来排序，优先连接AP下面Station number少的AP。</p>
<p>AP的beacon和probe response里面都有这个IE项。要完成这个功能，需要找Realtek提供扫描返回的所有IE信息，或者让Realtek增加返回Staion count的接口。我想我们应该新增一个API，让用户选择是否使用这个station count来选择AP连接。</p>
<p><img src="/2020/12/09/Wireless/Wi-Fi/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/image-20201111225138431.png"></p>
<a id="more"></a>

]]></content>
      <categories>
        <category>Wi-Fi</category>
      </categories>
  </entry>
  <entry>
    <title>LwIP inside</title>
    <url>/2020/12/09/Network/TCPIP/LwIP/LwIP%20inside/</url>
    <content><![CDATA[<p>本文使用的源码版本是 2.0.3</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>LwIP 自带两种内存管理机制：内存堆(heap)和内存池(pool)。</p>
<p>堆和池各自的优缺点不再阐述，其实就是效率和利用率之间的权衡。</p>
<h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><p>Pool 是个链表结构，LwIP 中每种类型的数据结构都对应着一种 pool，协议栈用 5 个属性来描述一种 pool：</p>
<ol>
<li>名称字符</li>
<li>单个大小</li>
<li>总共个数</li>
<li>内存空间</li>
</ol>
<a id="more"></a>

<ol start="5">
<li>首指针</li>
</ol>
<p>用结构体来描述就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct memp_desc</span><br><span class="line">&#123;</span><br><span class="line">  char *desc;</span><br><span class="line">  int size;</span><br><span class="line">  int num;</span><br><span class="line">  int *mem_base;</span><br><span class="line">  memp *tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每类 pool 都对应一个结构体变量，什么时候用什么方法初始化这些结构体变量呢？</p>
<p>普通的做法是为每类 pool 定义一个变量并赋初值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memp_desc memp_RAW_PCB &#x3D; </span><br><span class="line">&#123;</span><br><span class="line">  &quot;RAW_PCB&quot;,</span><br><span class="line">  1024,</span><br><span class="line">  16,</span><br><span class="line">  0x20001234;</span><br><span class="line">  &amp;memp_tab_RAW_PCB;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是协议栈中有那么多的 pool，这样很繁琐且不灵活。</p>
<p>LwIP 使用了一种屌炸天的奇技淫巧：宏定义大法。</p>
<p>协议栈的 memp_std.h 中为每类 pool 定义了一行字符串：LWIP_MEMPOOL(name, num, size, desc)，这行字符串用来描述一类 pool 的属性。</p>
<p>例如：LWIP_MEMPOOL(RAW_PCB,        MEMP_NUM_RAW_PCB,         sizeof(struct raw_pcb),        “RAW_PCB”)</p>
<p>然后在 memp.c 中把 LWIP_MEMPOOL 定义成了一个屌炸天的宏定义（略有修改）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define LWIP_MEMPOOL_DECLARE(name,num,size,desc) \</span><br><span class="line">  u8_t memp_memory_ ## name ## _base[num * size]; \</span><br><span class="line">  static struct memp *memp_tab_ ## name; \</span><br><span class="line">  const struct memp_desc memp_ ## name &#x3D; \</span><br><span class="line">  &#123; \</span><br><span class="line">    desc, \</span><br><span class="line">    size, \</span><br><span class="line">    num, \</span><br><span class="line">    memp_memory_ ## name ## _base, \</span><br><span class="line">    &amp;memp_tab_ ## name \</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>编译展开后是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u8_t memp_memory_RAW_PCB_base[MEMP_NUM_RAW_PCB * sizeof(struct raw_pcb)];</span><br><span class="line">static struct memp *memp_tab_RAW_PCB;</span><br><span class="line">const struct memp_desc memp_RAW_PCB &#x3D;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;RAW_PCB&quot;,</span><br><span class="line">  sizeof(struct raw_pcb),</span><br><span class="line">  MEMP_NUM_RAW_PCB,</span><br><span class="line">  memp_memory_RAW_PCB_base,</span><br><span class="line">  &amp;memp_tab_RAW_PCB</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>就问你屌不屌！😎😎😎😎😎😎😎😎</p>
<p>==<strong>只要代码中有定义多个相同结构体类型的变量的地方，都可以使用这种方式来简化代码。</strong>==</p>
<p>MEMP 类型大全：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RAW_PCB</span><br><span class="line">UDP_PCB</span><br><span class="line">TCP_PCB</span><br><span class="line">TCP_PCB_LISTEN</span><br><span class="line">TCP_SEG</span><br><span class="line">REASSDATA</span><br><span class="line">FRAG_PBUF</span><br><span class="line">NETBUF</span><br><span class="line">NETCONN</span><br><span class="line">TCPIP_MSG_API</span><br><span class="line">API_MSG</span><br><span class="line">DNS_API_MSG</span><br><span class="line">SOCKET_SETGETSOCKOPT_DATA</span><br><span class="line">NETIFAPI_MSG</span><br><span class="line">TCPIP_MSG_INPKT</span><br><span class="line">ARP_QUEUE</span><br><span class="line">IGMP_GROUP</span><br><span class="line">SYS_TIMEOUT</span><br><span class="line">NETDB</span><br><span class="line">LOCALHOSTLIST</span><br><span class="line">ND6_QUEUE</span><br><span class="line">IP6_REASSDATA</span><br><span class="line">MLD6_GROUP</span><br><span class="line">PBUF</span><br><span class="line">PBUF_POOL</span><br></pre></td></tr></table></figure>
<p><strong>PBUF POOL</strong></p>
<p>PBUF POOL是用在网络接口层存储接收到的数据的 pool，一般大小为 pbuf struct + TCP_MSS + IP header + link header。</p>
<h3 id="内存堆"><a href="#内存堆" class="headerlink" title="内存堆"></a>内存堆</h3><p>没什么好讲的了，和一般的堆管理机制大同小异。</p>
<p>mem.c 中的数组变量 ram_heap[MEM_SIZE] 就是分配的堆空间，MEM_SIZE 默认是 1600，用户可在 lwipopts.h 内自定义大小。</p>
<h3 id="使用系统的内存管理"><a href="#使用系统的内存管理" class="headerlink" title="使用系统的内存管理"></a>使用系统的内存管理</h3><p>LwIP 自带的内存池可以提供高效率的分配/回收，自带的内存堆可以避免协议栈内存出现问题时对系统内存的影响。</p>
<p>但在 ARM MCU 平台上，网络性能的瓶颈往往在于内存大小和网络本身，CPU 速度已足够快，内存池和内存堆的效率差别不大，另外，为协议栈单独分配内存堆也会造成内存浪费，所以 LwIP 提供了选项让协议栈全部使用系统的内存管理机制。</p>
<p>定义 MEM_LIBC_MALLOC 为 1 让协议栈使用系统的内存堆，定义 MEMP_MEM_MALLOC 为 1 让协议栈用内存堆来代替内存池[^1]。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * MEM_LIBC_MALLOC&#x3D;&#x3D;1: Use malloc&#x2F;free&#x2F;realloc provided by your C-library</span><br><span class="line"> * instead of the lwip internal allocator. Can save code size if you</span><br><span class="line"> * already use it.</span><br><span class="line"> *&#x2F;</span><br><span class="line">#if !defined MEM_LIBC_MALLOC || defined __DOXYGEN__</span><br><span class="line">#define MEM_LIBC_MALLOC                 0</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * MEMP_MEM_MALLOC&#x3D;&#x3D;1: Use mem_malloc&#x2F;mem_free instead of the lwip pool allocator.</span><br><span class="line"> * Especially useful with MEM_LIBC_MALLOC but handle with care regarding execution</span><br><span class="line"> * speed (heap alloc can be much slower than pool alloc) and usage from interrupts</span><br><span class="line"> * (especially if your netif driver allocates PBUF_POOL pbufs for received frames</span><br><span class="line"> * from interrupt)!</span><br><span class="line"> * ATTENTION: Currently, this uses the heap for ALL pools (also for private pools,</span><br><span class="line"> * not only for internal pools defined in memp_std.h)!</span><br><span class="line"> *&#x2F;</span><br><span class="line">#if !defined MEMP_MEM_MALLOC || defined __DOXYGEN__</span><br><span class="line">#define MEMP_MEM_MALLOC                 0</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>注意：若使用系统的内存管理，那么每类 pool 的个数就用不到了，但是协议栈编译时会做有效性检查，所以还是要定义一个合适的值。</p>
<p>[^1]: ESP32 就是这样做的。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>LwIP 内有大量的全局变量，要保证线程安全地调用协议栈函数，协议栈提供了两种方法：</p>
<ol>
<li>向协议栈守护线程 tcpip_thread 发送 TCPIP_MSG_CALLBACK 消息，让函数在 tcpip_thread 内运行，此时 tcpip_thread 相当于是 worker thread。</li>
<li>用户线程和 tcpip_thread 之间通过一个 core-locking 锁来实现互斥。</li>
<li>通过进/退临界区的方式来实现线程安全。</li>
</ol>
<p>要使用第 2 种方法，要定义 LWIP_TCPIP_CORE_LOCKING 为 1，其实协议栈中默认已经定义为 1 了，LwIP 推荐某些函数使用这种方法来运行，比如 lwip_set/getsockopt，这样的好处是减少资源和时间的消耗。</p>
<p>要使用第 3 种方法，要定义 SYS_ARCH_PROTECT 为 1，并实现 sys_arch_protect 和 sys_arch_unprotect 函数，在 LwIP 中一般是用于 buffer 或 memory 的分配/释放，这样的好处是相对方法 2 速度更快，因为方法 2 内用户函数一定要等待 tcpip_thread 在处理完所有的消息后释放锁后才能运行的，但是缺点是会频繁地开关中断。一个典型的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">  This optional function does a &quot;fast&quot; critical region protection and returns</span><br><span class="line">  the previous protection level. This function is only called during very short</span><br><span class="line">  critical regions. An embedded system which supports ISR-based drivers might</span><br><span class="line">  want to implement this function by disabling interrupts. Task-based systems</span><br><span class="line">  might want to implement this by using a mutex or disabling tasking. This</span><br><span class="line">  function should support recursive calls from the same task or interrupt. In</span><br><span class="line">  other words, sys_arch_protect() could be called while already protected. In</span><br><span class="line">  that case the return value indicates that it is already protected.</span><br><span class="line"></span><br><span class="line">  sys_arch_protect() is only required if your port is supporting an operating</span><br><span class="line">  system.</span><br><span class="line">*&#x2F;</span><br><span class="line">sys_prot_t sys_arch_protect(void)</span><br><span class="line">&#123;</span><br><span class="line">	vPortEnterCritical();</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">  This optional function does a &quot;fast&quot; set of critical region protection to the</span><br><span class="line">  value specified by pval. See the documentation for sys_arch_protect() for</span><br><span class="line">  more information. This function is only required if your port is supporting</span><br><span class="line">  an operating system.</span><br><span class="line">*&#x2F;</span><br><span class="line">void sys_arch_unprotect(sys_prot_t pval)</span><br><span class="line">&#123;</span><br><span class="line">	( void ) pval;</span><br><span class="line">	vPortExitCritical();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>SO_BINDTODEVICE</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>用户调用 gethostbyname 后，发送 callback 消息给 tcpip_thread，先查询缓存内是否已经有了此项，若有则直接返回给用户，若无则发送 dns query 请求。在底层递交一个 UDP 包后，若是 DNS response，则解析并返回给用户。同时维护了一个 timer 以处理超时错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user</span><br><span class="line">⇩</span><br><span class="line">lwip_gethostbyname</span><br><span class="line">⇩</span><br><span class="line">netconn_gethostbyname</span><br><span class="line">⇩</span><br><span class="line">tcpip_callback(lwip_netconn_do_gethostbyname)</span><br><span class="line">⇩                    ⇣</span><br><span class="line">sys_sem_wait          ⇣</span><br><span class="line">⇩                    ⇣</span><br><span class="line">return                ⇣</span><br><span class="line">---------------------------------------- query -------------------------------------------</span><br><span class="line">                      ⇣</span><br><span class="line">tcpip_thread          ⇣</span><br><span class="line">⇩                    ⇣</span><br><span class="line">lwip_netconn_do_gethostbyname</span><br><span class="line">⇩</span><br><span class="line">dns_gethostbyname_addrtype</span><br><span class="line">⇩</span><br><span class="line">dns_lookup ⇨(on found) sys_sem_signal</span><br><span class="line">⇩</span><br><span class="line">dns_enqueue</span><br><span class="line">⇩</span><br><span class="line">dns_check_entry</span><br><span class="line">⇩</span><br><span class="line">dns_send</span><br><span class="line">⇩</span><br><span class="line">udp_sendto</span><br><span class="line">------------------------------------- response -------------------------------------------</span><br><span class="line">udp_input</span><br><span class="line">⇩</span><br><span class="line">dns_recv</span><br><span class="line">⇩</span><br><span class="line">dns_correct_response</span><br><span class="line">⇩</span><br><span class="line">dns_call_found</span><br><span class="line">⇩</span><br><span class="line">lwip_netconn_do_dns_found</span><br><span class="line">⇩</span><br><span class="line">sys_sem_signal</span><br><span class="line">-------------------------------------- timeout -------------------------------------------</span><br><span class="line">tcpip_thread</span><br><span class="line">⇩</span><br><span class="line">(on timer expired)</span><br><span class="line">dns_timer</span><br><span class="line">⇩</span><br><span class="line">dns_tmr</span><br><span class="line">⇩</span><br><span class="line">dns_check_entries</span><br><span class="line">⇩</span><br><span class="line">dns_check_entry</span><br><span class="line">⇩</span><br><span class="line">(on maxium retries)</span><br><span class="line">dns_call_found(NULL)</span><br><span class="line">⇩</span><br><span class="line">lwip_netconn_do_dns_found</span><br><span class="line">⇩</span><br><span class="line">sys_sem_signal</span><br></pre></td></tr></table></figure>

<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>用户线程在调用 gethostbyname 后，就阻塞在一个信号量上。有 3 种情况会 give 信号量：</p>
<ol>
<li>缓冲中已有此项</li>
<li>收到 dns response</li>
<li>超时</li>
</ol>
<h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>其中，dns timer 是 DNS_TMR_INTERVAL，lwip 2.0.2 版本是 1000ms，重试次数是 DNS_MAX_RETRIES，默认是 4，num_dns 默认是 1，所以 dns 超时是 4 秒。</p>
]]></content>
      <categories>
        <category>LwIP</category>
      </categories>
  </entry>
  <entry>
    <title>LwIP 跨线程操作 socket</title>
    <url>/2020/12/09/Network/TCPIP/LwIP/LwIP%20%E8%B7%A8%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%20socket/</url>
    <content><![CDATA[<p><code>tcpip_thread</code>有一个<code>tcpip_mbox</code>用以接收应用层或底层的消息。</p>
<p>每个 socket 对应一个<code>netconn</code>，其中有一个<code>op_completed</code>信号量，用以同步在<code>tcpip_thread</code>中执行的函数。</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netconn</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/** sem that is used to synchronously execute functions in the core context */</span></span><br><span class="line">  <span class="keyword">sys_sem_t</span> op_completed;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用<code>write/read</code>的函数会有一个局部变量<code>apimsg</code>来放执行函数和参数等信息，并通过邮箱<code>tcpip_mbox</code>发送给<code>tcipip_thread</code>，其中包含了<code>netconn</code>的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">api_msg</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/** The netconn which to process - always needed: it includes the semaphore</span></span><br><span class="line"><span class="comment">      which is used to block the application thread until the function finished. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">netconn</span> *<span class="title">conn</span>;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>比如 A 线程调用 write，将自己的 apimsg(A) 的<code>指针</code>发送给<code>tcpip_mbox</code>（注意，是<code>指针</code>），然后 B 线程也调用 write，将自己的 apimsg(B) 的<code>指针</code>发送给<code>tcpip_mbox</code>，<code>tcpip_thread</code>从<code>tcpip_mbox</code>中取出<code>apimsg(A)</code>的指针，执行发送后，给出 semaphore，结果唤醒了 B 线程，B 线程的 write 函数退出后， msg_B 被释放。然后 tcipip_thread 又 pop 出 msg_B 的指针，此时 msg_B 已经内容不对了。</p>
]]></content>
      <categories>
        <category>LwIP</category>
      </categories>
  </entry>
  <entry>
    <title>access_send</title>
    <url>/2020/12/09/SoC/Realtek/RTL8762C/access_send/</url>
    <content><![CDATA[<p>access_send 用以发送 mesh access 层消息，返回值为发送结果。</p>
<h2 id="强制分片"><a href="#强制分片" class="headerlink" title="强制分片"></a>强制分片</h2><p>access_send 参数为<code>mesh_msg_t</code>结构体变量，若将其中<code>seg</code>设为 1，则强制分片发送。</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">mesh_msg_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">uint8_t</span> seg: <span class="number">1</span>; <span class="comment">//!&lt; Transport Segment Flag</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">mesh_msg_t</span>;</span><br></pre></td></tr></table></figure>

<p> 设置为强制分片后，即使短包也会用分片机制来发送，下面是抓包：</p>
<ul>
<li>只有一个 fragment 0</li>
<li>SEG 标志置 1</li>
<li>SegO = SegN = 0</li>
</ul>
<p><img src="/2020/12/09/SoC/Realtek/RTL8762C/access_send/image-20201120141825120.png"></p>
<h2 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h2><p>access_send 是异步的，它将消息 push 进发送队列。若队列已满，则返回<code>MESH_MSG_SEND_CAUSE_TRANS_TX_BUSY</code>错误。</p>
<h2 id="协程处理"><a href="#协程处理" class="headerlink" title="协程处理"></a>协程处理</h2><p>在 mesh thread 中调用 access_send 后不能阻塞此线程，因为后面会从队列中取消息发送出去。</p>
<p><img src="/2020/12/09/SoC/Realtek/RTL8762C/access_send/image-20201124103729555.png"></p>
<p>access_send 不能跨线程调用，否则会影响系统，体现在日志中是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00249  11-19#17:25:07.679  131  [APP] !**MM_GAP_SCHED gap_sched_task_get: fail, task is run out!</span><br></pre></td></tr></table></figure>

<h2 id="发送结果回调"><a href="#发送结果回调" class="headerlink" title="发送结果回调"></a>发送结果回调</h2><p>使用<code>mesh_model_reg</code>注册一个 model</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mesh_model_reg</span><span class="params">(<span class="keyword">uint8_t</span> element_index, mesh_model_info_p pmodel_info)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其参数<code>pmodel_info</code>中包含<code>model_send_cb</code>回调函数指针，指示了消息发送结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">mesh_model_info_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/** provided by application */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> model_id; <span class="comment">//!&lt; being equal or greater than 0xffff0000 means that the model is a sig model.</span></span><br><span class="line">    <span class="comment">/** callback to receive related access msg</span></span><br><span class="line"><span class="comment">        If the model don&#x27;t recognise the access opcode, it should return false! */</span></span><br><span class="line">    model_receive_pf model_receive;</span><br><span class="line">    model_send_cb_pf model_send_cb; <span class="comment">//!&lt; indicates the msg transmitted state</span></span><br><span class="line">    model_pub_cb_pf model_pub_cb; <span class="comment">//!&lt; indicates it is time to publishing</span></span><br><span class="line">    model_data_cb_pf model_data_cb;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">mesh_model_info_t</span>;</span><br></pre></td></tr></table></figure>

<p>此回调函数会传递给上层三个参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*model_send_cb_pf)</span><span class="params">(mesh_model_info_p pmodel_info, <span class="keyword">mesh_msg_send_stat_t</span> stat, <span class="keyword">uint32_t</span> access_opcode)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中<code>stat</code>代表发送的结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** @brief asynchronized callback value after sending a mesh message */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">mesh_msg_send_stat_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    MESH_MSG_SEND_STAT_FAIL,</span><br><span class="line">    MESH_MSG_SEND_STAT_SENT, <span class="comment">//!&lt; unseg access msg</span></span><br><span class="line">    MESH_MSG_SEND_STAT_ACKED, <span class="comment">//!&lt; seg access msg</span></span><br><span class="line">    MESH_MSG_SEND_STAT_ACKED_CANCEL,</span><br><span class="line">    MESH_MSG_SEND_STAT_ACKED_OBO, <span class="comment">//!&lt; seg access msg acked by fn</span></span><br><span class="line">    MESH_MSG_SEND_STAT_ACKED_OBO_CANCEL,</span><br><span class="line">    MESH_MSG_SEND_STAT_TIMEOUT, <span class="comment">//!&lt; seg access msg</span></span><br><span class="line">    MESH_MSG_SEND_STAT_CANCEL <span class="comment">//!&lt; seg msg canceled by myself due to some reasons like seq run out etc.</span></span><br><span class="line">&#125; <span class="keyword">mesh_msg_send_stat_t</span>;</span><br></pre></td></tr></table></figure>

<p>所以我们可以通过注册 model 时的<code>model_send_cb</code>回调来同步发送结果。</p>
]]></content>
      <categories>
        <category>RTL8762C</category>
      </categories>
  </entry>
  <entry>
    <title>Python 实用方法</title>
    <url>/2020/12/09/Programing%20Language/Python/Python%20%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="各种格式转换"><a href="#各种格式转换" class="headerlink" title="各种格式转换"></a>各种格式转换</h2><h3 id="39-0102-39-to-b-39-x01-x02-39"><a href="#39-0102-39-to-b-39-x01-x02-39" class="headerlink" title="&#39;0102&#39;  to  b&#39;\x01\x02&#39;"></a><code>&#39;0102&#39;</code>  to  <code>b&#39;\x01\x02&#39;</code></h3><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bytes.fromhex(&#39;0102&#39;)</span><br><span class="line">b&#39;\x01\x02&#39;</span><br></pre></td></tr></table></figure>

<h3 id="b-39-x01-x02-39-to-39-0102-39"><a href="#b-39-x01-x02-39-to-39-0102-39" class="headerlink" title="b&#39;\x01\x02&#39; to &#39;0102&#39;"></a><code>b&#39;\x01\x02&#39;</code> to <code>&#39;0102&#39;</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b&#39;\x01\x02&#39;.hex()</span><br><span class="line">&#39;0102&#39;</span><br></pre></td></tr></table></figure>

<h3 id="b-39-x01-x02-39-to-1-2"><a href="#b-39-x01-x02-39-to-1-2" class="headerlink" title="b&#39;\x01\x02&#39; to [1, 2]"></a><code>b&#39;\x01\x02&#39;</code> to <code>[1, 2]</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; list(b&#39;\x01\x02&#39;)</span><br><span class="line">[1, 2]</span><br></pre></td></tr></table></figure>

<h3 id="1-2-to-b-39-x01-x02-39"><a href="#1-2-to-b-39-x01-x02-39" class="headerlink" title="[1, 2] to b&#39;\x01\x02&#39;"></a><code>[1, 2]</code> to <code>b&#39;\x01\x02&#39;</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bytes([1, 2])</span><br><span class="line">b&#39;\x01\x02&#39;</span><br></pre></td></tr></table></figure>

<h3 id="b-39-x31-x32-39-to-39-12-39"><a href="#b-39-x31-x32-39-to-39-12-39" class="headerlink" title="b&#39;\x31\x32&#39; to &#39;12&#39;"></a><code>b&#39;\x31\x32&#39;</code> to <code>&#39;12&#39;</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b&#39;\x31\x32&#39;.decode()</span><br><span class="line">&#39;12&#39;</span><br></pre></td></tr></table></figure>

<h3 id="39-12-39-to-b-39-x31-x32-39"><a href="#39-12-39-to-b-39-x31-x32-39" class="headerlink" title="&#39;12&#39; to b&#39;\x31\x32&#39;"></a><code>&#39;12&#39;</code> to <code>b&#39;\x31\x32&#39;</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;12&#39;.encode()</span><br><span class="line">b&#39;\x31\x32&#39;</span><br></pre></td></tr></table></figure>

<h3 id="0x1234-to-b-39-x12-x34-39"><a href="#0x1234-to-b-39-x12-x34-39" class="headerlink" title="0x1234 to b&#39;\x12\x34&#39;"></a><code>0x1234</code> to <code>b&#39;\x12\x34&#39;</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; struct.pack(&#39;&gt;H&#39;,0x1234)</span><br><span class="line">b&#39;\x12\x34&#39;</span><br></pre></td></tr></table></figure>

<p>或者（推荐）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 0x1234</span><br><span class="line">a.to_bytes(2, &#39;big)</span><br></pre></td></tr></table></figure>

<h3 id="b-39-x12-x34-39-to-0x1234"><a href="#b-39-x12-x34-39-to-0x1234" class="headerlink" title="b&#39;\x12\x34&#39; to 0x1234"></a><code>b&#39;\x12\x34&#39;</code> to <code>0x1234</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; struct.unpack(&#39;&gt;H&#39;, b&#39;\x12\x34&#39;)</span><br><span class="line">(4660,)</span><br></pre></td></tr></table></figure>

<p>或者（推荐）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int.from_bytes(b&#39;\x12\x34&#39;, &#39;big&#39;)</span><br></pre></td></tr></table></figure>

<h2 id="中文字符导致的错误"><a href="#中文字符导致的错误" class="headerlink" title="中文字符导致的错误"></a>中文字符导致的错误</h2><p>Python 文件中若存在中文字符，在执行过程会报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SyntaxError: Non-ASCII character &#39;\xe4&#39; in file test.py on line 2, but no encoding declared;</span><br></pre></td></tr></table></figure>

<p>Python中默认的编码格式是 ASCII 格式，在没修改编码格式时无法正确打印汉字，所以在读取中文时会报错。</p>
<p>解决方法为只要在文件开头加入<code># -*- coding: UTF-8 —</code>或者<code>#coding=utf-8</code>就行了。</p>
<h2 id="获取命令行执行结果（成功-失败）"><a href="#获取命令行执行结果（成功-失败）" class="headerlink" title="获取命令行执行结果（成功/失败）"></a>获取命令行执行结果（成功/失败）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">proc &#x3D; subprocess.Popen(&#39;ps aux&#39;, shell&#x3D;True, stdout&#x3D;subprocess.PIPE)</span><br><span class="line">ret &#x3D; proc.wait()</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<p>proc.wait() 返回 0 代表成功，返回 1 代表失败</p>
<hr>
<p>2018-04-06 更新</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>关于 wait，官网文档描述如下：</p>
<blockquote>
<p>Popen.wait(<em>timeout=None</em>)</p>
<p>Wait for child process to terminate. Set and return <a href="https://docs.python.org/3.5/library/subprocess.html#subprocess.Popen.returncode"><code>returncode</code></a> attribute.</p>
<p>If the process does not terminate after <em>timeout</em> seconds, raise a <a href="https://docs.python.org/3.5/library/subprocess.html#subprocess.TimeoutExpired"><code>TimeoutExpired</code></a> exception. It is safe to catch this exception and retry the wait.</p>
<blockquote>
<p>Note</p>
<p>This will deadlock when using <code>stdout=PIPE</code> or <code>stderr=PIPE</code> and the child process generates enough output to a pipe such that it blocks waiting for the OS pipe buffer to accept more data. Use <a href="https://docs.python.org/3.5/library/subprocess.html#subprocess.Popen.communicate"><code>Popen.communicate()</code></a> when using pipes to avoid that.</p>
</blockquote>
<blockquote>
<p>Note</p>
<p>The function is implemented using a busy loop (non-blocking call and short sleeps). Use the <a href="https://docs.python.org/3.5/library/asyncio.html#module-asyncio"><code>asyncio</code></a> module for an asynchronous wait: see <a href="https://docs.python.org/3.5/library/asyncio-subprocess.html#asyncio.create_subprocess_exec"><code>asyncio.create_subprocess_exec</code></a>.</p>
</blockquote>
</blockquote>
<p>也就是说，在 stdout/err 定向到 PIPE 后，若子进程的输出超过了 PIPE 大小，那么就会死等 PIPE 被读取，而此时我们的进程又在 wait 内轮询死等子进程结束，所以就造成了死锁。</p>
<p>wait 其实是频繁的轮询子进程结果，等于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while proc.poll() !&#x3D; None:</span><br><span class="line">	sleep(0.0001)</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/guogaoan/article/details/37034565">https://blog.csdn.net/guogaoan/article/details/37034565</a></p>
<blockquote>
<p>那死锁问题如何避免呢？官方文档里推荐使用 <code>Popen.communicate()</code>。这个方法会把输出放在内存，而不是管道里，所以这时候上限就和内存大小有关了，一般不会有问题。而且如果要获得程序返回值，可以在调用 <code>Popen.communicate()</code> 之后取 <code>Popen.returncode</code> 的值。</p>
<p>结论：如果使用 <code>subprocess.Popen</code>，就不使用 <code>Popen.wait()</code>，而使用 <code>Popen.communicate()</code> 来等待外部程序执行结束。</p>
</blockquote>
<p>wait() 方式来获取结果有个很大的问题，stdout PIPE buffer是 64K，就是当子进程打印超过时就会卡住，此时死锁就产生了，导致 wait() 始终等不到结果，所以用 communicate 最稳妥。</p>
<p>当然，如果不定向 stdou 到 PIPE，死锁就不会发生。</p>
<h3 id="读取stdout"><a href="#读取stdout" class="headerlink" title="读取stdout"></a>读取stdout</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p &#x3D; subprocess.Popen(&quot;dir&quot;, shell&#x3D;True, stdout&#x3D;subprocess.PIPE, stderr&#x3D;subprocess.STDOUT)</span><br><span class="line">while True:</span><br><span class="line">    buff &#x3D; p.stdout.readline()</span><br><span class="line">    if buff &#x3D;&#x3D; &#39;&#39; and p.poll() !&#x3D; None:</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>

<h3 id="stdout-缓冲问题"><a href="#stdout-缓冲问题" class="headerlink" title="stdout 缓冲问题"></a>stdout 缓冲问题</h3><p>2018-04-08 更新</p>
<p><a href="http://blog.sina.com.cn/s/blog_4513dde60100oql9.html">http://blog.sina.com.cn/s/blog_4513dde60100oql9.html</a></p>
<p>PP3E上说过这个问题，说一个程序如果不是以交互的方式运行的话，那么stdout这些都是完全缓冲的，即使设置bufsize也没用，可行的办法是使用pty或者在源码中使用fflush强制flush stdout。</p>
<p>2018-06-24 更新</p>
<p>使用 setbuf 函数关闭 stdout 缓冲区，即可实时输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setbuf(stdout, NULL);</span><br></pre></td></tr></table></figure>

<h2 id="subprocess-Popen-命令类型详解"><a href="#subprocess-Popen-命令类型详解" class="headerlink" title="subprocess.Popen 命令类型详解"></a>subprocess.Popen 命令类型详解</h2><p>参考：<a href="http://www.cnblogs.com/zhoug2020/p/5079407.html">python中的subprocess.Popen使用</a></p>
<p>subprocess模块定义了一个类： Popen</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class subprocess.Popen( args, </span><br><span class="line">      bufsize&#x3D;0, </span><br><span class="line">      executable&#x3D;None,</span><br><span class="line">      stdin&#x3D;None,</span><br><span class="line">      stdout&#x3D;None, </span><br><span class="line">      stderr&#x3D;None, </span><br><span class="line">      preexec_fn&#x3D;None, </span><br><span class="line">      close_fds&#x3D;False, </span><br><span class="line">      shell&#x3D;False, </span><br><span class="line">      cwd&#x3D;None, </span><br><span class="line">      env&#x3D;None, </span><br><span class="line">      universal_newlines&#x3D;False, </span><br><span class="line">      startupinfo&#x3D;None, </span><br><span class="line">      creationflags&#x3D;0)</span><br></pre></td></tr></table></figure>

<p>args参数。可以是一个字符串，可以是一个包含程序参数的列表。要执行的程序一般就是这个列表的第一项，或者是字符串本身。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subprocess.Popen([&quot;cat&quot;,&quot;test.txt&quot;])</span><br><span class="line">subprocess.Popen(&quot;cat test.txt&quot;)</span><br></pre></td></tr></table></figure>

<p>这两个之中，后者将不会工作。因为如果是一个字符串的话，必须是程序的路径才可以。(考虑unix的api函数exec，接受的是字符串<br>列表)</p>
<p>但是下面的可以工作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subprocess.Popen(&quot;cat test.txt&quot;, shell&#x3D;True)</span><br></pre></td></tr></table></figure>

<p>这是因为它相当于<br>subprocess.Popen([“/bin/sh”, “-c”, “cat test.txt”])<br>在*nix下，当shell=False（默认）时，Popen使用os.execvp()来执行子程序。args一般要是一个【列表】。如果args是个字符串的<br>话，会被当做是可执行文件的路径，这样就不能传入任何参数了。</p>
<p>在Windows下，下面的却又是可以工作的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subprocess.Popen([&quot;notepad.exe&quot;, &quot;test.txt&quot;])</span><br><span class="line">subprocess.Popen(&quot;notepad.exe test.txt&quot;)</span><br></pre></td></tr></table></figure>

<p>这是由于windows下的api函数CreateProcess接受的是一个字符串。即使是列表形式的参数，也需要先合并成字符串再传递给api函数<br><code>subprocess.Popen(&quot;notepad.exe test.txt&quot; shell=True)</code><br>等同于<br><code>subprocess.Popen(&quot;cmd.exe /C &quot;+&quot;notepad.exe test.txt&quot; shell=True</code></p>
<h2 id="subprocess-run"><a href="#subprocess-run" class="headerlink" title="subprocess.run"></a>subprocess.run</h2><p>官方推荐尽量使用 run 方法，如果需要更底层的才使用 Popen</p>
<p><a href="https://docs.python.org/3.5/library/subprocess.html#subprocess.run">https://docs.python.org/3.5/library/subprocess.html#subprocess.run</a></p>
<blockquote>
<p>The recommended approach to invoking subprocesses is to use the <a href="https://docs.python.org/3.5/library/subprocess.html#subprocess.run"><code>run()</code></a> function for all use cases it can handle. For more advanced use cases, the underlying <a href="https://docs.python.org/3.5/library/subprocess.html#subprocess.Popen"><code>Popen</code></a> interface can be used directly.</p>
</blockquote>
<p>其实 run 是对 Popen 和 communicate 以及结果检查的封装</p>
<h2 id="遍历文件夹-os-walk"><a href="#遍历文件夹-os-walk" class="headerlink" title="遍历文件夹 - os.walk"></a>遍历文件夹 - os.walk</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (root,dirs,files) in os.walk(&#39;firmware&#39;):</span><br><span class="line">	print(root, dirs, files)</span><br></pre></td></tr></table></figure>

<h2 id="使用国内源来-pip-install"><a href="#使用国内源来-pip-install" class="headerlink" title="使用国内源来 pip install"></a>使用国内源来 pip install</h2><p><a href="https://www.cnblogs.com/microman/p/6107879.html">https://www.cnblogs.com/microman/p/6107879.html</a></p>
<p>pip install 默认使用国外源来安装库，但有时奇慢无比，切换到国内源会快很多。</p>
<p>国内源：</p>
<p>新版ubuntu要求使用https源，要注意。</p>
<p>清华：<a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<p>阿里云：<a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a></p>
<p>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a></p>
<p>华中理工大学：<a href="http://pypi.hustunique.com/">http://pypi.hustunique.com/</a></p>
<p>山东理工大学：<a href="http://pypi.sdutlinux.org/">http://pypi.sdutlinux.org/</a> </p>
<p>豆瓣：<a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a></p>
<p>临时使用：</p>
<p>可以在使用pip的时候加参数-i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a><br>例如：pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> pyspider，这样就会从清华这边的镜像去安装pyspider库。</p>
<p>永久修改：</p>
<p>Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host&#x3D;mirrors.aliyun.com</span><br></pre></td></tr></table></figure>

<p>windows下，直接在user目录中创建一个pip目录，如：C:\Users\xx\pip，新建文件pip.ini。内容同上。</p>
<h2 id="用-pyinstaller-打包-python-脚本到可执行文件"><a href="#用-pyinstaller-打包-python-脚本到可执行文件" class="headerlink" title="用 pyinstaller 打包 python 脚本到可执行文件"></a>用 pyinstaller 打包 python 脚本到可执行文件</h2><p><a href="https://jingyan.baidu.com/article/a378c960b47034b3282830bb.html">https://jingyan.baidu.com/article/a378c960b47034b3282830bb.html</a></p>
<p>安装 pyinstaller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install pyinstaller</span><br></pre></td></tr></table></figure>

<p>打包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyinstaller -F your.py</span><br></pre></td></tr></table></figure>

<p><strong>注意：用 -D 来打包到一个目录，运行速度会比 -F 打包到一个 .exe 快。</strong></p>
<h2 id="用-spec-files-打包"><a href="#用-spec-files-打包" class="headerlink" title="用 spec files 打包"></a>用 spec files 打包</h2><p><a href="https://pyinstaller.readthedocs.io/en/v3.3.1/spec-files.html">https://pyinstaller.readthedocs.io/en/v3.3.1/spec-files.html</a></p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyinstaller master.spec</span><br></pre></td></tr></table></figure>

<h2 id="打包资源文件"><a href="#打包资源文件" class="headerlink" title="打包资源文件"></a>打包资源文件</h2><p><a href="https://pythonhosted.org/PyInstaller/runtime-information.html#run-time-information">https://pythonhosted.org/PyInstaller/runtime-information.html#run-time-information</a></p>
<p><a href="https://pythonhosted.org/PyInstaller/operating-mode.html#how-the-one-file-program-works">https://pythonhosted.org/PyInstaller/operating-mode.html#how-the-one-file-program-works</a></p>
<p>有时需要打包一些资源文件，比如图片，音乐，或者可执行文件，需要用 —add-data 选项。</p>
<p>需要注意的是，打包后的可执行文件的工作原理其实是在 /tmp 目录下创建了临时工作文件夹 __MEI<em>xxxxxx</em> ，</p>
<p>资源文件都是放在此文件夹内的，所以脚本中使用资源文件就必须使用此临时文件夹的路径：<code>sys._MEIPASS</code></p>
<h2 id="Pyinstaller-和-import"><a href="#Pyinstaller-和-import" class="headerlink" title="Pyinstaller 和 __import__"></a>Pyinstaller 和 __import__</h2><p><code>__import__</code>可以动态导入模块，在用 pyinstaller 打包时，要把所有可能被导入的模块用 –hidden-import 选项加入进去，否则打包的程序运行时会找不到这些模块。</p>
<h2 id="pip-查看已经安装的包及路径"><a href="#pip-查看已经安装的包及路径" class="headerlink" title="pip 查看已经安装的包及路径"></a>pip 查看已经安装的包及路径</h2><p><a href="http://me.iblogc.com/2015/01/01/pip%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">pip常用命令</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">显示包所在的目录</span><br><span class="line"></span><br><span class="line">pip show -f &lt;包名&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Pycharm-PyQt5-Qt5-开发"><a href="#Pycharm-PyQt5-Qt5-开发" class="headerlink" title="Pycharm + PyQt5 + Qt5 开发"></a>Pycharm + PyQt5 + Qt5 开发</h2><h3 id="安装-pyqt5"><a href="#安装-pyqt5" class="headerlink" title="安装 pyqt5"></a>安装 pyqt5</h3><p><a href="https://www.zhihu.com/question/51562598">https://www.zhihu.com/question/51562598</a></p>
<p>用 pip 来安装 pyqt5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install pyqt5</span><br></pre></td></tr></table></figure>

<h3 id="安装-Qt5"><a href="#安装-Qt5" class="headerlink" title="安装 Qt5"></a>安装 Qt5</h3><p><a href="http://download.qt.io/official_releases/qt/">http://download.qt.io/official_releases/qt/</a></p>
<p>下载 5.10.1 版本</p>
<h3 id="配置-PyCharm"><a href="#配置-PyCharm" class="headerlink" title="配置 PyCharm"></a>配置 PyCharm</h3><p><a href="http://gavinliu.cn/2016/01/17/Python-Mac%E4%B8%8BPyCharm-PyQt5%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">Python - Mac下PyQt5环境搭建</a></p>
<h3 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h3><p><a href="https://blog.csdn.net/zhulove86/article/details/52530214">https://blog.csdn.net/zhulove86/article/details/52530214</a></p>
<p><a href="https://blog.csdn.net/a359680405/article/details/45148717">https://blog.csdn.net/a359680405/article/details/45148717</a></p>
<h3 id="子线程操作-UI"><a href="#子线程操作-UI" class="headerlink" title="子线程操作 UI"></a>子线程操作 UI</h3><p><a href="https://www.zhihu.com/question/37334646">为什么大多数程序子线程都不能刷新UI？</a></p>
<p><a href="https://blog.csdn.net/AhdaiMolly/article/details/74376525">https://blog.csdn.net/AhdaiMolly/article/details/74376525</a></p>
<p><a href="https://www.2cto.com/kf/201703/608163.html">https://www.2cto.com/kf/201703/608163.html</a></p>
<p><a href="https://www.v2ex.com/t/346882">https://www.v2ex.com/t/346882</a></p>
<blockquote>
<p>signal = pyqtSignal(str)<br>signal.connect(update) # Main thread<br>signal.emit(value) # sub thread</p>
</blockquote>
<p>UI 线程和 worker 线程之间只能通过 signal 来通信</p>
<p>worker 线程通过 emit signal 来操作 UI。</p>
<p>UI 线程通过 signal connect 的函数来实现回调。</p>
<h3 id="去除标题栏"><a href="#去除标题栏" class="headerlink" title="去除标题栏"></a>去除标题栏</h3><p><a href="https://www.cnblogs.com/codeAB/p/5019439.html">https://www.cnblogs.com/codeAB/p/5019439.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QWidget.setWindowFlags(Qt.FramelessWindowHint)</span><br></pre></td></tr></table></figure>

<h3 id="全屏"><a href="#全屏" class="headerlink" title="全屏"></a>全屏</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QWidget.showFullScreen()</span><br></pre></td></tr></table></figure>

<h3 id="BOX-layout-和-Grid-layout"><a href="#BOX-layout-和-Grid-layout" class="headerlink" title="BOX layout 和 Grid layout"></a>BOX layout 和 Grid layout</h3><h3 id="QThread"><a href="#QThread" class="headerlink" title="QThread"></a>QThread</h3><p>最好不要用 QThread</p>
<p><a href="http://hgoldfish.com/blogs/article/80/">http://hgoldfish.com/blogs/article/80/</a></p>
<p><a href="http://www.hgoldfish.com/blogs/article/97/">http://www.hgoldfish.com/blogs/article/97/</a></p>
<h3 id="Progress-bar"><a href="#Progress-bar" class="headerlink" title="Progress bar"></a>Progress bar</h3><p>Progress bar 的高度是由字体决定的</p>
<h3 id="鼠标双击事件"><a href="#鼠标双击事件" class="headerlink" title="鼠标双击事件"></a>鼠标双击事件</h3><p><a href="https://blog.csdn.net/dxt1107/article/details/47806965">https://blog.csdn.net/dxt1107/article/details/47806965</a></p>
<p>为了响应双击QLabel的事件，需要重写QWidget的mouseDoubleClickEvent方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from PyQt4.QtGui import *</span><br><span class="line">from PyQt4.QtCore import *</span><br><span class="line">from PyQt4 import *</span><br><span class="line">class MyLabel(QtGui.QLabel):</span><br><span class="line">    def __init__(self,parent&#x3D;None):</span><br><span class="line">        super(MyLabel,self).__init__(parent)</span><br><span class="line">    def mouseDoubleClickEvent(self,e):</span><br><span class="line">        print &#39;mouse double clicked&#39;   </span><br><span class="line">    def mousePressEvent(self,e):</span><br><span class="line">        print &#39;mousePressEvent&#39;</span><br><span class="line">    def focusInEvent(self,e):</span><br><span class="line">        print &#39;focusInEvent&#39;</span><br><span class="line">    def focusOutEvent(self,e):</span><br><span class="line">        print &#39;focusOutEvent&#39;</span><br><span class="line">    def moveEvent(self,e):</span><br><span class="line">        print &#39;moveEvent&#39;</span><br><span class="line">    def leaveEvent(self,e): #鼠标离开label</span><br><span class="line">        print &#39;leaveEvent&#39;</span><br><span class="line">    def enterEvent(self,e): #鼠标移入label</span><br><span class="line">        print &#39;enterEvent&#39;</span><br><span class="line">    def mouseMoveEvent(self,e):</span><br><span class="line">        print &#39;mouseMoveEvent&#39;</span><br><span class="line"> </span><br><span class="line">class TestDialog(QtGui.QDialog):</span><br><span class="line">    def __init__(self,parent&#x3D;None):</span><br><span class="line">        super(TestDialog,self).__init__(parent)</span><br><span class="line">        self.statusLabel &#x3D; MyLabel(self)</span><br><span class="line">        self.statusLabel.setGeometry(QtCore.QRect(95, 220, 151, 41))</span><br><span class="line">        self.statusLabel.setText(&quot;hello label&quot;)</span><br><span class="line"> </span><br><span class="line">app&#x3D;QApplication(sys.argv)</span><br><span class="line">dialog&#x3D;TestDialog()</span><br><span class="line">dialog.show()</span><br></pre></td></tr></table></figure>

<h3 id="PyQt5-Qt-designer-开发"><a href="#PyQt5-Qt-designer-开发" class="headerlink" title="PyQt5 + Qt designer 开发"></a>PyQt5 + Qt designer 开发</h3><p><a href="https://blog.csdn.net/chlk118/article/details/72595325">https://blog.csdn.net/chlk118/article/details/72595325</a></p>
<p><a href="https://blog.csdn.net/yy123xiang/article/details/78681669">https://blog.csdn.net/yy123xiang/article/details/78681669</a></p>
<p>用 Qt designer 生成的 .ui 文件，无需转换成 .py 文件，可以直接用 PyQt5.uic.loadUi 方法来加载。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from PyQt5.QtWidgets import QApplication, QMainWindow</span><br><span class="line">from PyQt5.uic import loadUi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MainWindow(QMainWindow):</span><br><span class="line">    def __init__(self, parent&#x3D;None):</span><br><span class="line">        super(MainWindow, self).__init__(parent)</span><br><span class="line">        loadUi(&#39;pyflashloader_isp.ui&#39;, self)</span><br><span class="line">        self.setFixedSize(self.sizeHint())</span><br><span class="line"></span><br><span class="line">app &#x3D; QApplication(sys.argv)</span><br><span class="line">w &#x3D; MainWindow()</span><br><span class="line">w.show()</span><br><span class="line">sys.exit(app.exec())</span><br></pre></td></tr></table></figure>

<h3 id="文件打开保存框"><a href="#文件打开保存框" class="headerlink" title="文件打开保存框"></a>文件打开保存框</h3><p><a href="https://blog.csdn.net/a359680405/article/details/45166271">https://blog.csdn.net/a359680405/article/details/45166271</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from PyQt5 import QtWidgets</span><br><span class="line">from PyQt5.QtWidgets import QFileDialog</span><br><span class="line"></span><br><span class="line">class MyWindow(QtWidgets.QWidget):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(MyWindow,self).__init__()</span><br><span class="line">        self.myButton &#x3D; QtWidgets.QPushButton(self)</span><br><span class="line">        self.myButton.setObjectName(&quot;myButton&quot;)</span><br><span class="line">        self.myButton.setText(&quot;Test&quot;)</span><br><span class="line">        self.myButton.clicked.connect(self.msg)</span><br><span class="line"></span><br><span class="line">    def msg(self):</span><br><span class="line">        directory1 &#x3D; QFileDialog.getExistingDirectory(self,</span><br><span class="line">                                    &quot;选取文件夹&quot;,</span><br><span class="line">                                    &quot;C:&#x2F;&quot;)                                 #起始路径</span><br><span class="line">        print(directory1)</span><br><span class="line"></span><br><span class="line">        fileName1, filetype &#x3D; QFileDialog.getOpenFileName(self,</span><br><span class="line">                                    &quot;选取文件&quot;,</span><br><span class="line">                                    &quot;C:&#x2F;&quot;,</span><br><span class="line">                                    &quot;All Files (*);;Text Files (*.txt)&quot;)   #设置文件扩展名过滤,注意用双分号间隔</span><br><span class="line">        print(fileName1,filetype)</span><br><span class="line"></span><br><span class="line">        files, ok1 &#x3D; QFileDialog.getOpenFileNames(self,</span><br><span class="line">                                    &quot;多文件选择&quot;,</span><br><span class="line">                                    &quot;C:&#x2F;&quot;,</span><br><span class="line">                                    &quot;All Files (*);;Text Files (*.txt)&quot;)</span><br><span class="line">        print(files,ok1)</span><br><span class="line"></span><br><span class="line">        fileName2, ok2 &#x3D; QFileDialog.getSaveFileName(self,</span><br><span class="line">                                    &quot;文件保存&quot;,</span><br><span class="line">                                    &quot;C:&#x2F;&quot;,</span><br><span class="line">                                    &quot;All Files (*);;Text Files (*.txt)&quot;)</span><br><span class="line"></span><br><span class="line">if __name__&#x3D;&#x3D;&quot;__main__&quot;:  </span><br><span class="line">    import sys  </span><br><span class="line">  </span><br><span class="line">    app&#x3D;QtWidgets.QApplication(sys.argv)  </span><br><span class="line">    myshow&#x3D;MyWindow()</span><br><span class="line">    myshow.show()</span><br><span class="line">    sys.exit(app.exec_())  </span><br></pre></td></tr></table></figure>

<h3 id="QWidget-背景透明"><a href="#QWidget-背景透明" class="headerlink" title="QWidget 背景透明"></a>QWidget 背景透明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.setWindowFlag(Qt.FramelessWindowHint)</span><br><span class="line">self.setStyleSheet(&#39;background_color:rgba(255,255,255,128)&#39;)</span><br></pre></td></tr></table></figure>

<p>其中 FramelessWindowHint 是必须的，没有这个 Flag，背景就不是透明的。</p>
<h3 id="PushButton-对齐边界"><a href="#PushButton-对齐边界" class="headerlink" title="PushButton 对齐边界"></a>PushButton 对齐边界</h3><p>PushButton 比较奇怪，放在布局内也会超出一截造成不对齐，所以要单独放在一个布局内，再放入布局内。</p>
<p>比如，先把 pushbutton 放在 vertical layout 内，然后再放在 Grid layout 内，就边界对齐了。</p>
<h2 id="获取本机-MAC-地址"><a href="#获取本机-MAC-地址" class="headerlink" title="获取本机 MAC 地址"></a>获取本机 MAC 地址</h2><p><a href="https://www.cnblogs.com/chenjingyi/p/5741742.html">https://www.cnblogs.com/chenjingyi/p/5741742.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import uuid</span><br><span class="line">def get_mac_address(): </span><br><span class="line">    mac&#x3D;uuid.UUID(int &#x3D; uuid.getnode()).hex[-12:] </span><br><span class="line">    return &quot;:&quot;.join([mac[e:e+2] for e in range(0,11,2)])</span><br></pre></td></tr></table></figure>

<p>需要注意的是，多网卡的机器，此方法返回的 MAC 可能不是固定的。</p>
<h2 id="AES-加密"><a href="#AES-加密" class="headerlink" title="AES 加密"></a>AES 加密</h2><p>安装 Crypto 库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install pycrypto</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/nurke/article/details/77267081">https://blog.csdn.net/nurke/article/details/77267081</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding: utf8</span><br><span class="line">import sys</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">from binascii import b2a_hex, a2b_hex</span><br><span class="line"> </span><br><span class="line">class prpcrypt():</span><br><span class="line">    def __init__(self, key):</span><br><span class="line">        self.key &#x3D; key</span><br><span class="line">        self.mode &#x3D; AES.MODE_CBC</span><br><span class="line">     </span><br><span class="line">    #加密函数，如果text不是16的倍数【加密文本text必须为16的倍数！】，那就补足为16的倍数</span><br><span class="line">    def encrypt(self, text):</span><br><span class="line">        cryptor &#x3D; AES.new(self.key, self.mode, self.key)</span><br><span class="line">        #这里密钥key 长度必须为16（AES-128）、24（AES-192）、或32（AES-256）Bytes 长度.目前AES-128足够用</span><br><span class="line">        length &#x3D; 16</span><br><span class="line">        count &#x3D; len(text)</span><br><span class="line">	if(count % length !&#x3D; 0) :</span><br><span class="line">        	add &#x3D; length - (count % length)</span><br><span class="line">	else:</span><br><span class="line">		add &#x3D; 0</span><br><span class="line">        text &#x3D; text + (&#39;\0&#39; * add)</span><br><span class="line">        self.ciphertext &#x3D; cryptor.encrypt(text)</span><br><span class="line">        #因为AES加密时候得到的字符串不一定是ascii字符集的，输出到终端或者保存时候可能存在问题</span><br><span class="line">        #所以这里统一把加密后的字符串转化为16进制字符串</span><br><span class="line">        return b2a_hex(self.ciphertext)</span><br><span class="line">     </span><br><span class="line">    #解密后，去掉补足的空格用strip() 去掉</span><br><span class="line">    def decrypt(self, text):</span><br><span class="line">        cryptor &#x3D; AES.new(self.key, self.mode, self.key)</span><br><span class="line">        plain_text &#x3D; cryptor.decrypt(a2b_hex(text))</span><br><span class="line">        return plain_text.rstrip(&#39;\0&#39;)</span><br><span class="line"> </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    pc &#x3D; prpcrypt(&#39;keyskeyskeyskeys&#39;)      #初始化密钥</span><br><span class="line">    e &#x3D; pc.encrypt(&quot;0123456789ABCDEF&quot;)</span><br><span class="line">    d &#x3D; pc.decrypt(e)                     </span><br><span class="line">    print e, d</span><br><span class="line">    e &#x3D; pc.encrypt(&quot;00000000000000000000000000&quot;)</span><br><span class="line">    d &#x3D; pc.decrypt(e)                  </span><br><span class="line">    print e, d</span><br></pre></td></tr></table></figure>

<h2 id="HASH-算法"><a href="#HASH-算法" class="headerlink" title="HASH 算法"></a>HASH 算法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import hashlib</span><br><span class="line">&gt;&gt;&gt; hashlib.sha256(&#39;123456789&#39;.encode()).hexdigest()</span><br><span class="line">&#39;15e2b0d3c33891ebb0f1ef609ec419420c20e320ce94c65fbc8c3312448eb225&#39;</span><br></pre></td></tr></table></figure>

<h2 id="程序退出-sys-exit-status"><a href="#程序退出-sys-exit-status" class="headerlink" title="程序退出 sys.exit(status)"></a>程序退出 sys.exit(status)</h2><p><a href="https://www.cnblogs.com/weiman3389/p/6047062.html">https://www.cnblogs.com/weiman3389/p/6047062.html</a></p>
<p>sys.exit(status) 的参数 status 就是此代码的执行结果，可以用 subprocess 来捕捉。</p>
<h2 id="移动-删除文件"><a href="#移动-删除文件" class="headerlink" title="移动/删除文件"></a>移动/删除文件</h2><p><a href="https://blog.csdn.net/woshisangsang/article/details/74360612">https://blog.csdn.net/woshisangsang/article/details/74360612</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#文件、文件夹的移动、复制、删除、重命名</span><br><span class="line"></span><br><span class="line">#导入shutil模块和os模块</span><br><span class="line">import shutil,os</span><br><span class="line"></span><br><span class="line">#复制单个文件</span><br><span class="line">shutil.copy(&quot;C:\\a\\1.txt&quot;,&quot;C:\\b&quot;)</span><br><span class="line">#复制并重命名新文件</span><br><span class="line">shutil.copy(&quot;C:\\a\\2.txt&quot;,&quot;C:\\b\\121.txt&quot;)</span><br><span class="line">#复制整个目录(备份)</span><br><span class="line">shutil.copytree(&quot;C:\\a&quot;,&quot;C:\\b\\new_a&quot;)</span><br><span class="line"></span><br><span class="line">#删除文件</span><br><span class="line">os.unlink(&quot;C:\\b\\1.txt&quot;)</span><br><span class="line">os.unlink(&quot;C:\\b\\121.txt&quot;)</span><br><span class="line">#删除空文件夹</span><br><span class="line">try:</span><br><span class="line">    os.rmdir(&quot;C:\\b\\new_a&quot;)</span><br><span class="line">except Exception as ex:</span><br><span class="line">    print(&quot;错误信息：&quot;+str(ex))#提示：错误信息，目录不是空的</span><br><span class="line">#删除文件夹及内容</span><br><span class="line">shutil.rmtree(&quot;C:\\b\\new_a&quot;)</span><br><span class="line"></span><br><span class="line">#移动文件</span><br><span class="line">shutil.move(&quot;C:\\a\\1.txt&quot;,&quot;C:\\b&quot;)</span><br><span class="line">#移动文件夹</span><br><span class="line">shutil.move(&quot;C:\\a\\c&quot;,&quot;C:\\b&quot;)</span><br><span class="line"></span><br><span class="line">#重命名文件</span><br><span class="line">shutil.move(&quot;C:\\a\\2.txt&quot;,&quot;C:\\a\\new2.txt&quot;)</span><br><span class="line">#重命名文件夹</span><br><span class="line">shutil.move(&quot;C:\\a\\d&quot;,&quot;C:\\a\\new_d&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="threading"><a href="#threading" class="headerlink" title="threading"></a>threading</h2><p>daemon</p>
<p><a href="https://www.cnblogs.com/xfiver/p/5189732.html">https://www.cnblogs.com/xfiver/p/5189732.html</a></p>
<h2 id="获取本机-IP-地址"><a href="#获取本机-IP-地址" class="headerlink" title="获取本机 IP 地址"></a>获取本机 IP 地址</h2><p><a href="https://blog.csdn.net/weixin_40539892/article/details/79103254">https://blog.csdn.net/weixin_40539892/article/details/79103254</a></p>
<p>这个方法是目前见过最优雅获取本机服务器的IP方法了。没有任何的依赖，也没有去猜测机器上的网络设备信息。</p>
<p>而且是利用 UDP 协议来实现的，生成一个UDP包，把自己的 IP 放如到 UDP 协议头中，然后从UDP包中获取本机的IP。</p>
<p>这个方法并不会真实的向外部发包，所以用抓包工具是看不到的。但是会申请一个 UDP 的端口，所以如果经常调用也会比较耗时的，这里如果需要可以将查询到的IP给缓存起来，性能可以获得很大提升。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在 shell 中可以一行调用，获取到本机IP</span><br><span class="line">python -c &quot;import socket;print([(s.connect((&#39;8.8.8.8&#39;, 53)), s.getsockname()[0], s.close()) for s in [socket.socket(socket.AF_INET, socket.SOCK_DGRAM)]][0][1])&quot;</span><br><span class="line">10.12.189.16</span><br><span class="line"># 可以封装成函数，方便 Python 的程序调用</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line">def get_host_ip():</span><br><span class="line">    try:</span><br><span class="line">        s &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">        s.connect((&#39;8.8.8.8&#39;, 80))</span><br><span class="line">        ip &#x3D; s.getsockname()[0]</span><br><span class="line">    finally:</span><br><span class="line">        s.close()</span><br><span class="line"></span><br><span class="line">    return ip</span><br></pre></td></tr></table></figure>
<h2 id="requests-加了-timeout-为啥还是会卡住？"><a href="#requests-加了-timeout-为啥还是会卡住？" class="headerlink" title="requests 加了 timeout 为啥还是会卡住？"></a>requests 加了 timeout 为啥还是会卡住？</h2><p><a href="https://www.v2ex.com/amp/t/365351">https://www.v2ex.com/amp/t/365351</a></p>
<blockquote>
<p>conn = request.urlopen(image_url,timeout=300)</p>
<p>请问有啥优化的办法么？</p>
<p>爬虫爬了 24 小时卡住了。。 重启启动以后又继续爬了</p>
<hr>
<p>requests 文档上有写<br>Note<br>timeout is not a time limit on the entire response download; rather, an exception is raised if the server has not issued a response for timeout seconds (more precisely, if no bytes have been received on the underlying socket for timeout seconds). If no timeout is specified explicitly, requests do not time out. </p>
<p>在最开始加一个<br>import socket<br>socket.setdefaulttimeout(时间)<br>就可以了</p>
</blockquote>
<h2 id="Python脚本生成的exe文件自动升级程序实现方法"><a href="#Python脚本生成的exe文件自动升级程序实现方法" class="headerlink" title="Python脚本生成的exe文件自动升级程序实现方法"></a>Python脚本生成的exe文件自动升级程序实现方法</h2><p><a href="https://blog.csdn.net/u013193899/article/details/78686039">https://blog.csdn.net/u013193899/article/details/78686039</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">import subprocess </span><br><span class="line"></span><br><span class="line">#编写bat脚本，删除旧程序，运行新程序</span><br><span class="line">def WriteRestartCmd(exe_name):</span><br><span class="line">    b &#x3D; open(&quot;upgrade.bat&quot;,&#39;w&#39;)</span><br><span class="line">    TempList &#x3D; &quot;@echo off\n&quot;;   #关闭bat脚本的输出</span><br><span class="line">    TempList +&#x3D; &quot;if not exist &quot;+exe_name+&quot; exit \n&quot;;    #新文件不存在,退出脚本执行</span><br><span class="line">    TempList +&#x3D; &quot;sleep 3\n&quot; #3秒后删除旧程序（3秒后程序已运行结束，不延时的话，会提示被占用，无法删除）</span><br><span class="line">    TempList +&#x3D; &quot;del &quot;+ os.path.realpath(sys.argv[0]) + &quot;\n&quot;    #删除当前文件</span><br><span class="line">    TempList +&#x3D; &quot;start &quot; + exe_name     #启动新程序</span><br><span class="line">    b.write(TempList)</span><br><span class="line">    b.close()</span><br><span class="line">    subprocess.Popen(&quot;upgrade.bat&quot;)</span><br><span class="line">    sys.exit()  #进行升级，退出此程序</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">#新程序启动时，删除旧程序制造的脚本</span><br><span class="line">    if os.path.isfile(&quot;upgrade.bat&quot;):</span><br><span class="line">        os.remove(&quot;upgrade.bat&quot;)</span><br><span class="line">    WriteRestartCmd(&quot;newVersion.exe&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br><span class="line">    sys.exit()1234567891011121314151617181920212223242526</span><br></pre></td></tr></table></figure>

<p>代码中不使用os.system()是因为 这个函数会阻塞，等待bat脚本操作完成后，才会继续执行。不适合此处场景</p>
<h2 id="搭建-Flask-服务系统"><a href="#搭建-Flask-服务系统" class="headerlink" title="搭建 Flask 服务系统"></a>搭建 Flask 服务系统</h2><p>pip3 install 安装如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flask&#x3D;&#x3D;0.12.2</span><br><span class="line">Flask-Migrate&#x3D;&#x3D;2.1.1</span><br><span class="line">Flask-Script&#x3D;&#x3D;2.0.6</span><br><span class="line">Flask-SQLAlchemy&#x3D;&#x3D;2.3.2</span><br><span class="line">Flask-Uploads&#x3D;&#x3D;0.2.1</span><br><span class="line">Flask-WTF&#x3D;&#x3D;0.14.2</span><br></pre></td></tr></table></figure>

<h2 id="stdout-缓冲区问题"><a href="#stdout-缓冲区问题" class="headerlink" title="stdout 缓冲区问题"></a>stdout 缓冲区问题</h2><p>有时候 print 并不能实时打印出来，这时有两种方法：</p>
<ol>
<li><p>在 print 后加 sys.stdout.flush()</p>
</li>
<li><p>加个 python 选项 -u</p>
<p><strong>-u **Force stdin, stdout and stderr to be totally **unbuffered</strong>.  On systems where it matters, also put stdin,  stdout  and  stderr  in</p>
</li>
</ol>
<p><a href="https://blog.csdn.net/joeblackzqq/article/details/7220009">https://blog.csdn.net/joeblackzqq/article/details/7220009</a></p>
<p>使用 Pyinstaller 打包时，可以在 .spec 的 options 内加入 -u 选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">options &#x3D; [ (&#39;u&#39;, None, &#39;OPTION&#39;), ]</span><br></pre></td></tr></table></figure>

<p><a href="http://pyinstaller.readthedocs.io/en/v3.3.1/spec-files.html?highlight=-u">http://pyinstaller.readthedocs.io/en/v3.3.1/spec-files.html?highlight=-u</a></p>
<h2 id="Python-中-SSH-登录以及-SCP-传输文件"><a href="#Python-中-SSH-登录以及-SCP-传输文件" class="headerlink" title="Python 中 SSH 登录以及 SCP 传输文件"></a>Python 中 SSH 登录以及 SCP 传输文件</h2><p><strong>使用 paramiko 库来登录 SSH，使用 scp 来传输文件</strong></p>
<p><a href="http://www.cnblogs.com/haigege/p/5513759.html">http://www.cnblogs.com/haigege/p/5513759.html</a></p>
<p><a href="http://blog.51cto.com/5ydycm/340854">http://blog.51cto.com/5ydycm/340854</a></p>
<p><a href="http://docs.paramiko.org/en/2.4/">http://docs.paramiko.org/en/2.4/</a></p>
<p><a href="https://pypi.org/project/scp">https://pypi.org/project/scp</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import paramiko</span><br><span class="line">from scp import SCPClient</span><br><span class="line"></span><br><span class="line">ssh &#x3D; paramiko.SSHClient()</span><br><span class="line">ssh.set_missing_host_key_policy(paramiko.client.MissingHostKeyPolicy)</span><br><span class="line">ssh.connect(&#39;192.168.3.40&#39;, username&#x3D;&#39;pi&#39;, password&#x3D;&#39;snowyang&#39;, timeout&#x3D;2)</span><br><span class="line"></span><br><span class="line">with SCPClient(ssh.get_transport()) as scp:</span><br><span class="line">    scp.get(&#39;&#x2F;home&#x2F;pi&#x2F;mx1290prog&#x2F;master.log&#39;, &#39;40.log&#39;)</span><br></pre></td></tr></table></figure>

<h2 id="GitPython"><a href="#GitPython" class="headerlink" title="GitPython"></a>GitPython</h2><p><a href="https://www.cnblogs.com/baiyangcao/p/gitpython.html">https://www.cnblogs.com/baiyangcao/p/gitpython.html</a></p>
<p><a href="http://gitpython.readthedocs.io/en/stable/tutorial.html">http://gitpython.readthedocs.io/en/stable/tutorial.html</a></p>
<h2 id="错误-Text-file-busy"><a href="#错误-Text-file-busy" class="headerlink" title="错误:Text file busy"></a>错误:Text file busy</h2><p>在调试 B.A.T 烧录器客户端一拖三时发现有时烧录失败但是模组并没有断开，后来看 log 发现是调用 openocd 时发生了问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Info : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints</span><br><span class="line">Info : gdb server disabled</span><br><span class="line">shutdown command invoked</span><br><span class="line">&#x2F;bin&#x2F;sh: 1: .&#x2F;openocd: Text file busy</span><br><span class="line">Disconnected</span><br><span class="line">&#x2F;bin&#x2F;sh: 1: .&#x2F;openocd: Text file busy</span><br><span class="line">&#x2F;bin&#x2F;sh: 1: .&#x2F;openocd: Text file busy</span><br><span class="line">Disconnected</span><br><span class="line">&#x2F;bin&#x2F;sh: 1: .&#x2F;openocd: Text file busy</span><br><span class="line">&#x2F;bin&#x2F;sh: 1: .&#x2F;openocd: Text file busy</span><br><span class="line">Disconnected</span><br><span class="line">&#x2F;bin&#x2F;sh: 1: .&#x2F;openocd: Text file busy</span><br><span class="line">&#x2F;bin&#x2F;sh: 1: .&#x2F;openocd: Text file busy</span><br><span class="line">&#x2F;bin&#x2F;sh: 1: .&#x2F;openocd: Text file busy</span><br><span class="line">&#x2F;bin&#x2F;sh: 1: .&#x2F;openocd: Text file busy</span><br><span class="line">Open On-Chip Debugger 0.10.0+dev-00364-g1756f393 (2018-05-03-10:58)</span><br><span class="line">Licensed under GNU GPL v2</span><br></pre></td></tr></table></figure>

<p>起初怀疑是 openocd 不能多进程调用，后来才发现，其实是在烧录时我不小心 CTRL + S 对 .py 文件做了保存操作，也就是说在执行脚本时又写了此脚本，那么就会导致此错误。</p>
<p>参考：<a href="https://stackoverflow.com/questions/1384398/usr-bin-perl-bad-interpreter-text-file-busy">https://stackoverflow.com/questions/1384398/usr-bin-perl-bad-interpreter-text-file-busy</a></p>
<h2 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h2><p>没有引用，对象就销毁了</p>
<p>一个引用在函数退出后就没有了</p>
<p>函数内的局部对象在退出后就销毁了</p>
<p><a href="https://www.jianshu.com/p/22a8bedc39fd">https://www.jianshu.com/p/22a8bedc39fd</a></p>
<h2 id="map-函数返回值问题"><a href="#map-函数返回值问题" class="headerlink" title="map 函数返回值问题"></a>map 函数返回值问题</h2><p><a href="https://blog.csdn.net/kairen6645/article/details/80252824">https://blog.csdn.net/kairen6645/article/details/80252824</a></p>
<p>今天在使用python map的过程中，发现了一个奇怪问题，map遍历完成后，再次访问map，发现map为空了。</p>
<p>产生这种差异的原因在于：遍历完最后一个元素后，再次访问时会放回空列表。</p>
<p>所以要把 map 结果转换为 list 再返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m &#x3D; list(map(args))</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="http://python.jobbole.com/82750/">Python奇技淫巧</a></p>
<h2 id="十六进制字符串转为十六进制数组。"><a href="#十六进制字符串转为十六进制数组。" class="headerlink" title="十六进制字符串转为十六进制数组。"></a>十六进制字符串转为十六进制数组。</h2><p>   比如把字符串 “ABCDEF” 转为 0xAB, 0xCD, 0xEF。</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usr&#x2F;bin&#x2F;python</span><br><span class="line"></span><br><span class="line">arr &#x3D; &quot;ABCDEF&quot;.decode(&#39;hex&#39;)</span><br><span class="line">f &#x3D; open(&#39;hex.bin&#39;, &#39;wb&#39;)</span><br><span class="line">f.write(arr)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>LwIP</title>
    <url>/2020/12/09/Network/TCPIP/LwIP/LwIP/</url>
    <content><![CDATA[<h2 id="LwIP"><a href="#LwIP" class="headerlink" title="LwIP"></a>LwIP</h2><p>LwIP 官方网站：</p>
<p><a href="http://savannah.nongnu.org/projects/lwip/">http://savannah.nongnu.org/projects/lwip/</a></p>
<p>Git 仓库：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lwIP - A Lightweight TCPIP stack</span><br><span class="line">git clone https:&#x2F;&#x2F;git.savannah.nongnu.org&#x2F;git&#x2F;lwip.git</span><br><span class="line"></span><br><span class="line">Unnamed repository; edit this file &#39;description&#39; to name the repository.</span><br><span class="line">git clone https:&#x2F;&#x2F;git.savannah.nongnu.org&#x2F;git&#x2F;lwip&#x2F;lwip-contrib.git</span><br></pre></td></tr></table></figure>

<p>lwip-contrib 仓库用以一些牛逼的第三方开发者贡献自己的代码。内有各种各样牛逼又实用的代码，比如 ping，shell, httpd 以及在 win32, unix 上的 port。这些代码都是经过官方审查的，就比如 ping 肯定比那些野生的 ping 要好用和稳定。</p>
<h2 id="LwIP-理解"><a href="#LwIP-理解" class="headerlink" title="LwIP 理解"></a>LwIP 理解</h2><p>我觉得协议栈中的 <code>栈</code> 字用的特别精确，协议栈就是一层层协议搭建起来的栈，一层协议负责一种职能，数据在栈中自下而上或者自上而下的传输。比如发送一个 TCP 报文，就自上而下地经过了负责可靠传输的传输层，负责路由和转发的网络层，最终由物理层转换为信号发送出去；而接收到一个原始数据包，就自下而上地经过网络层和传输层的处理，然后递交给用户。</p>
<h2 id="LwIP-移植"><a href="#LwIP-移植" class="headerlink" title="LwIP 移植"></a>LwIP 移植</h2><ol>
<li><p>需要编译哪些 .c，需要包含哪些 .h？</p>
<p>在 src 目录下有 Filelists.mk 文件，里面定义了 LwIP 各种功能所需的 .c。</p>
<p>所有的 .h 都在 include 目录下，并且都是以相对路径的方式引用的，所以只需要把 include 加入头文件搜索路径即可。</p>
<p>当然，最快最保险的方法还是直接用 STM32CubeMX 生成一个 FreeRTOS + LwIP 例程。</p>
</li>
<li><p>需要用户移植哪些文件？</p>
<p>参考《嵌入式网络那些事》，用户只需移植 lwipopts.h, perf.h 和 cc.h 这 3 个头文件即可完成内核（无 OS）的移植，若使用 OS，还需额外移植 sys_arch.c/.h 这 2 个文件。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>lwipopts.h</td>
<td>LwIP configuration</td>
</tr>
<tr>
<td>perf.h</td>
<td>Architecture specific performance measurement.</td>
</tr>
<tr>
<td>cc.h</td>
<td>Architecture environment, some compiler specific, some environment specific.</td>
</tr>
<tr>
<td>sys_arch.c/.h</td>
<td>Abstract operation system  layer.</td>
</tr>
</tbody></table>
<p> <a href="resources/LwIP/doc/sys_arch.txt">doc/sys_arch.txt</a> 可能没有及时更新，其实在 2.0.3 中，cc.h 中的大部分定义在 include/lwip/arch.h 中已经有默认定义了，对于 ARM + GCC 平台可以直接使用。lwip_contrib 的 master 分支最新 commit 上的 ports/unix 可供 ARM + GCC 参考，其 port/include/arch/cc.h 内其实只定义了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define LWIP_TIMEVAL_PRIVATE 0</span><br><span class="line">#include &lt;sys&#x2F;time.h&gt;</span><br><span class="line">#define LWIP_ERRNO_INCLUDE &lt;errno.h&gt;</span><br><span class="line">#define LWIP_RAND() ((u32_t)rand())</span><br></pre></td></tr></table></figure>

<p>如果没有在 lwipopts.h 内定义 LWIP_PERF，则无需 perf.h。</p>
<p>对于 sys_arch.h，<a href="resources/LwIP/doc/sys_arch.txt">doc/sys_arch.txt</a>  内说明如下：</p>
<blockquote>
<p>sys_arch.h - Tied to sys_arch.c</p>
<p>  Arch dependent types for the following objects:</p>
<pre><code>sys_sem_t, sys_mbox_t, sys_thread_t,</code></pre>
<p>  And, optionally:</p>
<pre><code>sys_prot_t</code></pre>
<p>  Defines to set vars of sys_mbox_t and sys_sem_t to NULL.</p>
<pre><code>SYS_MBOX_NULL NULL
SYS_SEM_NULL NULL</code></pre>
</blockquote>
<p>其实少了一个 sys_mutex_t ，如果使用的是 FreeRTOS，则可以直接使用 lwip_contrib 的 ports/freertos 的代码。</p>
<p>lwipopts.h 使用了 ESP32 的即可。</p>
</li>
</ol>
<h2 id="LwIP-初始化"><a href="#LwIP-初始化" class="headerlink" title="LwIP 初始化"></a>LwIP 初始化</h2><p>参考 <a href="resources/LwIP/doc/rawapi.txt">doc/rawapi.txt</a> 的 System initalization 章节。 <a href="resources/LwIP/doc/NO_SYS_SampleCode.c">doc/NO_SYS_SampleCode.c</a> 是示例代码。</p>
<p>参考：<a href="http://www.cnblogs.com/byeyear/p/4169834.html">lwip初始化过程</a></p>
<blockquote>
<p>初始化过程的前半部分主要针对lwip的内存管理和各个协议层，在src/core/init.c中有一个lwip_init()函数已经为我们做好了，直接调用即可；</p>
<p>初始化过程的后半部分初始化网络接口，依次调用以下函数：</p>
<p>netif_add（如果有多个接口则需多次调用）</p>
<p>netif_set_default</p>
<p>netif_set_up</p>
<p>dhcp_start</p>
<p>调用netif_add函数时我们需要提供一个init函数指针，这个指针指向我们自己的硬件接口初始化函数，一般来说就是ethernetif.c中的ethernetif_init()。</p>
</blockquote>
<p>其中 lwip_init 函数内主要是做内存和变量初始化。</p>
<p>在 netif_add 函数内会调用 init 函数指针来初始化网卡。LwIP 的逻辑是认为在添加网卡时就应该初始化它。</p>
<p>LwIP 通过 netif_set_link_up 触发的事件来启动 DHCP discovery。</p>
<p>使用 OS 的 LwIP 初始化只是把第一步的 lwip_init 换成了 tcpip_init。其实 tcpip_init 里也是调用了 lwip_init，并创建了 tcpip_thread。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void</span><br><span class="line">tcpip_init(tcpip_init_done_fn initfunc, void *arg)</span><br><span class="line">&#123;</span><br><span class="line">  lwip_init();</span><br><span class="line">  tcpip_init_done &#x3D; initfunc;</span><br><span class="line">  tcpip_init_done_arg &#x3D; arg;</span><br><span class="line">  if (sys_mbox_new(&amp;mbox, TCPIP_MBOX_SIZE) !&#x3D; ERR_OK) &#123;</span><br><span class="line">    LWIP_ASSERT(&quot;failed to create tcpip_thread mbox&quot;, 0);</span><br><span class="line">  &#125;</span><br><span class="line">#if LWIP_TCPIP_CORE_LOCKING</span><br><span class="line">  if (sys_mutex_new(&amp;lock_tcpip_core) !&#x3D; ERR_OK) &#123;</span><br><span class="line">    LWIP_ASSERT(&quot;failed to create lock_tcpip_core&quot;, 0);</span><br><span class="line">  &#125;</span><br><span class="line">#endif &#x2F;* LWIP_TCPIP_CORE_LOCKING *&#x2F;</span><br><span class="line">  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="netif-set-link-up-和-netif-set-up-的区别"><a href="#netif-set-link-up-和-netif-set-up-的区别" class="headerlink" title="netif_set_link_up 和 netif_set_up 的区别"></a>netif_set_link_up 和 netif_set_up 的区别</h2><p>参考：<a href="http://www.cnblogs.com/byeyear/p/3514573.html">LwIP：处理链路状态改变</a></p>
<p>此作者的 LwIP 分类：<a href="http://www.cnblogs.com/byeyear/category/513604.html">http://www.cnblogs.com/byeyear/category/513604.html</a></p>
<p>参考：<a href="http://lwip.wikia.com/wiki/Network_interfaces_management">Network interfaces management</a></p>
<p>还有个 WiKi：<a href="http://lwip.wikia.com/wiki/LwIP_Wiki">lwIP Wiki</a></p>
<p>它们似乎都认为 netif_set_up 代表着网卡拿到了 IP 地址，可以收发数据了。</p>
<p>但是根据作者本人回复：<a href="http://savannah.nongnu.org/bugs/?func=detailitem&item_id=37068"><em>bug #37068</em>: netif up/down handling is unclear</a></p>
<p>再根据 CHANGELOG：</p>
<blockquote>
<p>  2015-03-05: Simon Goldschmidt</p>
<ul>
<li>netif.c, ip4.c, dhcp.c, autoip.c: fixed bug #37068 (netif up/down handling<br>is unclear): correclty separated administrative status of a netif (up/down)<br>from ‘valid address’ status<br>ATTENTION: netif_set_up() now always has to be called, even when dhcp/autoip<br>is used!</li>
</ul>
</blockquote>
<p>官方解释如下：</p>
<blockquote>
<p>This is the administrative (= software) state of the netif, when the netif is fully configured this function must be called.</p>
</blockquote>
<blockquote>
<p>Bring an interface up, available for processing traffic.</p>
</blockquote>
<p>所以：</p>
<p>netif_set_up 是使能网卡，设置 NETIF_FLAG_UP 标志位，必须在网卡被使用前用户来调用<br>netif_set_link_up 是当网卡链路层 active 时由网卡驱动来设置的，如，station 关联上 AP 后就应该调用netif_set_link_up。</p>
<h2 id="注册-DHCP-回调函数-netif-set-status-callback"><a href="#注册-DHCP-回调函数-netif-set-status-callback" class="headerlink" title="注册 DHCP 回调函数 - netif_set_status_callback()"></a>注册 DHCP 回调函数 - netif_set_status_callback()</h2><p>使用<code>netif_set_status_callback</code>函数可以注册回调函数<code>NETIF_STATUS_CALLBACK</code>，那么协议栈中什么时候回调这个函数呢？ </p>
<ul>
<li><h3 id="NETIF-STATUS-CALLBACK"><a href="#NETIF-STATUS-CALLBACK" class="headerlink" title="NETIF_STATUS_CALLBACK"></a>NETIF_STATUS_CALLBACK</h3></li>
</ul>
<p>有 3 个函数内会回调这个函数，这 3 个函数内会判断网卡状态有变化才调用此回调函数(如网卡从 down 到 up，或者设置了新的IP地址)：</p>
<ol>
<li><code>netif_set_up</code><br>由用户调用以使能网卡</li>
<li><code>netif_set_down</code><br>由用户调用以禁止网卡</li>
<li><code>netif_set_ipaddr</code><br>由<code>netif_set_addr</code>调用（<code>netif_set_ipaddr</code>设置 IP 地址，而<code>netif_set_addr</code>还设置了子网掩码和网关地址）</li>
</ol>
<ul>
<li><h3 id="netif-set-addr"><a href="#netif-set-addr" class="headerlink" title="netif_set_addr"></a>netif_set_addr</h3></li>
</ul>
<p><code>netif_set_addr</code>有 4 个地方调用：</p>
<ol>
<li>netif 中的<code>netif_add</code></li>
<li>dhcp </li>
<li>autoip </li>
<li>ppp </li>
</ol>
<p>autoip 和 ppp 没有用到，<code>netif_add</code>是在初始化网卡时调用的，所以只用分析 dhcp。</p>
<p>dhcp 中有 3 个函数会调用<code>netif_set_addr</code>： </p>
<ol>
<li><code>dhcp_handle_nak</code><br>DHCP server收到 client 的 DHCP request 后，如果由于某些原因不能正常的分配IP地址，则会发送 NAK 给 client，这个 NAK 就在<code>dhcp_handle_nak</code>中处理：首先调用<code>netif_set_addr</code>将网卡的地址恢复默认的<code>IP_ADDR_ANY</code>，然后重启 dhcp。</li>
<li><code>dhcp_bind</code><br>在 2 个函数内被调用： <ol>
<li><code>dhcp_recv</code><br>成功收到 DHCP ACK 后，若网卡不支持 ARP，则会直接调用<code>dhcp_bind</code>来绑定 IP 地址，DHCP 完成。</li>
<li><code>dhcp_timeout</code><br>若用网卡支持 ARP，则在<code>dhcp_recv</code>内会向分配的 IP 地址发送一个 ARP 包以检查是否已被其他主机使用，若没有收到 ARP 回复，则 500ms 后的<code>dhcp_timeout</code>会调用<code>dhcp_bind</code>来绑定 IP 地址，DHCP 完成。</li>
</ol>
</li>
<li><code>dhcp_release</code><br>释放已分配的 IP 地址，也会调用<code>netif_set_addr</code>将网卡的地址恢复默认。</li>
</ol>
<p>所以<code>NETIF_STATUS_CALLBACK</code>可以用作是 DHCP 结果的一个回调函数。</p>
<p>DHCP 最后阶段的 ACK 包中含有：</p>
<ul>
<li>Your IP address：分配给本机的 IP 地址。</li>
<li>Subnet Mask：子网掩码。</li>
<li>Router：网关 IP 地址。</li>
<li>Domain Name Server：DNS 服务器 IP 地址。<br><img src="/Users/snowyang/markdown/resources/LwIP/dhcp_options.png" alt="dhcp_options"></li>
</ul>
<h2 id="Redefination-of-timeval"><a href="#Redefination-of-timeval" class="headerlink" title="Redefination of timeval"></a>Redefination of timeval</h2><p>struct timeval 在 LwIP 的 socket.h 和 GCC 的 _timeval.h 内都有定义，这样在编译时就会出错。</p>
<p>有两种解决方法：</p>
<ul>
<li><p>使用 GCC 的 timeval：在 lwipopts.h 定义 LWIP_TIMEVAL_PRIVATE 为 0，并在 cc.h 内包含头文件 &lt;sys/time.h&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** LWIP_TIMEVAL_PRIVATE: if you want to use the struct timeval provided</span><br><span class="line"> * by your system, set this to 0 and include &lt;sys&#x2F;time.h&gt; in cc.h *&#x2F;</span><br><span class="line">#ifndef LWIP_TIMEVAL_PRIVATE</span><br><span class="line">#define LWIP_TIMEVAL_PRIVATE 1</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if LWIP_TIMEVAL_PRIVATE</span><br><span class="line">struct timeval &#123;</span><br><span class="line">  long    tv_sec;         &#x2F;* seconds *&#x2F;</span><br><span class="line">  long    tv_usec;        &#x2F;* and microseconds *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">#endif &#x2F;* LWIP_TIMEVAL_PRIVATE *&#x2F;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 LwIP 的 timeval：加入全局编译选项<code>-D_TIMEVAL_DEFINED</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef _TIMEVAL_DEFINED</span><br><span class="line">#define _TIMEVAL_DEFINED</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Structure returned by gettimeofday(2) system call, and used in other calls.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct timeval &#123;</span><br><span class="line">	time_t		tv_sec;		&#x2F;* seconds *&#x2F;</span><br><span class="line">	suseconds_t	tv_usec;	&#x2F;* and microseconds *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="DNS-缓存问题"><a href="#DNS-缓存问题" class="headerlink" title="DNS 缓存问题"></a>DNS 缓存问题</h2></li>
</ul>
<p>主机在收到 DNS response 后会将 <Domain : IP> 存储到 DNS cache 内，下次可快速提供给应用层。</p>
<p>当路由器没有外网时，对于主机的 DNS query，一般的路由器是不予理会，那么主机自然会超时失败，但有些路由器会回复一个自己 IP 的 DNS response，那么主机就认为 DNS 成功了，用这个 IP 去建立 HTTPS 连接就会失败。</p>
<p>一般在 HTTPS 连接失败后，主机会再次去查询 DNS，即使此时路由器的外网建立了连接，但由于 DNS 缓存的存在（此所以主机不会发 DNS query），导致得到的还是路由器的 IP，所以会 HTTPS 连接失败。只能等到 DNS 缓存过期主机会发出 DNS query，才能得到正确的 IP 地址 。</p>
<p>有三种方法来解决此问题：</p>
<ul>
<li>在 dns_gethostbyname 内屏蔽 dns_lookup，即不要查询 DNS 缓存。</li>
<li>在调用 gethostbyname 前调用 dns_clean 以清除 DNS 缓存。</li>
<li>把 DNS_MAX_TTL 设置为 1（秒），DNS_MAX_TTL 即为 DNS 缓存的最大时间。推荐此方法，改动最小。</li>
</ul>
<h2 id="DNS-返回多个地址"><a href="#DNS-返回多个地址" class="headerlink" title="DNS 返回多个地址"></a>DNS 返回多个地址</h2><p>LwIP 中的 DNS 只返回一个地址，对于一些开启了负载均衡的服务器就有可能连不上。</p>
<h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><h3 id="注册-DHCP-回调函数"><a href="#注册-DHCP-回调函数" class="headerlink" title="注册 DHCP 回调函数"></a>注册 DHCP 回调函数</h3><p>使用<code>netif_set_status_callback</code>函数可以注册回调函数<code>NETIF_STATUS_CALLBACK</code>，那么协议栈中什么时候回调这个函数呢？ </p>
<p><strong>NETIF_STATUS_CALLBACK</strong></p>
<p>有 3 个函数内会回调这个函数，这 3 个函数内会判断网卡状态有变化才调用此回调函数(如网卡从 down 到 up，或者设置了新的IP地址)：</p>
<ol>
<li><p><code>netif_set_up</code><br> 由用户调用以使能网卡</p>
</li>
<li><p><code>netif_set_down</code><br> 由用户调用以禁止网卡</p>
</li>
<li><p><code>netif_set_ipaddr</code><br> 由<code>netif_set_addr</code>调用（<code>netif_set_ipaddr</code>设置 IP 地址，而<code>netif_set_addr</code>还设置了子网掩码和网关地址）</p>
</li>
</ol>
<p><strong>netif_set_addr</strong></p>
<p><code>netif_set_addr</code>有 4 个地方调用：</p>
<ol>
<li>netif 中的<code>netif_add</code></li>
<li>dhcp </li>
<li>autoip </li>
<li>ppp </li>
</ol>
<p>autoip 和 ppp 没有用到，<code>netif_add</code>是在初始化网卡时调用的，所以只用分析 dhcp。</p>
<p>dhcp 中有 3 个函数会调用<code>netif_set_addr</code>： </p>
<ol>
<li><p><code>dhcp_handle_nak</code><br> DHCP server收到 client 的 DHCP request 后，如果由于某些原因不能正常的分配IP地址，则会发送 NAK 给 client，这个 NAK 就在<code>dhcp_handle_nak</code>中处理：首先调用<code>netif_set_addr</code>将网卡的地址恢复默认的<code>IP_ADDR_ANY</code>，然后重启 dhcp。</p>
</li>
<li><p><code>dhcp_bind</code><br> 在 2 个函数内被调用： </p>
</li>
<li><p><code>dhcp_recv</code>  </p>
<p>成功收到 DHCP ACK 后，若网卡不支持 ARP，则会直接调用<code>dhcp_bind</code>来绑定 IP 地址，DHCP 完成。</p>
</li>
<li><p><code>dhcp_timeout</code>  </p>
<p>若用网卡支持 ARP，则在<code>dhcp_recv</code>内会向分配的 IP 地址发送一个 ARP 包以检查是否已被其他主机使用，若没有收到 ARP 回复，则 500ms 后的<code>dhcp_timeout</code>会调用<code>dhcp_bind</code>来绑定 IP 地址，DHCP 完成。</p>
</li>
<li><p><code>dhcp_release</code><br> 释放已分配的 IP 地址，也会调用<code>netif_set_addr</code>将网卡的地址恢复默认。</p>
</li>
</ol>
<p>所以<code>NETIF_STATUS_CALLBACK</code>可以用作是 DHCP 结果的一个回调函数。</p>
<p>DHCP 最后阶段的 ACK 包中含有：</p>
<ul>
<li>Your IP address：分配给本机的 IP 地址。</li>
<li>Subnet Mask：子网掩码。</li>
<li>Router：网关 IP 地址。</li>
<li>Domain Name Server：DNS 服务器 IP 地址。</li>
</ul>
<h3 id="启动-DHCP-dhcp-start"><a href="#启动-DHCP-dhcp-start" class="headerlink" title="启动 DHCP - dhcp_start"></a>启动 DHCP - dhcp_start</h3><p><code>dhcp_start</code>会检查当前网卡的链路是否active，若是，则直接调用<code>dhcp_discovery</code>，否则，设置 dhcp 的 state 为<code>INIT</code>。</p>
<p>网卡驱动中应该在网卡 link up 后（如 Wi-Fi 网络中 station 连接上 AP) 调用<code>netif_set_link_up</code>，<code>netif_set_link_up</code>内会调用<code>dhcp_network_changed</code>，<code>dhcp_network_changed</code>内发现当前 DHCP 状态为<code>INIT</code>时就调用<code>dhcp_discovery</code>，从而发起 discovery。</p>
<p>所以可以在网卡 link up 前就调用<code>dhcp_start</code>。</p>
<h3 id="DHCP-加速"><a href="#DHCP-加速" class="headerlink" title="DHCP 加速"></a>DHCP 加速</h3><p>有时候连网会很慢，抓包来看是 DHCP 花费了很长时间，究其原因主要有两点：</p>
<ol>
<li>丢包，特别是 Wi-Fi 。</li>
<li>一些路由器是出于安全考虑，会拒绝设备的再次请求。</li>
</ol>
<p>以上两种原因的结果都是超时重传，在 LwIP 中 DHCP 的超时重传时间是 2s，4s，8s …，以 2 的指数倍增长，所以一旦发生超时重传，就会很慢。</p>
<p>解决这个问题的方法也很简单，DHCP 由一个 500ms 的 fine timer 来处理超时事件，那么将所有的 DHCP 超时重传间隔设置为 500ms 即可大大加快 DHCP 的速度。</p>
<p>经过测试，在未优化之前，DHCP 平均需要约 4s 的时间，优化后只需 2s 的时间。</p>
<h2 id="操作系统模拟层移植"><a href="#操作系统模拟层移植" class="headerlink" title="操作系统模拟层移植"></a>操作系统模拟层移植</h2><p>移植操作系统模拟层，本质上就是实现几个操作系统接口函数：信号量，邮箱，互斥量和线程。 </p>
<p>信号量，邮箱和互斥量的操作：</p>
<ul>
<li>new</li>
<li>free</li>
<li>write</li>
<li>read</li>
</ul>
<p>信号量和邮箱还有额外的四个操作：</p>
<ul>
<li>try_write</li>
<li>try_read</li>
<li>valid</li>
<li>invalid </li>
</ul>
<p>线程的操作：</p>
<ul>
<li>new</li>
</ul>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="LwIP-中的-ACK"><a href="#LwIP-中的-ACK" class="headerlink" title="LwIP 中的 ACK"></a>LwIP 中的 ACK</h3><p>在<code>tcp_receive</code>内会调用<code>tcp_ack</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define tcp_ack(pcb)                               \</span><br><span class="line">  do &#123;                                             \</span><br><span class="line">    if((pcb)-&gt;flags &amp; TF_ACK_DELAY) &#123;              \</span><br><span class="line">      (pcb)-&gt;flags &amp;&#x3D; ~TF_ACK_DELAY;               \</span><br><span class="line">      (pcb)-&gt;flags |&#x3D; TF_ACK_NOW;                  \</span><br><span class="line">    &#125;                                              \</span><br><span class="line">    else &#123;                                         \</span><br><span class="line">      (pcb)-&gt;flags |&#x3D; TF_ACK_DELAY;                \</span><br><span class="line">    &#125;                                              \</span><br><span class="line">  &#125; while (0)</span><br></pre></td></tr></table></figure>

<p>收到第一个数据后，会置位<code>TF_ACK_DELAY</code>。</p>
<p>在 250 ms 一次的<code>tcp_fasttmr</code>内，若发现<code>TF_ACK_DELAY</code>仍然处于置位状态，就说明没有捎带确认或累计确认，那必须在这里发送 ACK 出去。</p>
<h3 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h3><p>收到第二个数据后，会置位<code>TF_ACK_NOW</code>并清零<code>TF_ACK_DELAY</code>。</p>
<p>在<code>tcp_input</code>的最后会调用<code>tcp_output</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">err_t</span><br><span class="line">tcp_output(struct tcp_pcb *pcb)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  if (pcb-&gt;flags &amp; TF_ACK_NOW &amp;&amp;</span><br><span class="line">     (seg &#x3D;&#x3D; NULL ||</span><br><span class="line">      lwip_ntohl(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;lastack + seg-&gt;len &gt; wnd)) &#123;</span><br><span class="line">     return tcp_send_empty_ack(pcb);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若<code>TF_ACK_NOW</code>被置位，说明至少收到已经两个数据包了，则立即发送 ACK，这就实现了累计确认的功能。</p>
<h3 id="捎带确认"><a href="#捎带确认" class="headerlink" title="捎带确认"></a>捎带确认</h3><p>在<code>tcp_output</code>发送数据报时，会填充 TCP 头的 ACK 域，并将<code>TF_ACK_DELAY</code>和<code>TF_ACK_NOW</code>清零。</p>
<h2 id="LwIP-尽量减小功能之间的耦合性"><a href="#LwIP-尽量减小功能之间的耦合性" class="headerlink" title="LwIP 尽量减小功能之间的耦合性"></a>LwIP 尽量减小功能之间的耦合性</h2><p>比如，延时确认的 250ms 超时在<code>tcp_fasttmr</code>内处理，它只看<code>TF_ACK_DELAY</code>是否被置位，置位则说明延时确认超时，需要马上发送 ACK。</p>
<p>那么它和其他功能模块之间的唯一耦合就是<code>TF_ACK_DELAY</code>这个 flag。在<code>tcp_receive</code>内只需将<code>TF_ACK_DELAY</code>置位即可，在捎带确认或者累计确认内也只需将<code>TF_ACK_DELAY</code>清零即可。</p>
<p>在 LwIP 中，特别是这种协议超时，普遍使用这种方式。</p>
<h2 id="LwIP-中的日志输出"><a href="#LwIP-中的日志输出" class="headerlink" title="LwIP 中的日志输出"></a>LwIP 中的日志输出</h2><p>LwIP 使用<code>LWIP_DEBUGF</code>宏来输出日志，有 2 个参数：<code>debug</code>和<code>message</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define LWIP_DEBUGF(debug, message) do &#123; \</span><br><span class="line">    if ( \</span><br><span class="line">        ((debug) &amp; LWIP_DBG_ON) &amp;&amp; \</span><br><span class="line">        ((debug) &amp; LWIP_DBG_TYPES_ON) &amp;&amp; \</span><br><span class="line">        ((s16_t)((debug) &amp; LWIP_DBG_MASK_LEVEL) &gt;&#x3D; LWIP_DBG_MIN_LEVEL)) &#123; \</span><br><span class="line">      LWIP_PLATFORM_DIAG(message); \</span><br><span class="line">      if ((debug) &amp; LWIP_DBG_HALT) &#123; \</span><br><span class="line">        while(1); \</span><br><span class="line">      &#125; \</span><br><span class="line">    &#125; \</span><br><span class="line">  &#125; while(0)</span><br></pre></td></tr></table></figure>


<p><code>debug</code>参数的值是模块，类型和等级的组合，这三种是与的关系，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, </span><br><span class="line">(&quot;dhcp_check: could not perform ARP query\n&quot;));</span><br></pre></td></tr></table></figure>

<p>其中，<code>debug</code>的模块是<code>DHCP</code>，类型是<code>trace</code>，等级是<code>warning</code>。  </p>
<p>用户可以在<code>lwipopts.h</code>中配置日志输出：  </p>
<ul>
<li>定义<code>LWIP_DBG_OFF</code>来开启某个模块的日志输出  </li>
<li>定义<code>LWIP_DBG_TYPES_ON</code>来开启某个类型的日志输出  </li>
<li>定义<code>LWIP_DBG_MIN_LEVEL</code>来开启某个等级的日志输出  </li>
</ul>
<h2 id="LwIP-中的协议控制块"><a href="#LwIP-中的协议控制块" class="headerlink" title="LwIP 中的协议控制块"></a>LwIP 中的协议控制块</h2><p><code>PCB</code>全称是<code>Protocol Control Block</code>，即<code>协议控制块</code>，包含着一个连接的属性和方法。</p>
<p>一个控制块代表着着一个协议层的一个实体的属性。</p>
<ul>
<li><p>用户控制块 - netconn，主要属性有：</p>
<ul>
<li>xxx_pcb</li>
<li>同步信号量</li>
<li>数据邮箱，代表着一个用户层次的传输层连接 </li>
</ul>
</li>
<li><p>传输层控制块 - xxx_pcb，代表着一个内核层次的传输层连接,主要属性有：  </p>
<ul>
<li>源/目 IP 地址和端口</li>
<li>回调函数和参数 </li>
</ul>
</li>
<li><p>网卡控制块 - netif，代表着一个网卡，主要属性有：  </p>
<ul>
<li>MAC 地址</li>
<li>IP 地址，子网掩码和网关地址</li>
<li>输入/输出函数</li>
</ul>
</li>
</ul>
<p>网络层的作用是寻址和路由，是个中间层，所以没有对应的控制块。</p>
<p>如下图，多个 UDP 控制块组织成一个链表，协议栈在收到一个 UDP 包后会遍历这个链表查找匹配的控制块，然后调用其接收回调函数（用户也可以注册）。</p>
<p><img src="/../resources/TCP:IP/%5Blwip%5D-udp_pcb.jpg" alt="lwip-udp_pcb"></p>
]]></content>
      <categories>
        <category>LwIP</category>
      </categories>
  </entry>
  <entry>
    <title>Wi-Fi 基本原理 - 入门推荐</title>
    <url>/2020/12/09/Wireless/Wi-Fi/Wi-Fi%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%20-%20%E5%85%A5%E9%97%A8%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<p>原文链接：<a href="https://www.cnblogs.com/zhoading/p/8891206.html">https://www.cnblogs.com/zhoading/p/8891206.html</a></p>
<p>这里对wifi的802.11协议中比较常见的知识做一个基本的总结和整理，便于后续的学习。因为无线网络中涉及术语很多，并且许多协议都是用英文描述，所以有些地方翻译出来会有歧义，这种情况就直接英文来描述了。</p>
<h2 id="一、基本概述"><a href="#一、基本概述" class="headerlink" title="一、基本概述"></a>一、基本概述</h2><h3 id="1、有线和无线网络"><a href="#1、有线和无线网络" class="headerlink" title="1、有线和无线网络"></a>1、有线和无线网络</h3><p>目前有线网络中最著名的是以太网(Ethenet)，但是无线网络WLAN是一个很有前景的发展领域，虽然可能不会完全取代以太网，但是它正拥有越来越多的用户，无线网络中最有前景的是Wifi。本文介绍无线网络相关内容。</p>
<p>无线网络相比有线网络，还是有许多的缺点的：</p>
<p>通信双方因为是通过无线进行通信，所以通信之前需要建立连接；而有线网络就直接用线缆连接，不用这个过程了。</p>
<p>通信双方通信方式是半双工的通信方式；而有线网络可以是全双工。</p>
<a id="more"></a>

<p>通信时在网络层以下出错的概率非常高，所以帧的重传概率很大，需要在网络层之下的协议添加重传的机制（不能只依赖上面TCP/IP的延时等待重传等开销来保证）；而有线网络出错概率非常小，无需在网络层有如此复杂的机制。</p>
<p>数据是在无线环境下进行的，所以抓包非常容易，存在安全隐患。</p>
<p>因为收发无线信号，所以功耗较大，对电池来说是一个考验。</p>
<p>相对有线网络吞吐量低，这一点正在逐步改善，802.11n协议可以达到600Mbps的吞吐量。</p>
<h3 id="2、协议"><a href="#2、协议" class="headerlink" title="2、协议"></a>2、协议</h3><p>Ethenet和Wifi采用的协议都属于IEEE 802协议集。其中，Ethenet以802.3协议做为其网络层以下的协议；而Wifi以802.11做为其网络层以下的协议。无论是有线网络，还是无线网络，其网络层以上的部分，基本一样。</p>
<p>这里主要关注的是Wifi网络中相关的内容。Wifi的802.11协议包含许多子部分。其中按照时间顺序发展，主要有：</p>
<p>（1）802.11a，1999年9月制定，工作在5gHZ的频率范围（频段宽度325MHZ），最大传输速率54mbps，但当时不是很流行，所以使用的不多。</p>
<p>（2）802.11b，1999年9月制定，时间比802.11a稍晚，工作在2.4g的频率范围（频段宽度83.5MHZ），最大传输速率11mbps。</p>
<p>（3）802.11g，2003年6月制定，工作在2.4gHZ频率范围（频段宽度83.5MHZ），最大传输速率54mbps。</p>
<p>（4）802.11n，2009年才被IEEE批准，在2.4gHZ和5gHZ均可工作，最大的传输速率为600mbps。</p>
<p>这些协议均为无线网络的通信所需的基本协议，最新发展的，一般要比最初的有所改善。</p>
<p>另外值得注意的是，802.11n在MAC层上进行了一些重要的改进，所以导致网络性能有了很大的提升例如：</p>
<p>因为传输速率在很大的程度上取决于Channel（信道）的ChannelWidth有多宽，而802.11n中采用了一种技术，可以在传输数据的时候将两个信道合并为一个，再进行传输，极大地提高了传输速率（这又称HT-40，high through）。</p>
<p>802.11n的MIMO（多输入输出）特性，使得两对天线可以在同时同Channel上传输数据，而两者却能够不相互干扰（采用了OFDM特殊的调制技术）。</p>
<h3 id="3、术语"><a href="#3、术语" class="headerlink" title="3、术语"></a>3、术语</h3><p>讲述之前，我们需要对无线网络中一些常用的术语有所了解。这里先列出一些，后面描述中出现的新的术语，将会在描述中解释。</p>
<p><strong>LAN</strong>：即局域网，是路由和主机组成的内部局域网，一般为有线网络。</p>
<p><strong>WAN</strong>：即广域网，是外部一个更大的局域网。</p>
<p><strong>WLAN</strong>（Wireless LAN，即无线局域网）：前面我们说过LAN是局域网，其实大多数指的是有线网络中的局域网，无线网络中的局域网，一般用WLAN。</p>
<p><strong>AP</strong>（Access point的简称，即访问点，接入点）：是一个无线网络中的特殊节点，通过这个节点，无线网络中的其它类型节点可以和无线网络外部以及内部进行通信。这里，AP和无线路由都在一台设备上（即Cisco E3000）。</p>
<p><strong>Station</strong>（工作站）：表示连接到无线网络中的设备，这些设备通过AP，可以和内部其它设备或者无线网络外部通信。</p>
<p><strong>Assosiate</strong>：连接。如果一个Station想要加入到无线网络中，需要和这个无线网络中的AP关联（即Assosiate）。</p>
<p><strong>SSID</strong>：用来标识一个无线网络，后面会详细介绍，我们这里只需了解，每个无线网络都有它自己的SSID。</p>
<p><strong>BSSID</strong>：用来标识一个BSS，其格式和MAC地址一样，是48位的地址格式。一般来说，它就是所处的无线接入点的MAC地址。某种程度来说，它的作用和SSID类似，但是SSID是网络的名字，是给人看的，BSSID是给机器看的，BSSID类似MAC地址。</p>
<p><strong>BSS</strong>（Basic Service Set）：由一组相互通信的工作站组成，是802.11无线网络的基本组件。主要有两种类型的IBSS和基础结构型网络。IBSS又叫ADHOC，组网是临时的，通信方式为Station&lt;-&gt;Station，这里不关注这种组网方式；我们关注的基础结构形网络，其通信方式是Station&lt;-&gt;AP&lt;-&gt;Station，也就是所有无线网络中的设备要想通信，都得经过AP。在无线网络的基础形网络中，最重要的两类设备：AP和Station。</p>
<p><strong>DS</strong>（Distributed System）：即分布式系统。分布式系统属于802.11逻辑组件，负责将帧转发至目的地址，802.11并未规定其技术细节，大多数商业产品以桥接引擎合分步式系统媒介共同构成分布式系统。分步式系统是接入点之间转发帧的骨干网络，一般是以太网。其实，骨干网络并不是分步系统的全部，而是其媒介。主要有三点：骨干网（例如以太网）、桥接器（具有有线无线两个网络接口的接入点包含它）、属于骨干网上的接入点所管辖的基础性网络的station通信（和外界或者BSS内部的station）必须经过DS、而外部路由只知道station的mac地址，所以也需要通过分布式系统才能知道station的具体位置并且正确送到。分步式系统中的接入点之间必须相互传递与之关联的工作站的信息，这样整个分步式系统才能知道哪个station和哪个ap关联，保证分步式系统正常工作（即转达给正确的station）。分步式系统也可以是使用无线媒介(WDS)，不一定一定是以太网。总之，分步式系统骨干网络（例如以太网）做为媒介，连接各个接入点，每个接入点与其内的station可构成BSS，各个接入点中的桥接控制器有到达骨干网络和其内部BSS无线网的接口（类似两个MAC地址），station通信需要通过分布式系统。</p>
<h2 id="二、实践基础"><a href="#二、实践基础" class="headerlink" title="二、实践基础"></a>二、实践基础</h2><h3 id="1、一些参数"><a href="#1、一些参数" class="headerlink" title="1、一些参数"></a>1、一些参数</h3><p><strong>MAC</strong></p>
<p>MAC（即Medium/MediaAccess Control, 介质访问控制），是数据链路层的一部分。MAC地址是烧录在NetworkInterfaceCard(即网卡，简称NIC)里的，它也叫硬件地址,是由48位（即bit，一字节为8位，即1byte=8bits)16进制的数字组成。其中0-23位叫做组织唯一标志符（organizationally unique，简称OUI），是识别LAN（局域网）节点的标识（在有些抓包工具抓包的时候会将前三个字节映射成某种组织名称的字符，也可以选择不显示这种映射）。24-47位是由厂家自己分配。</p>
<p><strong>SSID</strong></p>
<p>表示一个子网的名字，无线路由通过这个名字可以为其它设备标识这个无线路由的子网。设备进行扫描的时候，就会将相应SSID扫描到，然后就能够选择相应的SSID连接到相应的无线网络（当然不扫描，理论上也可以直接指定自己事先已经知道的ssid进行连接）。SSID可以和其它的重复，这样扫描的时候会看到两个同样SSID的无线网络，其实这一般用于将一个无线网络扩大的情况（毕竟无线路由器无线信号的覆盖范围是有线的）：当想要扩大一个无线网络（即SSID固定）的范围的时候，可以给多个路由设置相同的SSID来达到这个目的。（这也是漫游的原理，漫游的时候，我们可以在远方或者本地都能够打电话，也就是访问移动通信网络）。</p>
<p>SSID和BSSID不一定一一对应，一个BSSID在不同的Channel上面可能会对应到多个SSID，但是它们在一个Channel是一一对应的；另外，漫游的时候，虽然SSID不变，但是BSSID一定是会变化的。我们经常可以看到实际数据包中的AP的MAC地址和BSSID只差几位，其实实际设备的MAC地址可能只有一个，和BSSID没什么对应关系。在一个包含了路由功能和AP功能的无线路由器（Fat AP）上面，很可能是：路由器有两个MAC地址，一个用于外网（WAN），一个用于内网(WLAN和LAN)，一般路由器上面或者配置路由器的网页上面只标注外网的MAC地址；内网的MAC地址和外网MAC地址一般只有几位不同（甚至连续，也有些相差很多的例外）。</p>
<p><strong>Band</strong>（频率范围）</p>
<p>一般ap可以支持5g或2.4g两个频率范围段的无线信号。如果两者同时可以设置，而不是互斥那么，这个路由器还能够同时支持两种频段（频段即Band），这相当于这个ap可建立两个无线网络，它们采用不同的频段（这类似收音机在长波范围内收音和短波范围内收音）。</p>
<p><strong>Channel</strong>（信道）</p>
<p>Channel是对频段的进一步划分（将5G或者2.4G的频段范围再划分为几个小的频段，每个频段称作一个Channel），有”5.18GHZ“，“Auto(DFS)”等等，处于不同传输信道上面的数据，如果信道覆盖范围没有重叠，那么不会相互干扰。对于信道的使用，在国际上有所规定。其中有些信道是无需授权即可直接使用的（究竟是那个频段的那个信道，依照各个国家而不同），无需授权使用的意思是，传输数据的时候（无论以哪种无线方式），可以让设备收发的功率导致传输时的数据进入该信道的频率并在该信道所在频段宽度内进行传输；授权的使用的意思是，不允许传输时使用授权信道进行，否则会违反规定，并且干扰该信道上其他数据的传输。另外，除了wifi，微波、红外线、蓝牙（使用802.15协议）的工作频段也都有在2.4gHZ范围内的，所以，它们传输的时候会对wifi传输造成干扰，因为两者在不同的协议下进行通信，所以互相将对方传输的信号识别为噪声。有时候配置AP的时候，Channel中有一个类似“Auto”的选项值，这表示打开AP的时候，AP自己Scan周围的环境，选择一个干扰最小的Channel来进行通信，当选择好了一个Channel的时候，一般就不会改变了。</p>
<p><strong>Channel Width</strong>（信道宽度）</p>
<p>这里的Channel Width是信道的带宽，有”20M HZ“、”40M HZ“等，它表示一个Channel片段的宽度（假设5g的频段宽度总共为100M，平均划分为互不干扰的10个Channel，那么每个Channel的Channel Width就为100M/10=10M，实际Channel并不一定是完全不重叠的）。这个参数可能依赖于一些其它的选项，例如不是802.11N的协议，就可能不会有40M HZ的Channel Width（N模式有一个特点就是可以把两个Channel合并，通过提高ChannelWidth来提高吞吐量）。例如选择了”20M HZ”这个Channel Width之后，后面再选择一个“5.18GHZ”的Channel，则表示以5.18GHZ为中心的前”10M HZ”以及其后面的”10M HZ”频带范围被占用。</p>
<p>至此可知，配置无线AP的时候，如果屋子里面有很多的AP(也就是无线路由接入点）的话，仔细设置它们的Channel Width和Channel可以保证它们相互之间的干扰（类似收音机里面的串台）尽可能小。当然，如果相互干扰了，那么Net Mode所指定的协议也会有相应的处理方式让他们之间进行协调（例如让谁先通信谁等一会再通信之类的），但是这样网络的性能就不如没有干扰的时候好了。</p>
<p><strong>Wireless Security</strong>（无线网络的安全性）</p>
<p>这里主要涉及WEP、WPA、WPA2和RC4、TKIP、AES。</p>
<p>IEEE 802.11 所制定的是技术性标准 ,Wi-Fi 联盟所制定的是商业化标准 , 而 Wi-Fi 所制定的商业化标准基本上也都符合 IEEE 所制定的技术性标准。WEP 是1999年9月通过的 IEEE 802.11 标准的一部分；WPA(Wi-Fi Protected Access) 事实上就是由 Wi-Fi 联盟所制定的安全性标准 , 这个商业化标准存在的目的就是为了要支持 IEEE 802.11i 这个以技术为导向的安全性标准；而 WPA2 其实就是 WPA 的第二个版本。直观点说，WEP是较老的认证方法它有好几个弱点，因此在2003年被WPA淘汰，WPA又在2004年由完整的 IEEE 802.11i 标准（又称为 WPA2）所取代。</p>
<p>WEP（Wired Equivalent Privacy），采用名为RC4的RSA加密技术；WPA(Wi-Fi Protected Access) ，采用新的TKIP算法，TKIP算法保留了RC4所以也有其弱点，但是这个时候更好的CCMP还没完成，所以先在WPA上用TKIP技术；WPA2是WPA的第2个版本，采用CCMP加密协定（在有些路由器等设备上设定加密协定或者加密算法的时候，可能会用类似AES之类的字眼替代CCMP）。所以WPA2+AES是安全性最强的。</p>
<p>另外，在有些无线网路设备的参数中会看到像 WPA-Enterprise / WPA2-Enterprise 以及 WPA-Personal / WPA2-Personal 的字眼 , 其实 WPA-Enterprise / WPA2-Enterprise 就是 WPA / WPA2 ； WPA-Personal / WPA2-Personal 其实就是 WPA-PSK / WPA2-PSK, 也就是以 ”pre-share key” 或 ” passphrase” 的验证 (authentication) 模式来代替 IEEE 802.1X/EAP 的验证模式 ,PSK 模式下不须使用验证服务器 ( 例如 RADIUS Server), 所以特别适合家用或 SOHO 的使用者。</p>
<p>还有，wep是旧的加密方式，工作于802.11B/G模式下而802.11N草案并不支持此加密方式，所以如果802.11N的设备采用wep加密方式后，它也只会工作在802.11b/g模式下，N的性能发挥不出来。</p>
<p>实际中，在有些路由器上面，设置的时候，可能不是严格按照这个规定来设置的（例如设定了采用WPA方式，还可以选择AES），但是大体一样。</p>
<p><strong>Region</strong>（区域）</p>
<p>一般在无线网络中的AP上都有一个参数，表明它是处于哪个Region（地区）。Station根据AP中设置的Region调整其相应的发射功率以遵守该地区的规定。AP的调整过程一般都是手动设定，设置好AP所处的Region之后，这些信息就会在AP发送的Beacon帧（后面会说到）中包含了；通过这个AP连接到无线网络上的Station，从Beacon帧中了解到这些Region信息，并且根据这些信息中的规定和AP进行通信。如果AP开始设置错了，那么Station和AP通信的时候，采用的将会是不符合Region规定的频段，可能会对该Region中的其它传输网络造成干扰，这应当是“非法”的。</p>
<p><strong>Transmission Rate</strong></p>
<p>设置传输速率。这里采用不同的无线网络传输协议（802.11a，802.11b，802.11g等），那么可以设置的速率范围有所不同，这里的速度是指理论的速度，实际中，由于各种干扰因素，传输的速率可能会比设置的小。</p>
<p>一般而言，在无线网络中，对于某种协议的性能进行描述时，我们需要注意的是，描述时提到的传输速率（Datarate）和吞吐量（Throughput）是不同的。Datarate是理论上面最大数据传输速率，而Throughput是数据的实际最大吞吐量。因为厂家以及传输时所使用的协议等各种因素造成的开销，会导致实际吞吐量比理论吞吐量要小，一般实际最大吞吐为理论最大的50%左右（一个不太准确但是相对直观的估计：在网络中，高清视频所需的Throughput也就30mbps左右，网络上一般的视频也就4mbps左右）。</p>
<p><strong>Qos</strong>（质量保证）</p>
<p>无线网络中的QOS是质量保证，大致的意思是，传输数据的时候，考虑各种因素（例如收费策略，所处地区等），以一定的优先级来保证传输的特定要求（一般就是速度），如果带宽足够的话，QOS反而不需要了。</p>
<p>RTS Threshold / CTS Protection Mode：</p>
<p>这里的RTS是Request-To-Send的简写，CTS是Clear-To-Send的简写。设置好RTS的阈值之后，如果超过这个阈值就会在发送信息之前先发送RTS，以减少干扰，相应的CTS会回应之前的RTS。一般都是AP发送CTS数据，而Station发送RTS数据。</p>
<p>这里对RTS和CTS做一个简单解释：假设在同一个AP所覆盖的无线网络范围内的两个Station A和B，它们之间可能会因为距离的原因互相不可见（例如它们在AP网络范围的两端，而这两端的距离大于两者的信号覆盖范围），但是AP却知道它们是在自己的范围内。当一个A想要在AP的网络中进行通信的时候，必定要经过AP转发它的信息，由于A不知道B的存在，所以如果同时B也通过AP进行网络通信，那么会出现AP同时收到A、B两个Station的通信请求，而这在无线网络中是不允许的（无线网络中，同一时刻不能有多个人传输数据）。在这种情况下，B和A互相干扰了对方的通信，但是却互相不可见（不可见的节点互相被称作隐藏节点）。如果在一个网络中，这样的隐藏节点很多，那么势必会影响网络的性能（因为数据一旦发送失败，就要重传，隐藏节点会导致重传的机率增大）。这个时候，可采用RTS和CTS机制。即：在A想要通信的时候，先广播发送RTS给AP，告诉AP“它想要通信”，同时接受到RTS的别的Station（它们对发送RTS的Station而言可见）会知道A将要发送数据，于是它们不会发送数据以免干扰A；AP收到RTS之后，会广播发送CTS，告诉所有在AP范围内的Station（包括对A而言的隐藏节点B）”A将要通信（同时也相当于告诉A，A可以无干扰的发送信息了）”，这样对A而言的隐藏节点B也知道有一个A的存在并且要发送信息了，于是B就不会干扰A了。 这里，A和B两者可以在不同的网络上，也就是说，不同网络的工作站之间也可以通过RTS/CTS来清除相互的干扰。</p>
<p>Beacon Interval：</p>
<p>表示无线路由定期广播其SSID的时间间隔。这个一般不会特别设置，就采用默认值即可。如果不广播了，那么Station端扫描的时候可能会发现不定期广播的AP对应的SSID的网络不见了，所以可能会断开连接。这里定期广播，表示AP会定时向其范围内广播SSID的信息，以表示AP的存在，这样Station进入一个区域之后，就能够通过扫描知道这个区域是否有AP的存在。当然，除了AP广播SSID以告知其无线网络存在之外，Station也可主动广播探寻包，在其能够覆盖的范围内询问是否有AP存在（即我们通常所说的扫描寻找接入点）。</p>
<p>DTIM Interval：</p>
<p>DTIM/TIM表示告诉Station，AP在为Station做package buffer（例如Station睡眠的时候）的缓存时间。为了节省电池使用时间，处于无线网络中的Station可能会在一定时间之后自动进入休眠状态。这个时候，AP会为这个Station缓存发送给它的数据，而处于休眠状态的Station只会在一定时间间隔内给AP发送一个数据帧，以确认是否有发送给自己的数据存在。例如，当我们在主机上ping另外一台睡眠的机器的时候，收到另外一台机器响应的时间，要比它不睡眠的时候响应的时间长很多。</p>
<p>Fragmentation Threshold：</p>
<p>表示一个package的分片阈值。我们可以设置分片大小，当发送的数据包超过这个阈值之后，802.11协议会自动对这个数据包进行分割。如果设置的这个分片值越小，那么整个数据包越容易传输成功（因为如果出错，那么只需要传送一个片段而不是整个包，无线wifi网络中数据传输时出错的概率比有线的以太网要大的多的多），当然开销也越大（因为需要额外的信息标记每个分片，以及各个分片传输成功之后涉及到的重组问题）。</p>
<h3 id="2、抓包"><a href="#2、抓包" class="headerlink" title="2、抓包"></a>2、抓包</h3><p>一般来说，我们的机器上面的软件抓取无线网卡上面的包的时候，其实这些包的目标地址都是这个机器的无线网卡，因为不是发给这个机器无线网卡的包都被网卡过滤了。所以如果我们想要抓取所处无线网络环境下所有的包的时候，需要给机器配备一种特殊的设备（sniffer就是嗅探器），然后再通过抓包工具抓取并分析。有一个硬件设备叫做AirPcap，就是做这个用的，大有几百到上千美金，它可以同时做为嗅探器或者无线网卡使用，不过做为嗅探器的时候，会抓取所有经过它的包。这个工具目前只有Windows上面的驱动，所以使用这个工具，只能在Windows上面，配合Wireshark抓包软件进行抓包。</p>
<p>这里假设采用AirPcap嗅探，Wireshark软件抓包（其它抓包软件，例如linux下面的tcpdump等分析类似）。不用图形方式详细展示具体的抓包过程以及分析方法了，主要说一下抓包（这里的包实际主要指的是网络层以下的包，更常见的称呼应该是数据帧）时候需要注意的问题。</p>
<p>Wireshark展示包的时候，大致都是按照协议规定的字段展示，也些地方按照它自己特定的方式展示。因为这里着重讲述一些抓包时注意的基本原理上面的东西，所以不会对此进行过多阐述。大致就是：Wireshark软件中，对包展示的时候，按照协议规定的字段分别用Header和Body两个部分展示；另外，在Header之前还有两个部分是Wireshark为方便用户而展示的包的大小、时间等全局信息（例如见过表示这个包在B和G mode中的Channel 1时，用”BG1”表示）。所以，其实我们分析的时候，实际应该按照后面的Header和Body两个部分进行。 后面将基于以上所述，进行进一步的讲解。</p>
<p>抓包的时候，需要首先确认这个包是否是完整、正确的包。只要是校验位（checksum）不对的，就是错误的包，也无法确定接收的时候那里出了差错，所以这个包是应该忽略的，几乎没有分析的价值。另外，抓包的时候，由于干扰等原因，抓取的内容可能不是在实际传输所处的Channel上的包（例如在Channel 1上面嗅探，却嗅探到了Channel 2上的包）。</p>
<p>抓取授权阶段的包，需要注意实际的授权是在后面进行的。Authentication的时候，开始阶段实际是Open的（即无授权），也就是说，开始实际已经建立好了连接，所以我们在抓包的时候，开始看到的一般都是通过验证，但是在后面紧接着采用了类似802.11x等安全加强的协议，来进行再次鉴权认证，如果这里无法通过则立即将已经建立的Association断开。这样的机制，是因为原来的802.11没有充分考虑安全才会这样的，这样也兼容了以前的802.11。</p>
<p>抓取的包的数据，要注意这个包是否是被加过密的。根据协议标准的描述，包中如果有dataprotected字段，则表示这个数据本身是被加了密的，不知道这个数据具体是什么，当然，如果有密码，wireshark也有一个可以按照这个密码解密的工具，有时候不好用。这里所说的数据加密和网络的加密不一样，可能访问网络本身是需要密码（网络是security的），而数据本身没有crpted（加密）。对于一个加了密的数据包，我们一般看不出来这个包到底是做什么用的或者什么类型的等等。</p>
<p>抓包的时候，要注意包中指示的源和目的地址以及包的序号。在无线网络中通信的时候，我们抓包的时候可能会看到被抓取的包对应AP的MAC地址是不存在的，其实抓包时AP的MAC是BSSID，它和实际标注的MAC地址不一定一样（但是一般都差不多，也就是之后最后面的几位不一样）。有时候，我们看到抓取的包中的MAC地址有许多只相差几位，那么可能它们都属于一个设备（因为虽然设备可能只标注了一个网卡的MAC地址，但是它却“虚拟”出或者实际有多个MAC地址），所以当我们看到包中对应两个AP的MAC地址几乎一样的时候，一般来说，这两个MAC地址很可能就是一个设备的。还有在抓包的时候，一个地址上面的包的sequence（序号）是连续的，除非丢包了导致重复或者缺失。如果一个设备虚拟出来两个地址，那么也可能由于没有经过什么处理，导致这两个地址上面的包共同起来是连续的（如前所述，这两个地址和MAC很接近，应该是BSSID）。</p>
<p>抓取的数据帧如果是广播帧则不需要确认（ACK），如果是单播帧，则一般需要确认（ACK）。例如，Probe帧是广播帧，所以它无对应的ACK确认帧，对Probe的回复则叫做Probe Response；注意ACK帧本身用于确认，是单播的，但是它本身却不需要再被确认了。从包中的目的MAC地址中，可以看出这个包是广播／多播帧还是单播帧。MAC第一个字节的第一个位是1，表示组播，前两位是1表示广播，第一个字节第一个位是0表示单播。这里注意，MAC不是值，而是一个Pattern，所以没有Endian之说，也没有那个位高，那个MAC大之说。例如：“a8:27:26:….:b7”，这里第一个字节就是a8（10101000），其第一个字节的第一位就是8的最“右”位，即“0”，所以它的第一个字节的第一个位是0，是一个单播地址。其实，这里涉及到大端小端问题，后面也会讲到，总之，以太网线路上按“Big Endian”字节序传送报文（也就是最高字节先传送），而比特序是”Little Endian”（也就是字节内最低位先传送）所以，一个十六进制表示法表示的MAC地址01-80-C2-00-00-00，传送时的bit顺序就是：1000 0000 0000 0001 0100 0011 0000 0000 0000 0000 0000 0000。</p>
<p>使用Wire Shark在抓包或者显示包的时候，都可以设置过滤器（filter）。抓包时候设置的过滤器叫做capture filter，它是用BPF（berkerley package filter）这个比较通用的语言来描述（注意这不是Wireshark专用的filter语言，而是一个通用的语言）。但是抓包期间的过滤，有时候不准，所以我们一般先将所有的包抓取下来，然后用WireShark中显示的过滤器（即view filter）来显示我们关注的包，这里我们可以用macro来定义比较复杂的显示过滤条件。保存的时候，可以用按照显示过滤还是抓取过滤的方式保存内容。</p>
<p>尽量不要抓取Channel Width为40MHZ的Channel上的帧。我们还需要注意的是，使用Sniffer抓取无线网络包的时候，AirPcap无法正常抓取40MHZ Channel Width的包，或者说对抓取这个Channel Width上面的包支持不好。如果非要抓取40MHZ Channel Width的包，那么就在40或者36号Channel上面进行抓取，并在Wireshark上面设置“channel=36，offset+1”（平时offset都是0），这样能够抓取 Channel Width为40MHZ的包（但是，其他Channel上面的40mHZ的包还是无法抓取），这是由AirPcap内部的芯片固件的问题决定的（估计broad com芯片公司也不愿花过多的精力来支持这个很少有人用的抓包工具的这个功能）。</p>
<p>另外，假设一个无线工作站是基于Android系统的（例如智能手机或者平板电子书）那么我们可以利用“wpa_cli status”命令来可以查看当前设备的连接的SSID，BSSID，MAC，IP等信息，（这里“cli”=“command line interface”)。 还有更“复杂”的命令“wc”和“wl”，其中wc是比较上层的命令，wl是下层的命令（是基于芯片是否支持的，例如wl在broadcom芯片上支持，但是在ti上面就没有了）。</p>
<h2 id="三、一些原理"><a href="#三、一些原理" class="headerlink" title="三、一些原理"></a>三、一些原理</h2><h3 id="1、常见的帧"><a href="#1、常见的帧" class="headerlink" title="1、常见的帧"></a>1、常见的帧</h3><p>在802.11中的帧有三种类型：管理帧（Management Frame，例如Beacon帧、Association帧）、控制帧（Control Frame，例如RTS帧、CTS帧、ACK帧）、数据帧（Data Frame，承载数据的载体，其中的DS字段用来标识方向很重要）。帧头部中的类型字段中会标识出该帧属于哪个字段。</p>
<p>ACK帧</p>
<p>单播(unicast)帧都需要用ACK来确认，ACK本身不是广播帧，ACK在MAC上是unicast的，帧中有receive地址字段（用来标识是对谁的确认），但是它却不需要再确认了。ACK只有接收地址（receive）而无源地址（src）和序号（sequence），因为发送和接受是一个整体，发送之后，其他人（除了这个发送的接受者）都不会再发送数据了（无线协议中的冲突避免机制），所以接受者会发送一个没有src的ack帧给receiver，而接收ACK的一端会根据这个知道它收到了一个ACK帧（其实根据协议，应当把发送单播帧和收到它相应的ACK看作一个原子的不可分割的整体，表示一次成功的通信）。</p>
<p>Beacon帧</p>
<p>Beacon帧定时广播发送，主要用来通知网络AP的存在性。Station和AP建立Association的时候，也需要用到Beacon。Station可以通过Scan来扫描到Beacon，从而得知AP的存在，也可以在扫描的时候通过主动发送Probe来探寻AP是否存在。也就是说，建立Association的时候有主动的扫描或者被动的扫描两种方式。另外，Beacon还包含了关于Power Save、以及地区等信息。</p>
<p>Association帧</p>
<p>通常Association帧都有Probe Request和相应的Probe Response。Association的Request中有其所需要的Channel以及Data Rate等状态，以便让AP决定是否让它与自己建立Association。而关联是否成功，主要是看Response中的Status code是否为Success。</p>
<p>Data帧</p>
<p>Data Frame具有方向，这个方向用DS（分布式系统）字段来标识，以区分不同类型帧中关于地址的解析方式；其它的类型Frame例如Control Frame或者管理帧中，这个字段是全零。这个字段用两位表示，这两个位的含义分别表示“To Ds”和“From Ds”，大致含义如下：</p>
<p>（a）To DS：表示Station-&gt;AP，一般也叫Upload。<br>（b）From DS表示AP-&gt;Station，一般也叫Download。</p>
<p>这里，我们可以大致将DS看做AP，To/From是从AP的角度来考虑的。To DS就是让AP干活。另外Data Frame中还有一个比较重要的字段就是Sequence，表示帧的序号。重传帧序号一样，但是多了一个Retry的字段表示该帧是重传的。</p>
<p>为了便于理解，这里再次详细解释一下DS字段的含义：</p>
<p>To DS=0,From DS=0:表示Station之间的AD Hoc类似的通信，或者控制侦、管理侦。</p>
<p>To DS=0,From DS=1:Station接收的侦。</p>
<p>To DS=1,From DS = 0:Station发送的侦。</p>
<p>To DS=1,From DS = 1:无线桥接器上的数据侦。</p>
<p>这里，我们主要关注To DS和From DS分别是01和10的情况，DS虽然大致等于AP但是它不是AP，它其实是一个系统，从Station的角度来看，比较容易理解。并且To DS和From DS一定是无线网络上面数据侦才有的字段。</p>
<h3 id="2、帧和大端小端"><a href="#2、帧和大端小端" class="headerlink" title="2、帧和大端小端"></a>2、帧和大端小端</h3><p>Ethernet和802.11都是按照Little Endian的方式来传输数据，也就是说，而MAC层传输的时候，是采用Little Endian的方式，一个字节一个字节的传输的，前面的低位字节先传输，后面的高位字节后传输（传输单位不是按位而是字节）；在协议标准上描述一个帧的时候，一般是先按照Little Endian的方式对其进行总体描述，然后具体细节说每个字段的值，这时候这个字段值是Big Endian方式表示的，这一点应当注意。</p>
<p>例如，协议标准中可能能对某个帧格式做如下的描述：</p>
<p>|b0|b1|b2|b3|b4|b5|b6|b7|b8|b9|…|…|</p>
<p>这里，最低位b0在最前面，所以这里采用的就是小端的方式来描述帧的总体格式信息。传输的时候，就按照这里的方式，以字节为单位向物理层进行传输（先传b0<del>b7然后b8</del>b16等等）。 但是，在解释这个帧的各个域的时候却采用大端的方式进行描述。假设b3=0,b2=1,b1=0,b0=0四者共同组成一个名字为“FLAG”的域，那么会有类似如下的描述：</p>
<p>FLAG=4(即FLAG为0100)：表示XXX。</p>
<p>所以，协议标准中具体描述某个域的时候，一般直接用大端方式表示的数值(b3b2b1b0=0100)来描述；而传输数据帧或者在协议标准中描述整体帧的时候，中给出的却是小端的方式(b0b1b2b3=0010)。 这里的每个字段都是帧的一个部分，在管理帧（后面会说）中长度不固定的部分又叫IE(information Element) 。</p>
<p>另外注意，内存地址是用来标记每个字节的而不是位，所以内存里面大端小端也是以字节而不是位为单位的（前面描述“大端“、”小端”的时候却以位序而非字节序，这一点需要明辨，不要混淆）。假设奔腾的机器，CPU为32位，采用Little Endian方式，那么表示1这个int类型整数的时候，假设它在数值上是十六进制的”00000001”，那么存放在内存中却是由低位到高位依次存放的，由低到高地址依次为：”01”、”00”、”00”、”00”（也就是说小端方式存放在内存中的时候，是按照含有最低位的字节存放在低地址，注意是字节，在内存中“位”没有地址，所以没有大端小端一说）。在传递帧的时候，也是按照一个字节一个字节的传输，而一个字节内部在实际上其实没有什么端的分别，但是wireshark一律使用“b7b6b5b4b3b2b1b0”这样的方式来用大端的方式显示。</p>
<p>总之，需要注意网络层下面的帧的大端小端问题（不是网络中的字节序，TCP/IP中规定的网络字节序是Big Endian），大致就是：协议规定，传输的时候使用Little Endian；标准描述的时候用Big Endian和Little Endian都用；另外，Wire shark软件抓的包中，好象全都用Big Endian来进行标示（无论是信息窗口还是内存窗口都这样展示）。</p>
<h3 id="3、CSMA-CA的机制"><a href="#3、CSMA-CA的机制" class="headerlink" title="3、CSMA/CA的机制"></a>3、CSMA/CA的机制</h3><p>与以太网的CSMA/CD机制（冲突检测）相对，802.11采用的CSMA/CA机制（冲突避免）。采用这个机制，可以保证每次通信的原子性（即每次通信所需要传输的多种不同类型的帧之间没有夹杂其它通信的帧的干扰），大体过程是：</p>
<p>（a）链路空闲下来之后，所有Station在发送帧之前都首先等待一段时间（即DIFS，又称帧间隔时间）；</p>
<p>（b）到达DIFS之后，所有的Station进入竞争时间窗口（就是竞争期间），将这个竞争时间窗口分割成多个Slot（退避时间间隔），然后每个Station随机选择一个Slot；</p>
<p>（c）当某个Station到达它的Slot对应的时间之后，就开始发送数据。这里，选择的Slot越靠前，则表示Station在DIFS之后再等待的时间（退避时间）越短，也就会越早发送实际数据；</p>
<p>（d）退避窗口的Slot有多个，选择的时候，可能某个Slot被多个站点同时选取，这个时候发送会产生真正的数据冲突（如果多个人同时发送，那么它们都要经过AP来转发，AP无法同时听见多个人的“说话声音”）那么Station就会再重新选择并发送；</p>
<p>（e）当一个Station发送数据之后，所有Station会检测到链路忙，于是放弃尝试发送，等那个Station发送完数据之后，链路开始空闲，于是又进入到（a）重新开始这个过程。</p>
<p>对于以上的机制，如果我们让某个Station经过DIFS之后，选择的Slot越小，就意味着它发送帧的机会越大，也就是说这个Station的优先权越高。这就是Qos（质量保证）的基本，前面也说过，Qos就是“以一定的优先级来保证传输的特定要求”，要获得这种优先级，就要有相应的条件（例如“花钱”）（有一种不常用的无竞争发送，其实就是DIFS之后，不退避而直接发送）。</p>
<p>另外，其实对物理层上来说，所有的发送都是广播，单播与否只是在链路层以上分辨的。上面提到的检测链路是否忙，可以从链路上用软件方式进行（例如增加帧的特殊字段），也可以直接在物理层上进行，实际因为在物理层上成本较高，经常用的是前者，具体参见协议。软件检测大致的思路就是，进行一个通信的时候，这个通信包含多个帧，每个帧有不同的作用，发送的第一帧的时候，会通过其中的某个特殊字段（Duration字段，也叫NAV，即网络分配向量，是一个延迟时间值）告诉所有其它Station，在未来的一段时间内，链路被占用，以完成整个通信过程。这样，其它Station在此期间就不会发送数据干扰这次通信了，以后这个通信的每一帧以及其ACK确认帧之间都会有一个很小的时间间隔（小于DIFS，即SIFS），并且每帧会视情况延长那个Duration字段，保证整个通信期间确实不会有其它人干扰，这样整个通信就是原子性的了。</p>
<h3 id="4、帧的来源和目的地址"><a href="#4、帧的来源和目的地址" class="headerlink" title="4、帧的来源和目的地址"></a>4、帧的来源和目的地址</h3><p>因为无线网络中没有采用有线电缆而是采用无线电波做为传输介质，所以需要将其网络层以下的帧格式封装的更复杂，才能像在有线网络那样传输数据。其中，仅从标识帧的来源和去向方面，无线网络中的帧就需要有四个地址，而不像以太网那样简单只有有两个地址（源和目的）。这四个地址分别是：</p>
<p><strong>SRC</strong>：源地址（SA），和以太网中的一样，就是发帧的最初地址，在以太网和wifi中帧格式转换的时候，互相可以直接复制。</p>
<p><strong>DST</strong>：目的地址（DA），和以太网中的一样，就是最终接受数据帧的地址，在以太网和wifi中帧格式转换的时候，互相可以直接复制。</p>
<p><strong>TX</strong>：也就是Transmiter（TA），表示无线网络中目前实际发送帧者的地址（可能是最初发帧的人，也可能是转发时候的路由）。</p>
<p><strong>RX</strong>：也就是Receiver（RA），表示无线网络中，目前实际接收帧者的地址（可能是最终的接收者，也可能是接收帧以便转发给接收者的ap）。</p>
<p>注意，其实，还有一个BSSID，用来区分不同网络的标识。在802.11帧中，有四个地址字段，一般只用到其中的三个，并且，这四个字段对应哪种地址或者使用哪些地址，根据帧中的另外一个DS字段以及帧的类型而有不同的解释。</p>
<p>举例：</p>
<p>（1）无线网络中的Station和以太网中的Host进行通信：</p>
<p>Station&lt;- - - - -&gt;AP&lt;———-&gt;Host</p>
<p>a）当Station-&gt;Host的时候：</p>
<p>首先Station-&gt;AP，这时候Src=Station,Dst=Host,Tx=Station,Rx=AP，然后AP-&gt;Host，这时候Src=Station,Dst=Host，因为AP转发的时候，是在以太网中，所以没有Tx和Rx。</p>
<p>b）当Host-&gt;Station的时候：</p>
<p>首先Host-&gt;AP，这时候Src=Host，Dst=Station，然后AP-&gt;Station，这时候，Src=Host,Dst=Station,Tx=AP,Rx=Station。</p>
<p>（2）无线网络中的Station之间进行通信：</p>
<p>Station1&lt;- - - - -&gt;AP&lt;- - - - -&gt;Station2</p>
<p>a）当Station1-&gt;Station2时</p>
<p>首先Station1-&gt;AP，Src=Station1,Dst=Station2,Tx=Station1,Rx=AP，然后AP-&gt;Station2，Src=Station1, Dst=Station2, Tx=AP, Rx=Station2。</p>
<p>可见，在无线网络中，始终存在Tx和Rx，但是，这四个地址中还是只有三个地址足矣。</p>
<p>（3）当两个无线网络中的Station进行通信的时候：</p>
<p>Station1&lt;- - - - -&gt;AP1&lt;- - - - -&gt;AP2&lt;- - - - - -&gt;Station2</p>
<p>当Station1-&gt;Station2时：</p>
<p>首先Station1-&gt;AP1，Src=Station,Dst=Station2,Tx=Station1,Rx=AP1，然后AP1-&gt;AP2，Src=Station, Dst=Station2, Tx=AP1, Rx=AP2，然后AP2-&gt;Station2，Src=Station1,Dst=Station2,Tx=AP2,Rx=Station2。</p>
<p>注意，这个时候，AP起到桥接的作用，所以四个地址各不相同，同时，AP之间或者Station和AP之间的那部分连接，也可以是以太网。</p>
<p>综上可知，无线网络中的Station想要通信，必须经过AP来进行“转发”，其实，Tx和Rx是无线网络中的发和收，也就是Radio；而Src和Dst是真正的发送源和接收者。</p>
<h3 id="5、Sleep和Power-save-节电"><a href="#5、Sleep和Power-save-节电" class="headerlink" title="5、Sleep和Power save(节电)"></a>5、Sleep和Power save(节电)</h3><p>其实，无线网络中的Power save是指Station的Sleep（睡眠），并且这个Sleep并不是整个系统的Sleep，确切来说，应该是其wifi中Receiver（接收天线）的Sleep。Station在睡眠的期间还是可以Transmit（发送）的，只是当AP知道Station的Receiver处于Sleep状态时，就不会给Station发送帧了。Station在Sleep之前，会给AP发送一个特殊的帧，告诉AP说它（Station）要睡眠了，AP通过这个帧来记住是这个Station睡眠了，然后AP就不会给这个Station单独发送数据了。</p>
<p>当有和这个Station通信的包想通过AP转达的给这个Station时候，AP会帮这个Station将它们缓存起来，然后在Beacon广播帧中添加一个特殊的位（实际这个位是一个bitmap中的位，这个bitmap表示所有和该AP建立了关联的Station，而这个睡眠的Station的相应位为被置1则表示有消息要传达给这个Station），来表示这个Station有数据到达了（Beacon是定时广播的帧，前面说过它是用来通知无线网络，这个AP的状态），而不是直接发送给Station。而这个睡眠的Station，会在睡眠期间不时地醒来，以检查Beacon帧中的状态，当发现有给它的数据的时候，就会通过发送一个Power Poll的帧来收取数据，收取之后继续睡眠（所以ping一个睡眠状态的Station，响应的时间要慢好多）。</p>
<p>对于发送给这个Station的广播帧，其处理方式和普通帧有一点不同：当有广播帧要传达给这个Station的时候，AP会为这个Station缓存发送给它的广播帧，但是缓存的时间是DTIM（一般为300ms）。注意：单播帧缓存的时间不一定是多少，广播帧却缓存DTIM的时间。AP每发送一个Beacon的时候，都会将Dtim减少1，而Station睡眠的时候，会不时地醒来，查看一下Beacon帧中的dtim值。当Station发现其DTIM值变成0的时候，就醒来长一些的时间，看看有没有广播给它的数据，如果有的话就用类似Power Save Poll的帧接受，没有则继续睡眠。</p>
<p>这里，接收数据是根据是否有more data类似的字段来确认是否有更多的数据的；重发的帧是用类似retry的字段来标记。另外注意，当Station进行Sleep的时候，还是可以主动Tranmit消息的，当Station主动Transmit消息的时候，它会等待Reply，所以这个时候，Receiver是on的状态。</p>
<p>可见不同状态，电源消耗状态不同（传送比接收更耗电），另外，如果电源供电不足，在某个状态中就会出现通信失败的情况。（好像ap上面broadcom芯片中的睡眠之后，醒来立即重新发送的时候经常开始会失败，可能就是这个原因）。</p>
<h3 id="6、建立Association"><a href="#6、建立Association" class="headerlink" title="6、建立Association"></a>6、建立Association</h3><p>下面是Station和Ap建立开放Association的过程：<br>（0）Ap周期性地广播Beacon帧<br>（1）Station广播Probe Request到达Ap<br>（2）Ap向Station发送Probe Reponse<br>（3）Station向Ap发送ACK<br>（4）Station向Ap发送Authentication Request<br>（5）Ap向Station发送ACK<br>（6）Ap向Station发送Authentication Reponse<br>（7）Station向Ap发送ACK<br>（8）Station向Ap发送Association Request<br>（9）Ap向Station发送ACK<br>（10）Ap向Station发送Association Reponse<br>（11）Station向Ap发送ACK<br>（12）Station和Ap开始相互通信。</p>
<p>可见，广播帧不用回复，单播帧需要用ACK确认，ACK本身不用被确认。</p>
<p>本文内容主要来自学习的总结以及网络，主要集中于无线网络中物理层以上相对比较常见的部分，如果想要理解更详细和全面的内容则需参考相关书籍以及网络协议。由于对此方面的知识也是在初步学习之中，若文章中有错误和不完整之处，谢谢读者指正。^_^</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="http://imgtec.eetrend.com/d6-imgtec/blog/2018-12/19335.html">常见的WiFi攻击技术及检测方法总结</a></li>
<li><a href="http://imgtec.eetrend.com/d6-imgtec/blog/2018-12/19263.html">5G时代即将到来，你每天都在使用的WiFi会消失不见吗？</a></li>
<li><a href="http://imgtec.eetrend.com/d6-imgtec/blog/2018-10/19076.html">蓝牙5与WiFi的相爱相杀</a></li>
<li><a href="http://imgtec.eetrend.com/d6-imgtec/forum/2018-08/17060.html">以后的5G技术会不会取代wifi？</a></li>
<li><a href="http://imgtec.eetrend.com/d6-imgtec/blog/2018-07/16910.html">总结：wifi的802.11协议中比较常见的知识</a></li>
<li><a href="http://imgtec.eetrend.com/d6-imgtec/forum/2018-07/16868.html">9张图，让你家WiFi速度飞起来</a></li>
<li><a href="http://imgtec.eetrend.com/d6-imgtec/forum/2018-06/16790.html">WiFi联盟正式推出WPA3安全协议，智能家居连接将更加安全</a></li>
<li><a href="http://imgtec.eetrend.com/d6-imgtec/forum/2018-06/16742.html">蓝牙5和早前的蓝牙4.x有啥差别？和WIFI对比又有啥优势?</a></li>
<li><a href="http://imgtec.eetrend.com/d6-imgtec/blog/2018-06/16701.html">史上最全无线网桥知识，收藏这一篇就够了！</a></li>
<li><a href="http://imgtec.eetrend.com/d6-imgtec/forum/2018-03/11363.html">5G真的要把WiFi干掉了吗？</a></li>
</ul>
]]></content>
      <categories>
        <category>Wi-Fi</category>
      </categories>
  </entry>
</search>
